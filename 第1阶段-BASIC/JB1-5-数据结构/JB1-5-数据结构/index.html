<!doctype html><html lang=en><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><style>:root{--accent-color:#FF4D4D}</style><title>JB1-5-数据结构</title>
<meta name=description content="Java道经第1卷 - 第5阶 - v1-5-basic-algorithm(JAR) - 数据结构
CH01. 数组数据结构 EP01. 冒泡排序算法 心法: 冒泡排序算法 - 交换
基础概念: 冒泡排序过程中，较大或较小的元素会经由交换慢慢浮到数列的顶端，故名冒泡排序。 核心思想: 从头开始，不断地比较相邻的两个元 …"><meta name=keywords content='blog,lsx2216,hugo'><meta property="og:url" content="https://lsx2216.netlify.app/%E7%AC%AC1%E9%98%B6%E6%AE%B5-BASIC/JB1-5-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/JB1-5-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><meta property="og:type" content="website"><meta property="og:title" content="JB1-5-数据结构"><meta property="og:description" content="Java道经第1卷 - 第5阶 - v1-5-basic-algorithm(JAR) - 数据结构
CH01. 数组数据结构 EP01. 冒泡排序算法 心法: 冒泡排序算法 - 交换
基础概念: 冒泡排序过程中，较大或较小的元素会经由交换慢慢浮到数列的顶端，故名冒泡排序。 核心思想: 从头开始，不断地比较相邻的两个元 …"><meta property="og:image" content="https://lsx2216.netlify.app/assets/images/user.jpg"><meta property="og:image:secure_url" content="https://lsx2216.netlify.app/assets/images/user.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="JB1-5-数据结构"><meta name=twitter:description content="Java道经第1卷 - 第5阶 - v1-5-basic-algorithm(JAR) - 数据结构
CH01. 数组数据结构 EP01. 冒泡排序算法 心法: 冒泡排序算法 - 交换
基础概念: 冒泡排序过程中，较大或较小的元素会经由交换慢慢浮到数列的顶端，故名冒泡排序。 核心思想: 从头开始，不断地比较相邻的两个元 …"><meta property="twitter:domain" content="https://lsx2216.netlify.app/%E7%AC%AC1%E9%98%B6%E6%AE%B5-BASIC/JB1-5-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/JB1-5-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><meta property="twitter:url" content="https://lsx2216.netlify.app/%E7%AC%AC1%E9%98%B6%E6%AE%B5-BASIC/JB1-5-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/JB1-5-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><meta name=twitter:image content="https://lsx2216.netlify.app/assets/images/user.jpg"><link rel=canonical href=https://lsx2216.netlify.app/%E7%AC%AC1%E9%98%B6%E6%AE%B5-BASIC/JB1-5-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/JB1-5-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/><link rel=stylesheet type=text/css href=/css/normalize.min.css media=print><link rel=stylesheet type=text/css href=/css/main.min.css><link id=dark-theme rel=stylesheet href=/css/dark.min.css><script src=/js/bundle.min.3eb19cb61dde9e37b9522867f3e024aeb68e26ab8e03252e46e365abcb19acf7.js integrity="sha256-PrGcth3enje5Uihn8+AkrraOJquOAyUuRuNlq8sZrPc="></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css integrity=sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js integrity=sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})})</script>    <link rel="shortcut icon" href="/assets/images/user.jpg" type="image/x-icon">
</head><body><script>setThemeByUserPref()</script><header class=header><nav class=header-nav><div class=avatar><a href=https://lsx2216.netlify.app/><img src=/assets/images/user.jpg alt=avatar></a></div><div class=nav-title><a class=nav-brand href=https://lsx2216.netlify.app/>lsx2216</a></div><div class=nav-links><div class=nav-link><a href=https://lsx2216.netlify.app/ aria-label><span data-feather=home></span> Home</a></div><div class=nav-link><a href=https://lsx2216.netlify.app/projects/ aria-label><span data-feather=code></span> Projects</a></div><div class=nav-link><a href=https://github.com aria-label=github><span data-feather=github></span></a></div><span class=nav-icons-divider></span><div class="nav-link dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
<a aria-hidden=true role=switch><span class=theme-toggle-icon data-feather=moon></span></a></div><div class=nav-link id=hamburger-menu-toggle><span class="sr-only hamburger-menu-toggle-screen-reader-target">menu</span>
<a aria-checked=false aria-labelledby=hamburger-menu-toggle id=hamburger-menu-toggle-target role=switch><span data-feather=menu></span></a></div><ul class="nav-hamburger-list visibility-hidden"><li class=nav-item><a href=https://lsx2216.netlify.app/><span data-feather=home></span> Home</a></li><li class=nav-item><a href=https://lsx2216.netlify.app/projects/><span data-feather=code></span> Projects</a></li><li class=nav-item><a href=https://github.com><span data-feather=github></span></a></li><li class="nav-item dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
<a role=switch><span class=theme-toggle-icon data-feather=moon></span></a></li></ul></div></nav></header><main id=content><div class="post container"><div class=post-header-section><h1>JB1-5-数据结构</h1></div><div class=post-content><blockquote><p>Java道经第1卷 - 第5阶 - v1-5-basic-algorithm(JAR) - 数据结构</p></blockquote><hr><h1 id=ch01-数组数据结构>CH01. 数组数据结构</h1><h2 id=ep01-冒泡排序算法>EP01. 冒泡排序算法</h2><blockquote><p>心法: 冒泡排序算法 - 交换</p></blockquote><ul><li>基础概念:<ul><li>冒泡排序过程中，较大或较小的元素会经由交换慢慢浮到数列的顶端，故名冒泡排序。</li></ul></li><li>核心思想:<ul><li>从头开始，不断地比较相邻的两个元素，并进行对应的交换，直到最后排序完成。</li></ul></li></ul><blockquote><p>心法: 冒泡排序算法流程</p></blockquote><ol><li>假设需要对长度为 <code>N</code> 的数组进行升序排序。</li><li>第 <code>1</code> 轮操作:<ul><li>从头开始比较每一对相邻元素，共需比较 <code>N-1</code> 次。</li><li>若前数比后数大则交换，否则跳过，即让大的元素向后移动。</li><li>轮次结束后，数组 <code>N-1号位</code> 元素一定是数组中 <code>第1大</code> 的元素。</li></ul></li><li>第 <code>2</code> 轮操作:<ul><li>从头开始比较每一对相邻元素，共需比较 <code>N-2</code> 次。</li><li>若前数比后数大则交换，否则跳过，即让大的元素向后移动。</li><li>轮次结束后，数组 <code>N-2号位</code> 元素一定是数组中 <code>第2大</code> 的元素。</li></ul></li><li>第 <code>N-1</code> 轮操作:<ul><li>比较最后一对相邻元素，共需比较 <code>1</code> 次。</li><li>若前数比后数大则交换，否则跳过，即让大的元素向后移动。</li><li>轮次结束后，数组 <code>2号位</code> 元素一定是数组中 <code>第2大</code> 的元素。</li></ul></li><li>排序完成。</li></ol><blockquote><p>武技: 使用冒泡排序算法对数组进行升序排序</p></blockquote><ol><li>开发测试方法 <code>BubbleSortTest -> testBubbleSort()</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> sort;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BubbleSortTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 使用冒泡排序算法对数组 [3, 1, 4, 2, 5] 进行升序排序*/</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testBubbleSort</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> arr <span style=color:#f92672>=</span> {101, 2, 23, 133, 412, 23, 412, 51, 235};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 每一轮: 9个数，两两相比，要比9-1轮</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0, j <span style=color:#f92672>=</span> arr.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> 1; i <span style=color:#f92672>&lt;</span> j; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 相邻两个数比较，需要比较length-1-i次</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> 0, n <span style=color:#f92672>=</span> arr.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> 1 <span style=color:#f92672>-</span> i; m <span style=color:#f92672>&lt;</span> n; m<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 前数大于后数就交换，循环一次完毕保证最大的数排最后</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (arr<span style=color:#f92672>[</span>m<span style=color:#f92672>]</span> <span style=color:#f92672>&gt;</span> arr<span style=color:#f92672>[</span>m <span style=color:#f92672>+</span> 1<span style=color:#f92672>]</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>int</span> temp <span style=color:#f92672>=</span> arr<span style=color:#f92672>[</span>m<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>                    arr<span style=color:#f92672>[</span>m<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> arr<span style=color:#f92672>[</span>m <span style=color:#f92672>+</span> 1<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>                    arr<span style=color:#f92672>[</span>m <span style=color:#f92672>+</span> 1<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> temp;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Arrays.<span style=color:#a6e22e>toString</span>(arr));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=ep02-选择排序算法>EP02. 选择排序算法</h2><blockquote><p>心法: 选择排序算法 - 抢夺</p></blockquote><ul><li>核心思想:<ul><li>每一次从无序区中选出最小或最大的一个元素，追加到有序区，直到全部无序区的数据元素排完。</li></ul></li><li>选择排序不稳定: 如序列 <code>[5， 5， 3]</code>:<ul><li>第1轮就将第一个 <code>5</code> 与 <code>3</code> 交换，导致第一个 <code>5</code> 挪动到第二个 <code>5</code> 后面。</li></ul></li></ul><blockquote><p>心法: 选择排序算法流程</p></blockquote><ol><li>假设需要对长度为 <code>N</code> 的数组进行升序排序:<ul><li>排序开始之前，全部元素处于无序区，暂无有序区。</li></ul></li><li>第 <code>1</code> 轮操作:<ul><li>使用数组中的 <code>0号位</code> 元素作为挑战变量，假设为 <code>A</code>。</li><li>使用 <code>A</code> 依次和无序区其他元素比较，发现小的就抢夺其值，共需比较 <code>N-1</code> 次。</li><li>轮次结束后，数组 <code>0号位</code> 存放的一定是数组中 <code>第1小</code> 的值，进入有序区。</li></ul></li><li>第 <code>2</code> 轮操作:<ul><li>使用数组中的 <code>1号位</code> 元素作为挑战变量，假设为 <code>B</code>。</li><li>使用 <code>B</code> 依次和无序区其他元素比较，发现小的就抢夺其值，共需比较 <code>N-2</code> 次。</li><li>轮次结束后，数组 <code>1号位</code> 存放的一定是数组中 <code>第2小</code> 的值，进入有序区。</li></ul></li><li>第 <code>N-1</code> 轮操作:<ul><li>使用数组中的 <code>N-1号位</code> 元素作为挑战变量，假设为 <code>M</code>。</li><li>使用 <code>B</code> 依次和无序区最后一个元素比较，比它小的就抢夺其值，共需比较 <code>1</code> 次。</li><li>轮次结束后，数组 <code>N-1号位</code> 存放的一定是数组中 <code>N-1小</code> 的值，进入有序区。</li></ul></li><li>排序完成，此时无序区没有任何元素了，全部元素处于有序区。</li></ol><blockquote><p>武技: 使用选择排序法对数组进行升序排序</p></blockquote><ol><li>开发测试方法 <code>SelectionSortTest -> selectionSort()</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> sort;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SelectionSortTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 使用选择排序算法对数组 [3, 1, 4, 2, 5] 进行升序排序*/</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>selectionSort</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> arr <span style=color:#f92672>=</span> {3, 1, 4, 2, 5};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 每轮都将确定将一个无序区中最小的元素追加到有序区，需要比较N-1次</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0, j <span style=color:#f92672>=</span> arr.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> 1; i <span style=color:#f92672>&lt;</span> j; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 每一次都拿一个元素和后面所有的元素进行比较</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> 1, n <span style=color:#f92672>=</span> arr.<span style=color:#a6e22e>length</span>; m <span style=color:#f92672>&lt;</span> n; m<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 只要比arr[x]小，arr[x]就将其抢夺，最终arr[x]一定是无序区最小的元素</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (arr<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>&lt;</span> arr<span style=color:#f92672>[</span>m<span style=color:#f92672>]</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>int</span> temp <span style=color:#f92672>=</span> arr<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>                    arr<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> arr<span style=color:#f92672>[</span>m<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>                    arr<span style=color:#f92672>[</span>m<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> temp;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Arrays.<span style=color:#a6e22e>toString</span>(arr));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=ep03-插入排序算法>EP03. 插入排序算法</h2><blockquote><p>心法: 插入排序算法 - 插队</p></blockquote><ul><li>基本概念:<ul><li>插入排序算法算法适用于少量数据的排序，是稳定的排序方法。</li><li>插入排序在对几乎已经排好序的数据操作时，效率高。</li></ul></li><li>核心思想:<ul><li>在一个有序队列中插入一个新的元素后，该队列仍然有序。</li><li>可对比理解为生活中按大小个排序的思想。</li></ul></li></ul><blockquote><p>心法: 插入排序算法流程</p></blockquote><ol><li>假设需要对长度为 <code>N</code> 的数组进行升序排序:<ul><li>排序开始之前，将数组 <code>0号位</code> 元素加入队伍，其余元素都处于队伍之外。</li></ul></li><li>第 <code>1</code> 轮操作:<ul><li>将数组中的 <code>1号位</code> 元素视为要插队的元素，假设为 <code>A</code>。</li><li>使用 <code>A</code> 在队伍中从后向前依次比较，发现小的就交换位置，共需比较 <code>1</code> 次。</li><li>轮次结束后，得到一个新的队伍，队伍中存在 <code>2</code> 个元素。</li></ul></li><li>第 <code>2</code> 轮操作:<ul><li>将数组中的 <code>2号位</code> 元素视为要插队的元素，假设为 <code>B</code>。</li><li>使用 <code>B</code> 在队伍中从后向前依次比较，发现小的就交换位置，共需比较 <code>2</code> 次。</li><li>轮次结束后，得到一个新的队伍，队伍中存在 <code>3</code> 个元素。</li></ul></li><li>第 <code>N-1</code> 轮操作:<ul><li>将数组中的 <code>N-1号位</code> 元素视为要插队的元素，假设为 <code>M</code>。</li><li>使用 <code>M</code> 在队伍中从后向前依次比较，发现小的就交换位置，共需比较 <code>N-1</code> 次。</li><li>轮次结束后，得到一个新的队伍，队伍中存在 <code>N</code> 个元素。</li></ul></li><li>排序完成，此时队伍中的元素都是从小到大排好序的了。</li></ol><blockquote><p>武技: 使用插入排序法对数组进行升序排序</p></blockquote><ol><li>开发测试方法 <code>InsertSortTest -> insertSort()</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> sort;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>InsertSortTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 使用插入排序算法对数组 [3, 1, 4, 2, 5] 进行升序排序*/</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insertSort</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> arr <span style=color:#f92672>=</span> {3, 1, 4, 2, 5};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 从第i个位置开始依次向前比较，i从1开始，因为第0个人无法和它前面的人进行比较</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 由于你的i是从1开始的，所以判断条件要改为i&lt;arrs.length，不能使用length-1，否则会少比一次</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1, j <span style=color:#f92672>=</span> arr.<span style=color:#a6e22e>length</span>; i <span style=color:#f92672>&lt;</span> j; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 角标为1的人（第二个人），最多需要向前比较1次</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 角标为2的人（第三个人），最多需要向前比较2次</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 角标为i的人（第i+1个人），最多需要向前比较i次，所以m = i ; m &gt; 0 ; m--</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> i; m <span style=color:#f92672>&gt;</span> 0; m<span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 若后面的数小，交换，若后面的数大，直接结束循环，没有再向前比较的必要</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (arr<span style=color:#f92672>[</span>m<span style=color:#f92672>]</span> <span style=color:#f92672>&lt;</span> arr<span style=color:#f92672>[</span>m <span style=color:#f92672>-</span> 1<span style=color:#f92672>]</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>int</span> temp <span style=color:#f92672>=</span> arr<span style=color:#f92672>[</span>m<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>                    arr<span style=color:#f92672>[</span>m<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> arr<span style=color:#f92672>[</span>m <span style=color:#f92672>-</span> 1<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>                    arr<span style=color:#f92672>[</span>m <span style=color:#f92672>-</span> 1<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> temp;
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Arrays.<span style=color:#a6e22e>toString</span>(arr));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=ep04-希尔排序算法>EP04. 希尔排序算法</h2><blockquote><p>心法: 希尔排序算法 - 步长</p></blockquote><ul><li>基本概念:<ul><li>希尔排序是插入排序的优化版本，是稳定的排序方法。</li></ul></li><li>核心思想:<ul><li>将数组中的元素，按下标的一定增量分组，然后对每一组进行插入排序。</li><li>然后缩减增量后，重复再进行排序，直到增量缩减到1时，进行最后一次直接插入排序，排序结束。</li></ul></li></ul><blockquote><p>心法: 希尔排序算法流程</p></blockquote><ol><li>假设需要对长度为 <code>N</code> 的数组进行升序排序:<ul><li>排序开始之前，设定初始步长为 <code>数组长度 / 2</code>，尾为 <code>步长</code>，头为 <code>尾 - 步长</code>。</li></ul></li><li>第 <code>1</code> 轮操作:<ul><li>设置 <code>尾 = 步长</code>，设置 <code>头 = 尾 - 步长</code>。</li><li>比较 <code>尾</code> 和 <code>头</code>，将较小的值向前交换，作为下一次比较的 <code>尾</code>，这个 <code>尾</code> 是临时的。</li><li>将 <code>头</code> 向前移动一个 <code>步长</code> 的距离，继续和临时的 <code>尾</code> 比较并交换，直到 <code>头</code> 移动到数组开头时停止。</li><li>将 <code>尾</code> 向后移动一个位置，然后重新计算 <code>头</code>，并开启新一轮比较，直到 <code>尾</code> 移动到数组末尾时停止。</li><li>轮次结束后，得到一个新的数组，该数组比原始数组有序了一点，但并不是完全有序。</li></ul></li><li>第 <code>2</code> 轮操作:<ul><li>缩减 <code>步长</code> 为当前 <code>步长</code> 的一半，后续操作和第1轮步骤一致。</li><li>直到步长缩减为1时，进行最后一轮操作。</li></ul></li><li>排序完成，此时队伍中的元素都是从小到大排好序的了。</li></ol><blockquote><p>武技: 希尔排序算法</p></blockquote><ol><li>开发测试方法 <code>ShellSortTest -> testShellSort()</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> sort;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ShellSortTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testShellSort</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 初始数组</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> arr <span style=color:#f92672>=</span> {101, 2, 23, 133, 412, 23, 412, 51, 235};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [步长]: 初始长度为数组长度的一半</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> step <span style=color:#f92672>=</span> arr.<span style=color:#a6e22e>length</span> <span style=color:#f92672>/</span> 2;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 当 [步长] 缩减到0时排序完成</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (step <span style=color:#f92672>&gt;</span> 0) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// [尾]: 从step开始向后移动</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> tail <span style=color:#f92672>=</span> step;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 当 [尾] 移动到数组末尾时结束，需要缩减一次 [步长] 后重新循环</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (tail <span style=color:#f92672>&lt;</span> arr.<span style=color:#a6e22e>length</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// [头]: 从倒数第2个端点开始向前移动</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> head <span style=color:#f92672>=</span> tail <span style=color:#f92672>-</span> step;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 当 [头] 移动到数组开头时结束，需要向后移动一次 [尾] 后重新循环</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (head <span style=color:#f92672>&gt;=</span> 0) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 升序排序: 比较 [当前头元素] 和 [当前尾元素]，值小的向前交换</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (arr<span style=color:#f92672>[</span>head<span style=color:#f92672>]</span> <span style=color:#f92672>&gt;</span> arr<span style=color:#f92672>[</span>head <span style=color:#f92672>+</span> step<span style=color:#f92672>]</span>) {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>int</span> temp <span style=color:#f92672>=</span> arr<span style=color:#f92672>[</span>head<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>                        arr<span style=color:#f92672>[</span>head<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> arr<span style=color:#f92672>[</span>head <span style=color:#f92672>+</span> step<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>                        arr<span style=color:#f92672>[</span>head <span style=color:#f92672>+</span> step<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> temp;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 向前移动一次 [头]，每次移动的距离为当前 [步长]</span>
</span></span><span style=display:flex><span>                    head <span style=color:#f92672>-=</span> step;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 向后移动一次 [尾]，每次移动的距离为1</span>
</span></span><span style=display:flex><span>                tail<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// [步长] 缩减一半</span>
</span></span><span style=display:flex><span>            step <span style=color:#f92672>/=</span> 2;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;排序后: &#34;</span> <span style=color:#f92672>+</span> Arrays.<span style=color:#a6e22e>toString</span>(arr));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=ep05-二分查找算法>EP05. 二分查找算法</h2><blockquote><p>心法: 二分查找算法流程</p></blockquote><ol><li>假设需要在长度为 <code>N</code> 的数组中查找 <code>M</code> 元素:<ul><li>将数组排好序。</li></ul></li><li>第 <code>1</code> 步: 计算查找区间的中间位:<ul><li>最高位: <code>highIndex = N - 1</code>: 初始值，后续会被覆盖。</li><li>最低位: <code>lowIndex = 0</code>: 初始值，后续会被覆盖。</li><li>中间位: <code>midIndex = (highIndex + lowIndex) / 2</code>。</li></ul></li><li>第 <code>2</code> 步: 用中间位上的元素与 <code>M</code> 进行比较:<ul><li>若等于 <code>M</code>: 查找成功，返回元素对应的位置，即 <code>return midIndex</code>。</li><li>若大于 <code>M</code>: 划掉中间位及中间位之后的全部元素，即 <code>highIndex = midIndex - 1</code>。</li><li>若小于 <code>M</code>: 划掉中间位及中间位之前的全部元素，即 <code>lowIndex = midIndex + 1</code>。</li></ul></li><li>重复第 <code>1</code> 和第 <code>2</code> 步骤，直到找到该元素的位置:<ul><li>若最高位和最低位已相遇，仍然未找到该元素，则返回 <code>-1</code> 表示元素不存在。</li></ul></li></ol><blockquote><p>武技: 使用二分查找算法数组中的值</p></blockquote><ol><li>开发测试类 <code>BinarySearchTest -> testBinarySearch()</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> search;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BinarySearchTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 二分查找算法
</span></span></span><span style=display:flex><span><span style=color:#75715e>     *
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @param arr    待查找数组
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @param target 目标元素
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @return 目标元素在数组中的索引，若未找到则返回-1
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>binarySearch</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> arr, <span style=color:#66d9ef>int</span> target) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> result <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>1;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 最低位，最高位和中间位</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> lowIndex <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> highIndex <span style=color:#f92672>=</span> arr.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> 1;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> midIndex <span style=color:#f92672>=</span> (lowIndex <span style=color:#f92672>+</span> highIndex) <span style=color:#f92672>/</span> 2;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 当最低位小于等于最高位的时候进行二分查找</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (lowIndex <span style=color:#f92672>&lt;=</span> highIndex) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 若中间位上的元素是目标元素，则查找成功，循环结束</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (arr<span style=color:#f92672>[</span>midIndex<span style=color:#f92672>]</span> <span style=color:#f92672>==</span> target) {
</span></span><span style=display:flex><span>                result <span style=color:#f92672>=</span> midIndex;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 重新计算最低位，最高位和中间位</span>
</span></span><span style=display:flex><span>            lowIndex <span style=color:#f92672>=</span> arr<span style=color:#f92672>[</span>midIndex<span style=color:#f92672>]</span> <span style=color:#f92672>&lt;</span> target <span style=color:#f92672>?</span> midIndex <span style=color:#f92672>+</span> 1 : lowIndex;
</span></span><span style=display:flex><span>            highIndex <span style=color:#f92672>=</span> arr<span style=color:#f92672>[</span>midIndex<span style=color:#f92672>]</span> <span style=color:#f92672>&gt;</span> target <span style=color:#f92672>?</span> midIndex <span style=color:#f92672>-</span> 1 : highIndex;
</span></span><span style=display:flex><span>            midIndex <span style=color:#f92672>=</span> (lowIndex <span style=color:#f92672>+</span> highIndex) <span style=color:#f92672>/</span> 2;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testBinarySearch</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> arr <span style=color:#f92672>=</span> {1, 3, 5, 7, 9, 11, 13, 15};
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(binarySearch(arr, 13));
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(binarySearch(arr, 27));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=ch02-链表数据结构>CH02. 链表数据结构</h1><blockquote><p>心法: 链表结构</p></blockquote><ul><li>链表是一种由Node节点串联起来的线性结构。</li><li>链表查询效率比数组慢:<ul><li>链表中的每个Node节点的内存地址不规律且不连续，查询时必须从头到尾遍历。</li></ul></li><li>链表操作效率比数组快:<ul><li>操作链表中的Node节点时，只需修改目标节点的前后两个相关的引用值即可。</li></ul></li></ul><h2 id=ep01-单向线性链表>EP01. 单向线性链表</h2><blockquote><p>心法: 单向线性链表</p></blockquote><ul><li>单向线性链表中，每个Node都会额外存储下一个Node的内存地址以串起整个链表结构。</li></ul><table><thead><tr><th>组成部分</th><th>中文</th><th>类型</th><th>存储内容</th></tr></thead><tbody><tr><td><code>data</code></td><td>数据区域</td><td><code>E</code></td><td>存储节点数据，如一个字符串，一个实例等</td></tr><tr><td><code>next</code></td><td>后继指针</td><td><code>Node&lt;E></code></td><td>存储下一个节点的内存地址，尾节点的 <code>next</code> 指向 <code>null</code> 值</td></tr></tbody></table><blockquote><p>武技: 开发单向链表</p></blockquote><ol><li>开发测试链表类 <code>SingleLinkedTest -> SingleLinked</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> link;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@SuppressWarnings</span>(<span style=color:#e6db74>&#34;all&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SingleLinkedTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 单链表 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SingleLinked</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 内部类，用于定义链表内部的Node节点 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>/** 存储节点数据 */</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>private</span> E data;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>/** 后继指针: 存储下一个节点 */</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>private</span> Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> next;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>             * 创建节点时将节点数据注入到data属性中
</span></span></span><span style=display:flex><span><span style=color:#75715e>             *
</span></span></span><span style=display:flex><span><span style=color:#75715e>             * @param data 节点中存储的数据
</span></span></span><span style=display:flex><span><span style=color:#75715e>             */</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>Node</span>(E data) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> data;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>toString</span>() {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// [当前节点数据 -&gt; 下一个节点的数据]</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;[&#34;</span> <span style=color:#f92672>+</span> data <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;-&gt; &#34;</span> <span style=color:#f92672>+</span> (next <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;null&#34;</span> : next.<span style=color:#a6e22e>data</span>) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;]&#34;</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 头节点 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> head;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 创建链表时将头节点数据注入到head属性中
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @param headData 头节点中存储的数据
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>SingleLinked</span>(E headData) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node<span style=color:#f92672>&lt;&gt;</span>(headData);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>toString</span>() {
</span></span><span style=display:flex><span>            StringBuilder result <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> StringBuilder();
</span></span><span style=display:flex><span>            Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> current <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (current <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                result.<span style=color:#a6e22e>append</span>(<span style=color:#e6db74>&#34;[&#34;</span>);
</span></span><span style=display:flex><span>                result.<span style=color:#a6e22e>append</span>(current.<span style=color:#a6e22e>data</span>);
</span></span><span style=display:flex><span>                result.<span style=color:#a6e22e>append</span>(<span style=color:#e6db74>&#34; -&gt; &#34;</span>);
</span></span><span style=display:flex><span>                result.<span style=color:#a6e22e>append</span>(current.<span style=color:#a6e22e>next</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;null&#34;</span> : current.<span style=color:#a6e22e>next</span>.<span style=color:#a6e22e>data</span>);
</span></span><span style=display:flex><span>                result.<span style=color:#a6e22e>append</span>(<span style=color:#e6db74>&#34;] &#34;</span>);
</span></span><span style=display:flex><span>                current <span style=color:#f92672>=</span> current.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> result.<span style=color:#a6e22e>toString</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testBuild</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建单链表并将链表头内容设置为 &#34;2222&#34;</span>
</span></span><span style=display:flex><span>        SingleLinked<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> singleLinked <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SingleLinked<span style=color:#f92672>&lt;&gt;</span>(<span style=color:#e6db74>&#34;2222&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [2222 -&gt; null]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleLinked);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>开发添加链表尾方法 <code>SingleLinked -> addHead()</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> link;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@SuppressWarnings</span>(<span style=color:#e6db74>&#34;all&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SingleLinkedTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 单链表 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SingleLinked</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 添加一个新的链表头
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @param data 链表头节点数据
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @return 当前链表
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> SingleLinked<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>addHead</span>(E data) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 创建一个新节点newNode并注入节点内容</span>
</span></span><span style=display:flex><span>            Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> newNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node<span style=color:#f92672>&lt;&gt;</span>(data);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 让newNode节点的next指向原头节点</span>
</span></span><span style=display:flex><span>            newNode.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// newNode变更为链表头节点</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span> <span style=color:#f92672>=</span> newNode;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 自返回</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 添加新链表头 */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testAddHead</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建单链表并将链表头内容设置为 &#34;2222&#34;</span>
</span></span><span style=display:flex><span>        SingleLinked<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> singleLinked <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SingleLinked<span style=color:#f92672>&lt;&gt;</span>(<span style=color:#e6db74>&#34;2222&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [2222 -&gt; null] </span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;list: &#34;</span> <span style=color:#f92672>+</span> singleLinked);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [1111 -&gt; 2222] [2222 -&gt; null]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;list: &#34;</span> <span style=color:#f92672>+</span> singleLinked.<span style=color:#a6e22e>addHead</span>(<span style=color:#e6db74>&#34;1111&#34;</span>));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [0000 -&gt; 1111] [1111 -&gt; 2222] [2222 -&gt; null]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;list: &#34;</span> <span style=color:#f92672>+</span> singleLinked.<span style=color:#a6e22e>addHead</span>(<span style=color:#e6db74>&#34;0000&#34;</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li>开发添加链表尾方法 <code>SingleLinked -> addTail()</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> link;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@SuppressWarnings</span>(<span style=color:#e6db74>&#34;all&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SingleLinkedTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 单链表 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SingleLinked</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 添加一个新的链表尾
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @param data 节点数据
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @return 当前链表
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> SingleLinked<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>addTail</span>(E data) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 创建一个新节点newNode并注入节点内容</span>
</span></span><span style=display:flex><span>            Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> newNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node<span style=color:#f92672>&lt;&gt;</span>(data);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 从头遍历，找到链表的尾节点tail</span>
</span></span><span style=display:flex><span>            Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> tail <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (tail.<span style=color:#a6e22e>next</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 只要循环不结束，tail就继续指向下一个节点</span>
</span></span><span style=display:flex><span>                tail <span style=color:#f92672>=</span> tail.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 原尾节点的next指向新节点newNode</span>
</span></span><span style=display:flex><span>            tail.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> newNode;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 自返回</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 添加新链表尾 */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testAddTail</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建单链表并将链表头内容设置为 &#34;2222&#34;</span>
</span></span><span style=display:flex><span>        SingleLinked<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> singleLinked <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SingleLinked<span style=color:#f92672>&lt;&gt;</span>(<span style=color:#e6db74>&#34;2222&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [2222 -&gt; null]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleLinked);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [2222 -&gt; 3333] [3333 -&gt; null] </span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleLinked.<span style=color:#a6e22e>addTail</span>(<span style=color:#e6db74>&#34;3333&#34;</span>));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [2222 -&gt; 3333] [3333 -&gt; 4444] [4444 -&gt; null]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleLinked.<span style=color:#a6e22e>addTail</span>(<span style=color:#e6db74>&#34;4444&#34;</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=4><li>开发插入新节点方法 <code>SingleLinked -> add()</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> link;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@SuppressWarnings</span>(<span style=color:#e6db74>&#34;all&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SingleLinkedTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 单链表 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SingleLinked</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 在链表指定位置插入一个节点
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @param data 节点数据
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @param pos  指定位置，从0开始
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @return 当前链表
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> SingleLinked<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>add</span>(E data, <span style=color:#66d9ef>int</span> pos) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 如果pos&lt;=0，视为添加头节点操作，直接调用addHead()</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (pos <span style=color:#f92672>&lt;=</span> 0) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> addHead(data);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 创建一个新节点newNode并注入节点内容</span>
</span></span><span style=display:flex><span>            Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> newNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node<span style=color:#f92672>&lt;&gt;</span>(data);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 存储目标节点，即pos位置上的节点，从head开始</span>
</span></span><span style=display:flex><span>            Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> targetNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 存储目标节点的前一个节点</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 赋值this.head仅为了防止空指针</span>
</span></span><span style=display:flex><span>            Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> prevNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 从头开始遍历，找到pos位置上的节点</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> pos; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 若寻找过程中就已经到了尾节点，视为添加尾节点操作，直接调用addTail()</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (targetNode.<span style=color:#a6e22e>next</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> addTail(data);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 每次都将当前节点先备份到prevNode</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 循环结束时，prevNode存储的就是目标节点的上一个节点</span>
</span></span><span style=display:flex><span>                prevNode <span style=color:#f92672>=</span> targetNode;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 只要循环不结束，targetNode就继续指向下一个节点</span>
</span></span><span style=display:flex><span>                targetNode <span style=color:#f92672>=</span> targetNode.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// prevNode节点的next指向newNode</span>
</span></span><span style=display:flex><span>            prevNode.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> newNode;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// newNode节点的next指向target</span>
</span></span><span style=display:flex><span>            newNode.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> targetNode;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 自返回</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 插入新节点 */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testAdd</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建单链表并将链表头内容设置为 &#34;2222&#34;</span>
</span></span><span style=display:flex><span>        SingleLinked<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> singleLinked <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SingleLinked<span style=color:#f92672>&lt;&gt;</span>(<span style=color:#e6db74>&#34;2222&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [2222 -&gt; null]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleLinked);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [0000 -&gt; 2222] [2222 -&gt; null]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleLinked.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;0000&#34;</span>, 0));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [0000 -&gt; 1111] [1111 -&gt; 2222] [2222 -&gt; null]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleLinked.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;1111&#34;</span>, 1));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [0000 -&gt; 1111] [1111 -&gt; 2222] [2222 -&gt; 3333] [3333 -&gt; null]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleLinked.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;3333&#34;</span>, 3));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=5><li>开发获取节点方法 <code>SingleLinked -> get()</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> link;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@SuppressWarnings</span>(<span style=color:#e6db74>&#34;all&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SingleLinkedTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 单链表 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SingleLinked</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 获取指定节点数据对应的节点
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @param data 节点数据
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @return 节点数据所在的节点，若没找到返回null
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>get</span>(E data) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 从头开始遍历，寻找目标节点</span>
</span></span><span style=display:flex><span>            Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> targetNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (targetNode <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 不断地用指定值比对每个节点的data</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (data.<span style=color:#a6e22e>equals</span>(targetNode.<span style=color:#a6e22e>data</span>)) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 比对成功返回对应节点</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> targetNode;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 只要循环不结束，targetNode就继续指向下一个节点</span>
</span></span><span style=display:flex><span>                targetNode <span style=color:#f92672>=</span> targetNode.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 比对失败返回null</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 获取节点 */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testGet</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建单链表并将链表头内容设置为 &#34;2222&#34;</span>
</span></span><span style=display:flex><span>        SingleLinked<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> singleLinked <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SingleLinked<span style=color:#f92672>&lt;&gt;</span>(<span style=color:#e6db74>&#34;2222&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [2222 -&gt; null]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleLinked);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [2222-&gt; null]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;node: &#34;</span> <span style=color:#f92672>+</span> singleLinked.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;2222&#34;</span>));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// null</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;node: &#34;</span> <span style=color:#f92672>+</span> singleLinked.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;0000&#34;</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=6><li>开发删除节点方法 <code>SingleLinked -> delete()</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> link;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@SuppressWarnings</span>(<span style=color:#e6db74>&#34;all&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SingleLinkedTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 单链表 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SingleLinked</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 删除指定节点数据对应的节点
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @param data 节点数据
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @return 当前链表
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> SingleLinked<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>delete</span>(E data) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 如果删除的是头节点，则直接抛出异常</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (data.<span style=color:#a6e22e>equals</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>.<span style=color:#a6e22e>data</span>)) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(<span style=color:#e6db74>&#34;头节点不允许删除&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 存储目标节点的前一个节点</span>
</span></span><span style=display:flex><span>            Node prevNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 从头开始遍历，寻找目标节点</span>
</span></span><span style=display:flex><span>            Node targetNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (targetNode <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 不断地用指定值比对每个节点的data</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (data.<span style=color:#a6e22e>equals</span>(targetNode.<span style=color:#a6e22e>data</span>)) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 将prevNode节点的next指向targetNode的next</span>
</span></span><span style=display:flex><span>                    prevNode.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> targetNode.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 每次都将当前节点先备份到prevNode</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 循环结束时，prevNode存储的就是目标节点的上一个节点</span>
</span></span><span style=display:flex><span>                prevNode <span style=color:#f92672>=</span> targetNode;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 只要循环不结束，targetNode就继续指向下一个节点</span>
</span></span><span style=display:flex><span>                targetNode <span style=color:#f92672>=</span> targetNode.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 自返回</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 删除节点 */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testDelete</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建单链表并将链表头内容设置为 &#34;2222&#34;</span>
</span></span><span style=display:flex><span>        SingleLinked<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> singleLinked <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SingleLinked<span style=color:#f92672>&lt;&gt;</span>(<span style=color:#e6db74>&#34;2222&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [2222 -&gt; null]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleLinked);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [2222 -&gt; 3333] [3333 -&gt; null]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleLinked.<span style=color:#a6e22e>addTail</span>(<span style=color:#e6db74>&#34;3333&#34;</span>));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [2222 -&gt; null]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleLinked.<span style=color:#a6e22e>delete</span>(<span style=color:#e6db74>&#34;3333&#34;</span>));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// exception</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleLinked.<span style=color:#a6e22e>delete</span>(<span style=color:#e6db74>&#34;2222&#34;</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=ep02-双向线性链表>EP02. 双向线性链表</h2><blockquote><p>心法: 双向线性链表</p></blockquote><ul><li>双向线性链表中，每个Node都会额外存储下一个Node和上一个Node的内存地址以串起整个链表结构。</li></ul><table><thead><tr><th>组成部分</th><th>中文</th><th>类型</th><th>存储内容</th></tr></thead><tbody><tr><td><code>prev</code></td><td>前驱指针</td><td><code>Node&lt;E></code></td><td>存储上一个节点的内存地址</td></tr><tr><td><code>data</code></td><td>数据区域</td><td><code>E</code></td><td>存储节点数据，如一个字符串，一个实例等</td></tr><tr><td><code>next</code></td><td>后继指针</td><td><code>Node&lt;E></code></td><td>存储下一个节点的内存地址，尾节点的 <code>next</code> 指向 <code>null</code> 值</td></tr></tbody></table><blockquote><p>武技: 开发双向链表</p></blockquote><ol><li>开发测试链表类 <code>DoubleLinkedTest -> DoubleLinked</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> link;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@SuppressWarnings</span>(<span style=color:#e6db74>&#34;all&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DoubleLinkedTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 双链表 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DoubleLinked</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 内部类，用于定义链表内部的Node节点 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>/** 存储节点数据 */</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>private</span> E data;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>/** 后继指针: 存储下一个节点 */</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>private</span> Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> next;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>/** 先驱指针: 存储上一个节点 */</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>private</span> Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> prev;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>             * 创建节点时将节点数据注入到data属性中
</span></span></span><span style=display:flex><span><span style=color:#75715e>             *
</span></span></span><span style=display:flex><span><span style=color:#75715e>             * @param data 节点中存储的数据
</span></span></span><span style=display:flex><span><span style=color:#75715e>             */</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>Node</span>(E data) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> data;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>toString</span>() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;[&#34;</span>
</span></span><span style=display:flex><span>                        <span style=color:#f92672>+</span> (prev <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;null&#34;</span> : prev.<span style=color:#a6e22e>data</span>)
</span></span><span style=display:flex><span>                        <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; &lt;- &#34;</span> <span style=color:#f92672>+</span> data <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; -&gt; &#34;</span>
</span></span><span style=display:flex><span>                        <span style=color:#f92672>+</span> (next <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;null&#34;</span> : next.<span style=color:#a6e22e>data</span>)
</span></span><span style=display:flex><span>                        <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;]&#34;</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 头节点 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> head;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 创建链表时将头节点数据注入到head属性中 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>DoubleLinked</span>(E headData) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node<span style=color:#f92672>&lt;&gt;</span>(headData);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>toString</span>() {
</span></span><span style=display:flex><span>            StringBuilder result <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> StringBuilder();
</span></span><span style=display:flex><span>            Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> current <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (current <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                result.<span style=color:#a6e22e>append</span>(<span style=color:#e6db74>&#34;[&#34;</span>);
</span></span><span style=display:flex><span>                result.<span style=color:#a6e22e>append</span>(current.<span style=color:#a6e22e>prev</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;null&#34;</span> : current.<span style=color:#a6e22e>prev</span>.<span style=color:#a6e22e>data</span>);
</span></span><span style=display:flex><span>                result.<span style=color:#a6e22e>append</span>(<span style=color:#e6db74>&#34; &lt;- &#34;</span>);
</span></span><span style=display:flex><span>                result.<span style=color:#a6e22e>append</span>(current.<span style=color:#a6e22e>data</span>);
</span></span><span style=display:flex><span>                result.<span style=color:#a6e22e>append</span>(<span style=color:#e6db74>&#34; -&gt; &#34;</span>);
</span></span><span style=display:flex><span>                result.<span style=color:#a6e22e>append</span>(current.<span style=color:#a6e22e>next</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;null&#34;</span> : current.<span style=color:#a6e22e>next</span>.<span style=color:#a6e22e>data</span>);
</span></span><span style=display:flex><span>                result.<span style=color:#a6e22e>append</span>(<span style=color:#e6db74>&#34;] &#34;</span>);
</span></span><span style=display:flex><span>                current <span style=color:#f92672>=</span> current.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> result.<span style=color:#a6e22e>toString</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testBuild</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建双链表并将链表头内容设置为 &#34;2222&#34;</span>
</span></span><span style=display:flex><span>        DoubleLinked<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> singleLinked <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> DoubleLinked<span style=color:#f92672>&lt;&gt;</span>(<span style=color:#e6db74>&#34;2222&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [null &lt;- 2222 -&gt; null]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleLinked);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>开发添加链表头方法 <code>DoubleLinked -> addHead()</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> link;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@SuppressWarnings</span>(<span style=color:#e6db74>&#34;all&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DoubleLinkedTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 双链表 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DoubleLinked</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 添加一个新的链表头
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @param data 节点内容
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @return 当前链表
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> DoubleLinked<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>addHead</span>(E data) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 创建一个新节点newNode并注入节点内容</span>
</span></span><span style=display:flex><span>            Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> newNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node<span style=color:#f92672>&lt;&gt;</span>(data);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 将原链表头的prev指向新节点</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>.<span style=color:#a6e22e>prev</span> <span style=color:#f92672>=</span> newNode;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 将新节点的next指向原链表头</span>
</span></span><span style=display:flex><span>            newNode.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 重新定义链表头</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span> <span style=color:#f92672>=</span> newNode;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 自返回</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testAddHead</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建双链表并将链表头内容设置为 &#34;2222&#34;</span>
</span></span><span style=display:flex><span>        DoubleLinked<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> singleLinked <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> DoubleLinked<span style=color:#f92672>&lt;&gt;</span>(<span style=color:#e6db74>&#34;2222&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [null &lt;- 2222 -&gt; null]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleLinked);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [null &lt;- 1111 -&gt; 2222] [1111 &lt;- 2222 -&gt; null]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleLinked.<span style=color:#a6e22e>addHead</span>(<span style=color:#e6db74>&#34;1111&#34;</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li>开发添加链表尾方法 <code>DoubleLinked -> addTail()</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> link;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@SuppressWarnings</span>(<span style=color:#e6db74>&#34;all&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DoubleLinkedTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 双链表 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DoubleLinked</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 添加一个新的链表尾
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @param data 节点内容
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @return 当前链表
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> DoubleLinked<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>addTail</span>(E data) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 创建一个新节点newNode并注入节点内容</span>
</span></span><span style=display:flex><span>            Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> newNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node<span style=color:#f92672>&lt;&gt;</span>(data);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 找到链表尾</span>
</span></span><span style=display:flex><span>            Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> tailNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (tailNode.<span style=color:#a6e22e>next</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                tailNode <span style=color:#f92672>=</span> tailNode.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 将原链表尾的next指向新节点</span>
</span></span><span style=display:flex><span>            tailNode.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> newNode;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 将新节点的prev指向原链表尾</span>
</span></span><span style=display:flex><span>            newNode.<span style=color:#a6e22e>prev</span> <span style=color:#f92672>=</span> tailNode;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 自返回</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testAddTail</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建双链表并将链表头内容设置为 &#34;2222&#34;</span>
</span></span><span style=display:flex><span>        DoubleLinked<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> singleLinked <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> DoubleLinked<span style=color:#f92672>&lt;&gt;</span>(<span style=color:#e6db74>&#34;2222&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [null &lt;- 2222 -&gt; null]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleLinked);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [null &lt;- 2222 -&gt; 3333] [2222 &lt;- 3333 -&gt; null]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleLinked.<span style=color:#a6e22e>addTail</span>(<span style=color:#e6db74>&#34;3333&#34;</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=4><li>开发添加新节点方法 <code>DoubleLinked -> add()</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> link;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@SuppressWarnings</span>(<span style=color:#e6db74>&#34;all&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DoubleLinkedTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 双链表 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DoubleLinked</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 在链表指定位置插入一个节点
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @param data 节点数据
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @param pos  指定位置，从0开始
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @return 当前链表
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> DoubleLinked<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>add</span>(E data, <span style=color:#66d9ef>int</span> pos) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 如果pos&lt;=0，视为添加头节点操作，直接调用addHead()</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (pos <span style=color:#f92672>&lt;=</span> 0) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> addHead(data);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 创建一个新节点newNode并注入节点内容</span>
</span></span><span style=display:flex><span>            Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> newNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node<span style=color:#f92672>&lt;&gt;</span>(data);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 从head开始，寻找目标节点</span>
</span></span><span style=display:flex><span>            Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> targetNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> pos; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 若寻找过程中就已经到了尾节点，视为添加尾节点操作，直接调用addTail()</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (targetNode.<span style=color:#a6e22e>next</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> addTail(data);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 只要循环不结束，targetNode就继续指向下一个节点</span>
</span></span><span style=display:flex><span>                targetNode <span style=color:#f92672>=</span> targetNode.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 将新节点的prev指向目标节点的上一个节点</span>
</span></span><span style=display:flex><span>            newNode.<span style=color:#a6e22e>prev</span> <span style=color:#f92672>=</span> targetNode.<span style=color:#a6e22e>prev</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 将目标节点的上一个节点的next指向新节点</span>
</span></span><span style=display:flex><span>            targetNode.<span style=color:#a6e22e>prev</span>.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> newNode;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 将新节点的next指向目标节点</span>
</span></span><span style=display:flex><span>            newNode.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> targetNode;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 将目标节点的prev指向新节点</span>
</span></span><span style=display:flex><span>            targetNode.<span style=color:#a6e22e>prev</span> <span style=color:#f92672>=</span> newNode;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 自返回</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testAdd</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建双链表并将链表头内容设置为 &#34;2222&#34;</span>
</span></span><span style=display:flex><span>        DoubleLinked<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> singleLinked <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> DoubleLinked<span style=color:#f92672>&lt;&gt;</span>(<span style=color:#e6db74>&#34;2222&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [null &lt;- 2222 -&gt; null]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleLinked);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [null &lt;- 1111 -&gt; 2222] [1111 &lt;- 2222 -&gt; null]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleLinked.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;1111&#34;</span>, 0));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [null &lt;- 1111 -&gt; 2222] [1111 &lt;- 2222 -&gt; 3333] [2222 &lt;- 3333 -&gt; null]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleLinked.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;3333&#34;</span>, 2));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=5><li>开发获取某节点方法 <code>DoubleLinked -> get()</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> link;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@SuppressWarnings</span>(<span style=color:#e6db74>&#34;all&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DoubleLinkedTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 双链表 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DoubleLinked</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 获取指定节点数据对应的节点
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @param data 节点内容
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @return 节点数据所在的节点，若没找到返回null
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Node <span style=color:#a6e22e>get</span>(E data) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 从头开始遍历，寻找目标节点</span>
</span></span><span style=display:flex><span>            Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> targetNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (targetNode <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 不断地用指定值比对每个节点的data</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (data.<span style=color:#a6e22e>equals</span>(targetNode.<span style=color:#a6e22e>data</span>)) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 对比成功，返回该节点</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> targetNode;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 只要循环不结束，就让targetNode继续指向它的下一个节点</span>
</span></span><span style=display:flex><span>                targetNode <span style=color:#f92672>=</span> targetNode.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 若寻找失败，直接返回null</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testGet</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建双链表并将链表头内容设置为 &#34;2222&#34;</span>
</span></span><span style=display:flex><span>        DoubleLinked<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> singleLinked <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> DoubleLinked<span style=color:#f92672>&lt;&gt;</span>(<span style=color:#e6db74>&#34;2222&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [null &lt;- 2222 -&gt; null]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleLinked);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [null &lt;- 2222 -&gt; null]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;node: &#34;</span> <span style=color:#f92672>+</span> singleLinked.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;2222&#34;</span>));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// null</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;node: &#34;</span> <span style=color:#f92672>+</span> singleLinked.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;1111&#34;</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=6><li>开发删除某节点方法 <code>DoubleLinked -> delete()</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> link;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@SuppressWarnings</span>(<span style=color:#e6db74>&#34;all&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DoubleLinkedTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 双链表 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DoubleLinked</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 删除指定节点数据对应的节点
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @param data 节点内容
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @return 当前链表，若寻找失败，直接返回null
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> DoubleLinked<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>delete</span>(E data) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (data.<span style=color:#a6e22e>equals</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>.<span style=color:#a6e22e>data</span>)) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(<span style=color:#e6db74>&#34;不能删除头节点&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 从头开始遍历寻找目标节点</span>
</span></span><span style=display:flex><span>            Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> targetNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (targetNode <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 不断地用指定值比对每个节点的data</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (data.<span style=color:#a6e22e>equals</span>(targetNode.<span style=color:#a6e22e>data</span>)) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 将目标节点的上一个节点的next指向目标节点的下一个节点</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>null</span> <span style=color:#f92672>!=</span> targetNode.<span style=color:#a6e22e>prev</span>) {
</span></span><span style=display:flex><span>                        targetNode.<span style=color:#a6e22e>prev</span>.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> targetNode.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 将目标节点的下一个节点的prev指向目标节点的上一个节点</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>null</span> <span style=color:#f92672>!=</span> targetNode.<span style=color:#a6e22e>next</span>) {
</span></span><span style=display:flex><span>                        targetNode.<span style=color:#a6e22e>next</span>.<span style=color:#a6e22e>prev</span> <span style=color:#f92672>=</span> targetNode.<span style=color:#a6e22e>prev</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 只要循环不结束，就让targetNode继续指向它的下一个节点</span>
</span></span><span style=display:flex><span>                targetNode <span style=color:#f92672>=</span> targetNode.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 自返回</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testDelete</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建双链表并将链表头内容设置为 &#34;2222&#34;</span>
</span></span><span style=display:flex><span>        DoubleLinked<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> singleLinked <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> DoubleLinked<span style=color:#f92672>&lt;&gt;</span>(<span style=color:#e6db74>&#34;2222&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [null &lt;- 2222 -&gt; null]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleLinked);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [null &lt;- 2222 -&gt; 3333] [2222 &lt;- 3333 -&gt; null]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleLinked.<span style=color:#a6e22e>addTail</span>(<span style=color:#e6db74>&#34;3333&#34;</span>));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [null &lt;- 2222 -&gt; null]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;node: &#34;</span> <span style=color:#f92672>+</span> singleLinked.<span style=color:#a6e22e>delete</span>(<span style=color:#e6db74>&#34;3333&#34;</span>));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// exception</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;node: &#34;</span> <span style=color:#f92672>+</span> singleLinked.<span style=color:#a6e22e>delete</span>(<span style=color:#e6db74>&#34;2222&#34;</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=ep03-单向环形链表>EP03. 单向环形链表</h2><blockquote><p>心法: 单向环形链表</p></blockquote><ul><li>单向环形链表就是首尾相连的单链表，即尾节点的next指向头节点，从而形成一个环。</li></ul><table><thead><tr><th>组成部分</th><th>中文</th><th>类型</th><th>存储内容</th></tr></thead><tbody><tr><td><code>data</code></td><td>数据区域</td><td><code>E</code></td><td>存储节点数据，如一个字符串，一个实例等</td></tr><tr><td><code>next</code></td><td>后继指针</td><td><code>Node&lt;E></code></td><td>存储下一个节点的内存地址，尾节点的 <code>next</code> 指向 <code>null</code> 值</td></tr></tbody></table><blockquote><p>武技: 开发单向环链表</p></blockquote><ol><li>开发测试链表类 <code>SingleCircleLinkedTest -> SingleCycleLinked</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> link;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@SuppressWarnings</span>(<span style=color:#e6db74>&#34;all&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SingleCircleLinkedTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 单向环链表 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SingleCycleLinked</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 内部类，用于定义链表内部的Node节点 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>/** 存储节点数据 */</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>private</span> E data;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>/** 后继指针: 存储下一个节点 */</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>private</span> Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> next;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>             * 创建节点时将节点数据注入到data属性中
</span></span></span><span style=display:flex><span><span style=color:#75715e>             *
</span></span></span><span style=display:flex><span><span style=color:#75715e>             * @param data 节点中存储的数据
</span></span></span><span style=display:flex><span><span style=color:#75715e>             */</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>Node</span>(E data) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> data;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>toString</span>() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;[&#34;</span> <span style=color:#f92672>+</span> data <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; -&gt; &#34;</span> <span style=color:#f92672>+</span> (next <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;null&#34;</span> : next.<span style=color:#a6e22e>data</span>) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;]&#34;</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 头节点 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> head;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 创建链表时将头节点数据注入到head属性中
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @param headData 头节点中存储的数据
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>SingleCycleLinked</span>(E headData) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node<span style=color:#f92672>&lt;&gt;</span>(headData);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 将当前链表头的next指向自己</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>toString</span>() {
</span></span><span style=display:flex><span>            StringBuilder result <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> StringBuilder();
</span></span><span style=display:flex><span>            Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> current <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>                result.<span style=color:#a6e22e>append</span>(<span style=color:#e6db74>&#34;[&#34;</span>);
</span></span><span style=display:flex><span>                result.<span style=color:#a6e22e>append</span>(current.<span style=color:#a6e22e>data</span>);
</span></span><span style=display:flex><span>                result.<span style=color:#a6e22e>append</span>(<span style=color:#e6db74>&#34; -&gt; &#34;</span>);
</span></span><span style=display:flex><span>                result.<span style=color:#a6e22e>append</span>(current.<span style=color:#a6e22e>next</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;null&#34;</span> : current.<span style=color:#a6e22e>next</span>.<span style=color:#a6e22e>data</span>);
</span></span><span style=display:flex><span>                result.<span style=color:#a6e22e>append</span>(<span style=color:#e6db74>&#34;] &#34;</span>);
</span></span><span style=display:flex><span>                current <span style=color:#f92672>=</span> current.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>while</span> (current <span style=color:#f92672>!=</span> head);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> result.<span style=color:#a6e22e>toString</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testBuild</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建单向环链表并将链表头内容设置为 &#34;1111&#34;</span>
</span></span><span style=display:flex><span>        SingleCycleLinked<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> singleCycleLinked <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SingleCycleLinked<span style=color:#f92672>&lt;&gt;</span>(<span style=color:#e6db74>&#34;1111&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [1111 -&gt; 1111] </span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleCycleLinked);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>开发添加新节点方法 <code>SingleCycleLinked -> add()</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> link;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@SuppressWarnings</span>(<span style=color:#e6db74>&#34;all&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SingleCircleLinkedTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 单向环链表 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SingleCycleLinked</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 在链表头之后插入一个新节点
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @param data 节点内容
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @return 当前链表
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> SingleCycleLinked<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>add</span>(E data) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 创建一个新节点newNode并注入节点内容</span>
</span></span><span style=display:flex><span>            Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> newNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node<span style=color:#f92672>&lt;&gt;</span>(data);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 头节点</span>
</span></span><span style=display:flex><span>            Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> headNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 将新节点的next指向头节点的下一个节点</span>
</span></span><span style=display:flex><span>            newNode.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> headNode.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 将头节点的next指向新节点</span>
</span></span><span style=display:flex><span>            headNode.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> newNode;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 自返回</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testAdd</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建单向环链表并将链表头内容设置为 &#34;1111&#34;</span>
</span></span><span style=display:flex><span>        SingleCycleLinked<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> singleCycleLinked <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SingleCycleLinked<span style=color:#f92672>&lt;&gt;</span>(<span style=color:#e6db74>&#34;1111&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [1111 -&gt; 1111]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleCycleLinked);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [1111 -&gt; 2222] [2222 -&gt; 1111]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleCycleLinked.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;2222&#34;</span>));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [1111 -&gt; 3333] [3333 -&gt; 2222] [2222 -&gt; 1111]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleCycleLinked.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;3333&#34;</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li>开发获取某节点方法 <code>SingleCycleLinked -> get()</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> link;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@SuppressWarnings</span>(<span style=color:#e6db74>&#34;all&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SingleCircleLinkedTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 单向环链表 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SingleCycleLinked</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 获取指定节点数据对应的节点
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @param data 节点内容
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @return 节点数据所在的节点
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>get</span>(E data) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 从头开始遍历，寻找目标节点</span>
</span></span><span style=display:flex><span>            Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> targetNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 不断地用指定值比对每个节点的data</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (data.<span style=color:#a6e22e>equals</span>(targetNode.<span style=color:#a6e22e>data</span>)) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 比对成功返回对应节点</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> targetNode;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 只要循环不结束，targetNode就继续指向下一个节点</span>
</span></span><span style=display:flex><span>                targetNode <span style=color:#f92672>=</span> targetNode.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>while</span> (targetNode <span style=color:#f92672>!=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 比对失败返回null</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testGet</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建单向环链表并将链表头内容设置为 &#34;1111&#34;</span>
</span></span><span style=display:flex><span>        SingleCycleLinked<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> singleCycleLinked <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SingleCycleLinked<span style=color:#f92672>&lt;&gt;</span>(<span style=color:#e6db74>&#34;1111&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [1111 -&gt; 1111]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleCycleLinked);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [1111 -&gt; 1111]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleCycleLinked.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;1111&#34;</span>));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// null</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleCycleLinked.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;2222&#34;</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=4><li>开发删除某节点方法 <code>SingleCycleLinked -> delete()</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> link;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@SuppressWarnings</span>(<span style=color:#e6db74>&#34;all&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SingleCircleLinkedTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 单向环链表 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SingleCycleLinked</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 删除指定节点数据对应的节点
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @param data 节点内容
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @return 当前链表
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> SingleCycleLinked<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>delete</span>(E data) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (data.<span style=color:#a6e22e>equals</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>.<span style=color:#a6e22e>data</span>)) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(<span style=color:#e6db74>&#34;头节点不允许删除&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 存储目标节点的前一个节点</span>
</span></span><span style=display:flex><span>            Node prevNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 从头开始遍历，寻找目标节点</span>
</span></span><span style=display:flex><span>            Node targetNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 不断地用指定值比对每个节点的data</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (data.<span style=color:#a6e22e>equals</span>(targetNode.<span style=color:#a6e22e>data</span>)) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 将prevNode节点的next指向targetNode的next</span>
</span></span><span style=display:flex><span>                    prevNode.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> targetNode.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 每次都将当前节点先备份到prevNode</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 循环结束时，prevNode存储的就是目标节点的上一个节点</span>
</span></span><span style=display:flex><span>                prevNode <span style=color:#f92672>=</span> targetNode;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 只要循环不结束，targetNode就继续指向下一个节点</span>
</span></span><span style=display:flex><span>                targetNode <span style=color:#f92672>=</span> targetNode.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>while</span> (targetNode <span style=color:#f92672>!=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 自返回</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testDelete</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建单向环链表并将链表头内容设置为 &#34;1111&#34;</span>
</span></span><span style=display:flex><span>        SingleCycleLinked<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> singleCycleLinked <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SingleCycleLinked<span style=color:#f92672>&lt;&gt;</span>(<span style=color:#e6db74>&#34;1111&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [1111 -&gt; 1111]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleCycleLinked);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [1111 -&gt; 2222] [2222 -&gt; 1111]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleCycleLinked.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;2222&#34;</span>));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [1111 -&gt; 1111]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleCycleLinked.<span style=color:#a6e22e>delete</span>(<span style=color:#e6db74>&#34;2222&#34;</span>));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// exception</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> singleCycleLinked.<span style=color:#a6e22e>delete</span>(<span style=color:#e6db74>&#34;1111&#34;</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=ep04-双向环形链表>EP04. 双向环形链表</h2><blockquote><p>心法: 双向环形链表</p></blockquote><ul><li>双向环形链表就是首尾相连的双链表，即尾节点的next指向头节点，从而形成一个环。</li></ul><table><thead><tr><th>组成部分</th><th>中文</th><th>类型</th><th>存储内容</th></tr></thead><tbody><tr><td><code>prev</code></td><td>前驱指针</td><td><code>Node&lt;E></code></td><td>存储上一个节点的内存地址</td></tr><tr><td><code>data</code></td><td>数据区域</td><td><code>E</code></td><td>存储节点数据，如一个字符串，一个实例等</td></tr><tr><td><code>next</code></td><td>后继指针</td><td><code>Node&lt;E></code></td><td>存储下一个节点的内存地址，尾节点的 <code>next</code> 指向 <code>null</code> 值</td></tr></tbody></table><blockquote><p>武技: 开发双向环链表</p></blockquote><ol><li>开发测试链表类 <code>DoubleCircleLinkedTest -> DoubleCycleLinked</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> link;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@SuppressWarnings</span>(<span style=color:#e6db74>&#34;all&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DoubleCircleLinkedTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 双向环链表 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DoubleCycleLinked</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 内部类，用于定义链表内部的Node节点 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>/** 存储节点数据 */</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>private</span> E data;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>/** 后继指针: 存储下一个节点 */</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>private</span> Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> next;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>/** 前驱指针: 存储上一个节点 */</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>private</span> Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> prev;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>/** 创建节点时将节点数据注入到data属性中 */</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>Node</span>(E data) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> data;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>toString</span>() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;[&#34;</span>
</span></span><span style=display:flex><span>                        <span style=color:#f92672>+</span> (prev <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;null&#34;</span> : prev.<span style=color:#a6e22e>data</span>)
</span></span><span style=display:flex><span>                        <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; &lt;- &#34;</span> <span style=color:#f92672>+</span> data <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; -&gt; &#34;</span>
</span></span><span style=display:flex><span>                        <span style=color:#f92672>+</span> (next <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;null&#34;</span> : next.<span style=color:#a6e22e>data</span>)
</span></span><span style=display:flex><span>                        <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;]&#34;</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 头节点 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> head;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 创建链表时将头节点数据注入到head属性中
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @param headData 头节点中存储的数据
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>DoubleCycleLinked</span>(E headData) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node<span style=color:#f92672>&lt;&gt;</span>(headData);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 将当前链表头的prev和next均指向自己</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>.<span style=color:#a6e22e>prev</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>toString</span>() {
</span></span><span style=display:flex><span>            StringBuilder result <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> StringBuilder();
</span></span><span style=display:flex><span>            Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> current <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>                result.<span style=color:#a6e22e>append</span>(<span style=color:#e6db74>&#34;[&#34;</span>);
</span></span><span style=display:flex><span>                result.<span style=color:#a6e22e>append</span>(current.<span style=color:#a6e22e>prev</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;null&#34;</span> : current.<span style=color:#a6e22e>prev</span>.<span style=color:#a6e22e>data</span>);
</span></span><span style=display:flex><span>                result.<span style=color:#a6e22e>append</span>(<span style=color:#e6db74>&#34; &lt;- &#34;</span>);
</span></span><span style=display:flex><span>                result.<span style=color:#a6e22e>append</span>(current.<span style=color:#a6e22e>data</span>);
</span></span><span style=display:flex><span>                result.<span style=color:#a6e22e>append</span>(<span style=color:#e6db74>&#34; -&gt; &#34;</span>);
</span></span><span style=display:flex><span>                result.<span style=color:#a6e22e>append</span>(current.<span style=color:#a6e22e>next</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;null&#34;</span> : current.<span style=color:#a6e22e>next</span>.<span style=color:#a6e22e>data</span>);
</span></span><span style=display:flex><span>                result.<span style=color:#a6e22e>append</span>(<span style=color:#e6db74>&#34;] &#34;</span>);
</span></span><span style=display:flex><span>                current <span style=color:#f92672>=</span> current.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>while</span> (current <span style=color:#f92672>!=</span> head);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> result.<span style=color:#a6e22e>toString</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testBuild</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建双向环链表并将链表头内容设置为 &#34;1111&#34;</span>
</span></span><span style=display:flex><span>        DoubleCycleLinked<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> doubleCycleLinked <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> DoubleCycleLinked<span style=color:#f92672>&lt;&gt;</span>(<span style=color:#e6db74>&#34;1111&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [1111 &lt;- 1111 -&gt; 1111]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> doubleCycleLinked);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>开发添加新节点方法 <code>DoubleCycleLinked -> add()</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> link;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@SuppressWarnings</span>(<span style=color:#e6db74>&#34;all&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DoubleCircleLinkedTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 双向环链表 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DoubleCycleLinked</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 在链表头之后插入一个新节点
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @param data 节点内容
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @return 当前链表
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> DoubleCycleLinked<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>add</span>(E data) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 创建一个新节点newNode并注入节点内容</span>
</span></span><span style=display:flex><span>            Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> newNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node<span style=color:#f92672>&lt;&gt;</span>(data);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 将新节点的next指向脖子节点</span>
</span></span><span style=display:flex><span>            newNode.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 将脖子节点的prev指向新节点</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>.<span style=color:#a6e22e>next</span>.<span style=color:#a6e22e>prev</span> <span style=color:#f92672>=</span> newNode;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 将新节点的prev指向头节点</span>
</span></span><span style=display:flex><span>            newNode.<span style=color:#a6e22e>prev</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 将头节点的next指向新节点</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> newNode;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 自返回</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testAdd</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建双向环链表并将链表头内容设置为 &#34;1111&#34;</span>
</span></span><span style=display:flex><span>        DoubleCycleLinked<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> doubleCycleLinked <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> DoubleCycleLinked<span style=color:#f92672>&lt;&gt;</span>(<span style=color:#e6db74>&#34;1111&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [1111 &lt;- 1111 -&gt; 1111]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> doubleCycleLinked);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [2222 &lt;- 1111 -&gt; 2222] [1111 &lt;- 2222 -&gt; 1111]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> doubleCycleLinked.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;2222&#34;</span>));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [2222 &lt;- 1111 -&gt; 3333] [1111 &lt;- 3333 -&gt; 2222] [3333 &lt;- 2222 -&gt; 1111]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> doubleCycleLinked.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;3333&#34;</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li>开发获取某节点方法 <code>DoubleCycleLinked -> get()</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> link;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@SuppressWarnings</span>(<span style=color:#e6db74>&#34;all&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DoubleCircleLinkedTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 双向环链表 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DoubleCycleLinked</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 获取指定节点数据对应的节点
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @param data 节点内容
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @return 节点数据所在的节点
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>get</span>(E data) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 从头开始遍历，寻找目标节点</span>
</span></span><span style=display:flex><span>            Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> targetNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 不断地用指定值比对每个节点的data</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (data.<span style=color:#a6e22e>equals</span>(targetNode.<span style=color:#a6e22e>data</span>)) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 比对成功返回对应节点</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> targetNode;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 只要循环不结束，targetNode就继续指向下一个节点</span>
</span></span><span style=display:flex><span>                targetNode <span style=color:#f92672>=</span> targetNode.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>while</span> (targetNode <span style=color:#f92672>!=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 比对失败返回null</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testGet</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建双向环链表并将链表头内容设置为 &#34;1111&#34;</span>
</span></span><span style=display:flex><span>        DoubleCycleLinked<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> doubleCycleLinked <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> DoubleCycleLinked<span style=color:#f92672>&lt;&gt;</span>(<span style=color:#e6db74>&#34;1111&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [1111 &lt;- 1111 -&gt; 1111]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> doubleCycleLinked);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [1111 &lt;- 1111 -&gt; 1111]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;node: &#34;</span> <span style=color:#f92672>+</span> doubleCycleLinked.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;1111&#34;</span>));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// null</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;node: &#34;</span> <span style=color:#f92672>+</span> doubleCycleLinked.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;2222&#34;</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=4><li>开发删除某节点方法 <code>DoubleCycleLinked -> delete()</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> link;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@SuppressWarnings</span>(<span style=color:#e6db74>&#34;all&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DoubleCircleLinkedTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 双向环链表 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DoubleCycleLinked</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 删除指定节点数据对应的节点
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @param data 节点内容
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @return 当前链表
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> DoubleCycleLinked<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>delete</span>(E data) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (data.<span style=color:#a6e22e>equals</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>.<span style=color:#a6e22e>data</span>)) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(<span style=color:#e6db74>&#34;头节点不允许删除&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 从头开始遍历，寻找目标节点</span>
</span></span><span style=display:flex><span>            Node targetNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 不断地用指定值比对每个节点的data</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (data.<span style=color:#a6e22e>equals</span>(targetNode.<span style=color:#a6e22e>data</span>)) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 将目标节点的上一个节点的next指向targetNode的next</span>
</span></span><span style=display:flex><span>                    targetNode.<span style=color:#a6e22e>prev</span>.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> targetNode.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 将目标节点下一个节点的next指向目标节点的上一个节点</span>
</span></span><span style=display:flex><span>                    targetNode.<span style=color:#a6e22e>next</span>.<span style=color:#a6e22e>prev</span> <span style=color:#f92672>=</span> targetNode.<span style=color:#a6e22e>prev</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 只要循环不结束，targetNode就继续指向下一个节点</span>
</span></span><span style=display:flex><span>                targetNode <span style=color:#f92672>=</span> targetNode.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>while</span> (targetNode <span style=color:#f92672>!=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>head</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 自返回</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testDelete</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建双向环链表并将链表头内容设置为 &#34;1111&#34;</span>
</span></span><span style=display:flex><span>        DoubleCycleLinked<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> doubleCycleLinked <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> DoubleCycleLinked<span style=color:#f92672>&lt;&gt;</span>(<span style=color:#e6db74>&#34;1111&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [1111 &lt;- 1111 -&gt; 1111]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> doubleCycleLinked);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [2222 &lt;- 1111 -&gt; 2222] [1111 &lt;- 2222 -&gt; 1111]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> doubleCycleLinked.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;2222&#34;</span>));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [1111 &lt;- 1111 -&gt; 1111]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> doubleCycleLinked.<span style=color:#a6e22e>delete</span>(<span style=color:#e6db74>&#34;2222&#34;</span>));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// exception</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;link: &#34;</span> <span style=color:#f92672>+</span> doubleCycleLinked.<span style=color:#a6e22e>delete</span>(<span style=color:#e6db74>&#34;1111&#34;</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=ch03-哈希数据结构>CH03. 哈希数据结构</h1><blockquote><p>心法: 哈希算法 <code>Hash Algorithm</code></p></blockquote><ul><li><code>Hash Algorithm</code>:<ul><li>Hash被称为散列或哈希，是一种算法，MD5，SHA等都属于Hash算法的实现。</li></ul></li><li><code>Hash Table</code>:<ul><li>哈希表也叫散列表，是一种以数组为基础的数据结构，以键值对映射的方式存取值。</li></ul></li></ul><h2 id=ep01-哈希代码函数>EP01. 哈希代码函数</h2><blockquote><p>心法: 哈希码函数 <code>hashCode()</code></p></blockquote><ul><li>哈希码函数来自于Object类，即任何实例都可以调用该方法以获取其Hash码:<ul><li><code>public native int hashCode()</code>: 返回指定实例的Hash码，即对象的唯一标识。</li></ul></li></ul><blockquote><p>心法: 哈希码生成策略</p></blockquote><ul><li>哈希码有6种生成策略，可以在JVM运行参数中使用 <code>-XX:hashCode</code> 来设置:</li></ul><table><thead><tr><th>JVM运行参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-XX:hashCode=0</code></td><td>返回一个随机的Hash值，该生成策略在高并发的时候会出现自旋等待</td></tr><tr><td><code>-XX:hashCode=1</code></td><td>使用某种算法对实例的内存地址进行计算后返回</td></tr><tr><td><code>-XX:hashCode=2</code></td><td>固定返回1，该策略一般用于测试</td></tr><tr><td><code>-XX:hashCode=3</code></td><td>对一个公共变量进行自增后返回，全部实例的哈希码都使用相同的自增变量</td></tr><tr><td><code>-XX:hashCode=4</code></td><td>直接返回实例的内存地址</td></tr><tr><td><code>-XX:hashCode=其他值</code></td><td>利用xor-shift算法产生伪随机数，默认值5</td></tr></tbody></table><blockquote><p>武技: 测试哈希码生成策略</p></blockquote><ol><li>开发测试方法 <code>HashCodeTest -> testHashCodeGeneratePolicy()</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> hash;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HashCodeTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** HashCode生成策略: -XX:hashCode==2 */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testHashCodeGeneratePolicy</span>() {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#66d9ef>new</span> Object().<span style=color:#a6e22e>hashCode</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=ep02-哈希函数重写>EP02. 哈希函数重写</h2><blockquote><p>心法: 判断两个实例是否相等的流程</p></blockquote><ul><li>调用两个实例的 <code>hashCode()</code> 获取各自的Hash值:<ol><li>若Hash值不等，则直接返回 <code>false</code>，以此提升比较过程的效率。</li><li>若hash值相等，则返回两个实例的 <code>equals()</code> 比较结果。</li></ol></li><li>所以任何情况下，重写 <code>equals()</code> 时必须同时重写 <code>hashCode()</code> 以保证Hash值相等这一前提条件。</li></ul><blockquote><p>武技: 利用HashMap测试重写 <code>equals()</code> 时未重写 <code>hashCode()</code> 出现的BUG</p></blockquote><ol><li>开发实体类 <code>HashCodeTest -> User</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> hash;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HashCodeTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Data</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@AllArgsConstructor</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>User</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Integer id;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>重写方法 <code>User -> equals()</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HashCodeTest</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Data</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>User</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>equals</span>(Object obj) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 若参与比较的obj参数就是this自己，则直接返回true</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span> <span style=color:#f92672>==</span> obj) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 若参与比较的obj参数不属于User类型，则直接返回false</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(obj <span style=color:#66d9ef>instanceof</span> User)) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 若参与比较的obj参数属于User类型，则强转为User类型</span>
</span></span><span style=display:flex><span>            User user <span style=color:#f92672>=</span> (User) obj;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 使用 `Objects.equals()` 工具分别比较两个实例的id和name值</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 全相等则返回true，否则返回false</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Objects.<span style=color:#a6e22e>equals</span>(id, user.<span style=color:#a6e22e>id</span>) <span style=color:#f92672>&amp;&amp;</span> Objects.<span style=color:#a6e22e>equals</span>(name, user.<span style=color:#a6e22e>name</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li>开发测试方法 <code>HashCodeTest -> testEquals()</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HashCodeTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 测试重写的equals()方法 */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testEquals</span>() {
</span></span><span style=display:flex><span>        User jack01 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> User(1, <span style=color:#e6db74>&#34;杰克&#34;</span>);
</span></span><span style=display:flex><span>        User jack02 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> User(1, <span style=color:#e6db74>&#34;杰克&#34;</span>);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(jack01.<span style=color:#a6e22e>equals</span>(jack02));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=4><li>开发测试方法 <code>HashCodeTest -> testHashCode()</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HashCodeTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 测试HashMap的取值原理 */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testHashCode</span>() {
</span></span><span style=display:flex><span>        User jack01 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> User(1, <span style=color:#e6db74>&#34;杰克&#34;</span>);
</span></span><span style=display:flex><span>        User jack02 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> User(1, <span style=color:#e6db74>&#34;杰克&#34;</span>);
</span></span><span style=display:flex><span>        HashMap<span style=color:#f92672>&lt;</span>User, Integer<span style=color:#f92672>&gt;</span> hashMap <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        hashMap.<span style=color:#a6e22e>put</span>(jack01, 100);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// HashMap中的get()方法底层是根据key的hash值来获取对应value的</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 若User类没重写hashCode()方法，则HashMap认为jack02和jack01不是同个key值，返回null</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 若User类重写了hashCode()方法，则hashMap认为jack02和jack01是同个key值，返回100</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(hashMap.<span style=color:#a6e22e>get</span>(jack02));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=5><li>重写方法 <code>User -> hashCode()</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HashCodeTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Data</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@AllArgsConstructor</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>User</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>hashCode</span>() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 使用 `Objects.hash()` 工具对id和name的值计算hash总和并返回</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Objects.<span style=color:#a6e22e>hash</span>(id, name);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=6><li>重新运行测试方法 <code>HashCodeTest -> testHashCode()</code>，测试HashMap的取值原理。</li></ol><h2 id=ep03-哈希数据结构>EP03. 哈希数据结构</h2><blockquote><p>心法: 哈希数据结构</p></blockquote><ul><li>哈希结构的核心就是 <code>Node数组</code> 和 <code>哈希函数</code>:<ul><li>Node节点中存储一个字符串类型的键，一个Object类型的值和一个Node类型的后继指针。</li><li>哈希函数是决定Hash效率的最重要函数。</li></ul></li><li>无论使用哈希结构进行存值还是取值，都需要先使用哈希函数对元素的 <code>键</code> 进行计算定位:<ul><li>计算的结果就是该元素在Node数组中的位置。</li><li>在最优情况下，仅需一次便可找到目标元素。</li></ul></li></ul><table><thead><tr><th>Node组成部分</th><th>中文</th><th>类型</th><th>存储内容</th></tr></thead><tbody><tr><td><code>key</code></td><td>键</td><td><code>String</code></td><td>存储数据的键，固定为字符串结构</td></tr><tr><td><code>value</code></td><td>值</td><td><code>E</code></td><td>存储数据的值</td></tr><tr><td><code>next</code></td><td>后继指针</td><td><code>Node&lt;E></code></td><td>存储下一个节点的内存地址，尾节点的 <code>next</code> 指向 <code>null</code> 值</td></tr></tbody></table><blockquote><p>心法: 使用扰动函数优化哈希函数</p></blockquote><ol><li><code>int h = obj.hashCode()</code>: 调用Object的哈希函数计算对象的初始哈希码:<ol><li>int型Hash值为32位，约有40亿种可能，直接在内存中创建40亿长度的数组是不明智的。</li><li>所以不推荐直接使用这个Hash值，需要二次处理。</li></ol></li><li><code>h = h ^ (h >>> 16)</code>: 扰动函数：对32位的Hash值的操作：<ol><li>将Hash值右移动16位：<ol><li>原Hash的高16位被移动到低16位。</li><li>原Hash的低16位被移出。</li><li>原Hash的高16位全部补充0。</li></ol></li><li>将右移动结果和原Hash值进行异或混合：<ol><li>原Hash的高16位信息和低16位信息在结果的低16位进行混合，提升Hash值低16位的随机性以减少Hash冲突。</li><li>结果的高16位信息可忽略。</li></ol></li></ol></li><li><code>h = h & (数组长度 - 1)</code>: 使用位运算取余，以决定最终存放的位置：<ol><li>位运算取余效率比 (hash % length) 高，但前提是bitmap的长度会被尽量保证为2的N次方。</li><li>从二进制的角度来看，对一个数右移N位就相当于对这个数除以2的N次方：<ol><li>右移N位后，剩余的二进制数字所表示的就是商，被移出的N个数字就是余数。</li><li>所以想要通过位运算获取一个数对2的N次方取余的结果，直接提取该数的后N位数即可。</li></ol></li><li>一个2的N次方值减去1后，位图末尾就会变为N个1：<ol><li>如2的2次方 - 1 = 03(0000 0011)：末尾2个1。</li><li>如2的3次方 - 1 = 07(0000 0111)：末尾3个1。</li><li>如2的4次方 - 1 = 15(0000 1111)：末尾4个1。</li></ol></li><li>任何数和此时的 <code>&</code> 操作会提取Hash值中后N位：<ol><li>如Hash值为21(0001 0101)，数组长度为16，减1后为15(0000 1111)。</li><li>那么 (0001 0101) & (0000 1111) = (0000 0101)，相当于提取了21的后4位。</li><li>而这后4位，就是 21%16 的结果，为5。</li></ol></li></ol></li></ol><blockquote><p>武技: 开发自定义哈希结构</p></blockquote><ol><li>开发哈希类 <code>MyHashTest -> MyHash</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> hash;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@SuppressWarnings</span>(<span style=color:#e6db74>&#34;all&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyHashTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 哈希类 */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Data</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyHash</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Data</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@AllArgsConstructor</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>private</span> String key;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>private</span> Object value;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>private</span> MyHash.<span style=color:#a6e22e>Node</span> next;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 底层数组 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> MyHash.<span style=color:#a6e22e>Node</span><span style=color:#f92672>[]</span> nodes <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyHash.<span style=color:#a6e22e>Node</span><span style=color:#f92672>[</span>4<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 底层数组中非null元素的个数 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Integer elementLength <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 加载因子: 当数组当前容量超过 capacity * factor 时，进行扩容 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>float</span> factor <span style=color:#f92672>=</span> 0.<span style=color:#a6e22e>75f</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>开发方法 <code>MyHashTest -> MyHash -> hash()</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyHashTest</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyHash</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 计算指定元素的hash值并返回
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @param obj 待计算的元素
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @return 指定元素的hash值
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>hash</span>(Object obj) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 对 `obj` 参数进行空值保护</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (obj <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> 0;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 获取Hash值</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> h <span style=color:#f92672>=</span> obj.<span style=color:#a6e22e>hashCode</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 使用扰动函数和取余处理优化Hash值并返回</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> (h <span style=color:#f92672>^</span> (h <span style=color:#f92672>&gt;&gt;&gt;</span> 16)) <span style=color:#f92672>&amp;</span> (nodes.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> 1);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testHash</span>() {
</span></span><span style=display:flex><span>        MyHash myHash <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyHash();
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(myHash.<span style=color:#a6e22e>hash</span>(<span style=color:#e6db74>&#34;周&#34;</span>));
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(myHash.<span style=color:#a6e22e>hash</span>(<span style=color:#e6db74>&#34;航&#34;</span>));
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(myHash.<span style=color:#a6e22e>hash</span>(<span style=color:#e6db74>&#34;宇&#34;</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li>开发方法 <code>MyHashTest -> MyHash -> put()</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyHashTest</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyHash</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 在数组中存储数据 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>put</span>(String key, Object value) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 在数组的 `hash(key)` 位置上存储一个Node数据</span>
</span></span><span style=display:flex><span>            nodes<span style=color:#f92672>[</span>hash(key)<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyHash.<span style=color:#a6e22e>Node</span>(key, value, nextNode);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 数组中的非null元素计数器自增</span>
</span></span><span style=display:flex><span>            elementLength<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testPut</span>() {
</span></span><span style=display:flex><span>        MyHash myHash <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyHash();
</span></span><span style=display:flex><span>        myHash.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;周&#34;</span>, <span style=color:#e6db74>&#34;zhou&#34;</span>);
</span></span><span style=display:flex><span>        myHash.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;航&#34;</span>, <span style=color:#e6db74>&#34;hang&#34;</span>);
</span></span><span style=display:flex><span>        myHash.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;宇&#34;</span>, <span style=color:#e6db74>&#34;yu&#34;</span>);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(myHash);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=4><li>开发方法 <code>MyHashTest -> MyHash -> get()</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyHashTest</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyHash</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 从数组中获取数据 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> MyHash.<span style=color:#a6e22e>Node</span> <span style=color:#a6e22e>get</span>(String key) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> nodes<span style=color:#f92672>[</span>hash(key)<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testGet</span>() {
</span></span><span style=display:flex><span>        MyHash myHash <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyHash();
</span></span><span style=display:flex><span>        myHash.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;周&#34;</span>, <span style=color:#e6db74>&#34;zhou&#34;</span>);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(myHash.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;周&#34;</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=ep04-哈希数组扩容>EP04. 哈希数组扩容</h2><blockquote><p>心法: 哈希数组扩容</p></blockquote><ul><li>当底层数组到达一定阈值时，需要对数组进行扩容，这个阈值就是加载因子，是一个浮点数。</li><li>数组扩容时乘以2的N次方，可以使Hash分布更均匀:<ul><li>假设初始容量为16，减1后，15的二进制后四位为 <code>1111</code>，位与运算的结果会更均匀。</li></ul></li></ul><blockquote><p>武技: 开发数组扩容方法</p></blockquote><ol><li>开发方法 <code>MyHashTest -> MyHash -> expansion()</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyHashTest</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyHash</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 数组扩容 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>expansion</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 创建新数组，长度为当前数组长度的两倍</span>
</span></span><span style=display:flex><span>            MyHash.<span style=color:#a6e22e>Node</span><span style=color:#f92672>[]</span> newNodes <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyHash.<span style=color:#a6e22e>Node</span><span style=color:#f92672>[</span>nodes.<span style=color:#a6e22e>length</span> <span style=color:#f92672>*</span> 2<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 拷贝数据到新数组</span>
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>arraycopy</span>(nodes, 0, newNodes, 0, nodes.<span style=color:#a6e22e>length</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 交换引用</span>
</span></span><span style=display:flex><span>            nodes <span style=color:#f92672>=</span> newNodes;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>修改方法 <code>MyHashTest -> MyHash -> put()</code>:<ul><li>每次添加新数据时，判断是否需要进行扩容。</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyHashTest</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyHash</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 在数组中存储数据 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>put</span>(String key, Object value) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 每次添加新数据时，判断是否需要进行扩容</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (elementLength <span style=color:#f92672>&gt;=</span> nodes.<span style=color:#a6e22e>length</span> <span style=color:#f92672>*</span> factor) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 数组扩容</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>expansion</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ..</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testExpansion</span>() {
</span></span><span style=display:flex><span>        MyHash myHash <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyHash();
</span></span><span style=display:flex><span>        myHash.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;高渐离&#34;</span>, <span style=color:#e6db74>&#34;gao-jian-li&#34;</span>);
</span></span><span style=display:flex><span>        myHash.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;钟无艳&#34;</span>, <span style=color:#e6db74>&#34;zhong-wu-yan&#34;</span>);
</span></span><span style=display:flex><span>        myHash.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;李元芳&#34;</span>, <span style=color:#e6db74>&#34;li-yuan-fang&#34;</span>);
</span></span><span style=display:flex><span>        myHash.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;狄仁杰&#34;</span>, <span style=color:#e6db74>&#34;di-ren-jie&#34;</span>);
</span></span><span style=display:flex><span>        myHash.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;老夫子&#34;</span>, <span style=color:#e6db74>&#34;lao-fu-zi&#34;</span>);
</span></span><span style=display:flex><span>        myHash.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;安琪拉&#34;</span>, <span style=color:#e6db74>&#34;an-qi-la&#34;</span>);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(myHash);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=ep05-哈希数组重构>EP05. 哈希数组重构</h2><blockquote><p>心法: 哈希数组重构 <code>rehash</code></p></blockquote><ul><li>当数组扩容后，因为数组长度改变，Hash规则也改变。</li><li>为避免数据倾斜，需要将原数组的每个元素重新Hash到新数组。</li></ul><blockquote><p>武技: 开发哈希数组重构方法</p></blockquote><ol><li>开发方法 <code>MyHashTest -> MyHash -> rehash()</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyHashTest</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyHash</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** Hash重构操作 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>rehash</span>() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 创建临时数组</span>
</span></span><span style=display:flex><span>            MyHash.<span style=color:#a6e22e>Node</span><span style=color:#f92672>[]</span> newNodes <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyHash.<span style=color:#a6e22e>Node</span><span style=color:#f92672>[</span>nodes.<span style=color:#a6e22e>length</span><span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 遍历原数组中的全部Node数据，并进行空值保护</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (MyHash.<span style=color:#a6e22e>Node</span> node : nodes) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (node <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// rehash操作</span>
</span></span><span style=display:flex><span>                    newNodes<span style=color:#f92672>[</span>hash(node.<span style=color:#a6e22e>getKey</span>())<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>                            <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyHash.<span style=color:#a6e22e>Node</span>(node.<span style=color:#a6e22e>getKey</span>(), node.<span style=color:#a6e22e>getValue</span>(), <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 将临时数组的引用递交给原数组变量</span>
</span></span><span style=display:flex><span>            nodes <span style=color:#f92672>=</span> newNodes;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>修改方法 <code>MyHashTest -> MyHash -> expansion()</code>:<ul><li>每次扩容结束后，执行一次重构操作。</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyHashTest</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyHash</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 数组扩容 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>expansion</span>() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ..</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>rehash</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=ep06-哈希碰撞冲突>EP06. 哈希碰撞冲突</h2><blockquote><p>心法: 哈希碰撞冲突，简称哈希冲突或哈希碰撞</p></blockquote><table><thead><tr><th>冲突类型</th><th>描述</th></tr></thead><tbody><tr><td>键冲突</td><td>两个 <code>key</code> 相同，此时会发生值覆盖。</td></tr><tr><td>哈希冲突</td><td>两个 <code>key</code> 不相同，但它们的 <code>hash(key)</code> 值相同的情况，此时视为哈希冲突。</td></tr></tbody></table><blockquote><p>心法: 哈希冲突解决方案</p></blockquote><table><thead><tr><th>解决方案</th><th>方案详情</th><th>其他</th></tr></thead><tbody><tr><td>再哈希法</td><td>构建多个Hash函数，当哈希冲突时，再计算另一个函数，直到不冲突为止。</td><td>每次冲突都要重新哈希，计算时间增加</td></tr><tr><td>公共溢出表</td><td>将哈希表分为基本表和公共溢出表，凡是和基本表发生冲突的元素，一律填入溢出表。</td><td>查找冲突元素时，需要再遍历一次溢出表</td></tr><tr><td>开放定址法再散列法</td><td>1. 添加元素时，若发生哈希冲突，则利用公式向后探测    一个新的空闲位置来存储新元素。2. 删除元素时，会在目标位置上添加 <code>isDelete</code> 标记，    表示该位置上的元素已经被删除了。3. 查找元素时，若目标位置上不是目标元素，则开始线    性探测，遇 <code>isDelete</code> 继续探测，遇空闲位置停止，    若探测次数超过数组长度，则表示该数组已无空闲位    置，应该扩容了。</td><td>探测公式: <code>(Hash值 + i) % 数组长度</code>线性探测: <code>i = 1, 2, 3, 4, 5, 6, ..</code>平方探测: <code>i = 1², -1², 2², -2², ..</code>随机探测: <code>i = 随机数</code>公式中的取余操作是为了避免数组越界</td></tr><tr><td>链地址法链接法拉链法</td><td>1. 添加元素时，若发生哈希冲突，则在冲突的位置上建    立一个链表，并将所有冲突的元素追加到链表。2. 查找元素时，若目标位置上不是目标元素，则进入链    表查找或者红黑树查找。</td><td>HashMap底层采用该方案解决哈希冲突底层结构: <code>Entry[] + 单链表 + 红黑树</code>容量规则: 初始16，扩容时乘以2的N次方树化阈值: 数组某位置上的链表长度超过8退化阈值: 数组某位置上的链表长度小于6</td></tr></tbody></table><blockquote><p>武技: 使用链地址法解决哈希冲突</p></blockquote><ol><li>修改方法 <code>MyHashTest -> MyHash -> put()</code>:<ul><li>每次存值前，若发生哈希冲突，则将新元素前插到链表中。</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyHashTest</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyHash</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 在数组中存储数据 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>put</span>(String key, Object value) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ..</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 若发生哈希冲突</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 提取当前位置上的元素，即链表头元素</span>
</span></span><span style=display:flex><span>            MyHash.<span style=color:#a6e22e>Node</span> headNode <span style=color:#f92672>=</span> nodes<span style=color:#f92672>[</span>hash(key)<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 定义当前位置上元素的next后继元素，初始为null</span>
</span></span><span style=display:flex><span>            MyHash.<span style=color:#a6e22e>Node</span> nextNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (headNode <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 将非空链表头备份到新链表头的后继元素变量中</span>
</span></span><span style=display:flex><span>                nextNode <span style=color:#f92672>=</span> headNode;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 设置新元素为链表头</span>
</span></span><span style=display:flex><span>            nodes<span style=color:#f92672>[</span>hash(key)<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyHash.<span style=color:#a6e22e>Node</span>(key, value, nextNode);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 数组中的非null元素计数器自增</span>
</span></span><span style=display:flex><span>            elementLength<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>修改方法 <code>MyHashTest -> MyHash -> get()</code>:<ul><li>每次取值时，若发生哈希冲突，则顺着链表向下寻找。</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyHashTest</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyHash</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 从数组中获取数据 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> MyHash.<span style=color:#a6e22e>Node</span> <span style=color:#a6e22e>get</span>(String key) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 提取当前位置上的元素，即链表头元素</span>
</span></span><span style=display:flex><span>            MyHash.<span style=color:#a6e22e>Node</span> headNode <span style=color:#f92672>=</span> nodes<span style=color:#f92672>[</span>hash(key)<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (headNode <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 获取到的结果不是目标key，则开始链表查询</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>key.<span style=color:#a6e22e>equals</span>(headNode.<span style=color:#a6e22e>getKey</span>())) {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 循环向下寻找代码</span>
</span></span><span style=display:flex><span>                    headNode <span style=color:#f92672>=</span> headNode.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 返回最终目标元素</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> headNode;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** hash冲突 */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testHashConflict</span>() {
</span></span><span style=display:flex><span>        MyHash myHash <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyHash();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 钟无艳的hash值分别为 (3, 0, 3)</span>
</span></span><span style=display:flex><span>        myHash.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;钟&#34;</span>, <span style=color:#e6db74>&#34;zhong&#34;</span>);
</span></span><span style=display:flex><span>        myHash.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;无&#34;</span>, <span style=color:#e6db74>&#34;wu&#34;</span>);
</span></span><span style=display:flex><span>        myHash.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;艳&#34;</span>, <span style=color:#e6db74>&#34;yan&#34;</span>);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(myHash);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(myHash.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;钟&#34;</span>));
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(myHash.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;艳&#34;</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><svg id="btt-button" class="arrow-logo" xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 384 512" onclick="scrollToTop()" title="Go to top"><path d="M177 159.7l136 136c9.4 9.4 9.4 24.6.0 33.9l-22.6 22.6c-9.4 9.4-24.6 9.4-33.9.0L160 255.9l-96.4 96.4c-9.4 9.4-24.6 9.4-33.9.0L7 329.7c-9.4-9.4-9.4-24.6.0-33.9l136-136c9.4-9.5 24.6-9.5 34-.1z"/></svg>
<script>let backToTopButton=document.getElementById("btt-button");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?backToTopButton.style.display="block":backToTopButton.style.display="none"}function scrollToTop(){window.scrollTo(0,0)}</script></div></main><footer class=footer><span>&copy; 2024 The Marauders</span>
<span>Made with &#10084;&#65039; using <a target=_blank href=https://github.com/gokarna-theme/gokarna-hugo>Gokarna</a></span></footer></body></html>