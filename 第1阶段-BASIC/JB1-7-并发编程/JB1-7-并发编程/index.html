<!doctype html><html lang=en><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><style>:root{--accent-color:#FF4D4D}</style><title>JB1-7-并发编程</title>
<meta name=description content="[!NOTE] Java道经第1卷 - 第7阶 - 并发编程 v1-7-basic-thread (JAR)
S01. 多线程基础入门 E01. 线程基础概念 1. 进程VS线程 启动一个程序至少启动了一个进程，启动一个进程至少启动了一个线程。 名称 描述 切换开销 数据空间 进程 OS …"><meta name=keywords content='blog,lsx2216,hugo'><meta property="og:url" content="https://lsx2216.netlify.app/%E7%AC%AC1%E9%98%B6%E6%AE%B5-BASIC/JB1-7-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JB1-7-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><meta property="og:type" content="website"><meta property="og:title" content="JB1-7-并发编程"><meta property="og:description" content="[!NOTE] Java道经第1卷 - 第7阶 - 并发编程 v1-7-basic-thread (JAR)
S01. 多线程基础入门 E01. 线程基础概念 1. 进程VS线程 启动一个程序至少启动了一个进程，启动一个进程至少启动了一个线程。 名称 描述 切换开销 数据空间 进程 OS …"><meta property="og:image" content="https://lsx2216.netlify.app/assets/images/user.jpg"><meta property="og:image:secure_url" content="https://lsx2216.netlify.app/assets/images/user.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="JB1-7-并发编程"><meta name=twitter:description content="[!NOTE] Java道经第1卷 - 第7阶 - 并发编程 v1-7-basic-thread (JAR)
S01. 多线程基础入门 E01. 线程基础概念 1. 进程VS线程 启动一个程序至少启动了一个进程，启动一个进程至少启动了一个线程。 名称 描述 切换开销 数据空间 进程 OS …"><meta property="twitter:domain" content="https://lsx2216.netlify.app/%E7%AC%AC1%E9%98%B6%E6%AE%B5-BASIC/JB1-7-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JB1-7-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><meta property="twitter:url" content="https://lsx2216.netlify.app/%E7%AC%AC1%E9%98%B6%E6%AE%B5-BASIC/JB1-7-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JB1-7-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><meta name=twitter:image content="https://lsx2216.netlify.app/assets/images/user.jpg"><link rel=canonical href=https://lsx2216.netlify.app/%E7%AC%AC1%E9%98%B6%E6%AE%B5-BASIC/JB1-7-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JB1-7-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/><link rel=stylesheet type=text/css href=/css/normalize.min.css media=print><link rel=stylesheet type=text/css href=/css/main.min.css><link id=dark-theme rel=stylesheet href=/css/dark.min.css><script src=/js/bundle.min.3eb19cb61dde9e37b9522867f3e024aeb68e26ab8e03252e46e365abcb19acf7.js integrity="sha256-PrGcth3enje5Uihn8+AkrraOJquOAyUuRuNlq8sZrPc="></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css integrity=sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js integrity=sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})})</script>    <link rel="shortcut icon" href="/assets/images/user.jpg" type="image/x-icon">
</head><body><script>setThemeByUserPref()</script><header class=header><nav class=header-nav><div class=avatar><a href=https://lsx2216.netlify.app/><img src=/assets/images/user.jpg alt=avatar></a></div><div class=nav-title><a class=nav-brand href=https://lsx2216.netlify.app/>lsx2216</a></div><div class=nav-links><div class=nav-link><a href=https://lsx2216.netlify.app/ aria-label><span data-feather=home></span> Home</a></div><div class=nav-link><a href=https://lsx2216.netlify.app/projects/ aria-label><span data-feather=code></span> Projects</a></div><div class=nav-link><a href=https://github.com aria-label=github><span data-feather=github></span></a></div><span class=nav-icons-divider></span><div class="nav-link dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
<a aria-hidden=true role=switch><span class=theme-toggle-icon data-feather=moon></span></a></div><div class=nav-link id=hamburger-menu-toggle><span class="sr-only hamburger-menu-toggle-screen-reader-target">menu</span>
<a aria-checked=false aria-labelledby=hamburger-menu-toggle id=hamburger-menu-toggle-target role=switch><span data-feather=menu></span></a></div><ul class="nav-hamburger-list visibility-hidden"><li class=nav-item><a href=https://lsx2216.netlify.app/><span data-feather=home></span> Home</a></li><li class=nav-item><a href=https://lsx2216.netlify.app/projects/><span data-feather=code></span> Projects</a></li><li class=nav-item><a href=https://github.com><span data-feather=github></span></a></li><li class="nav-item dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
<a role=switch><span class=theme-toggle-icon data-feather=moon></span></a></li></ul></div></nav></header><main id=content><div class="post container"><div class=post-header-section><h1>JB1-7-并发编程</h1></div><div class=post-content><blockquote><p>[!NOTE] Java道经第1卷 - 第7阶 - 并发编程
v1-7-basic-thread (JAR)</p></blockquote><h1 id=s01-多线程基础入门>S01. 多线程基础入门</h1><h2 id=e01-线程基础概念>E01. 线程基础概念</h2><h3 id=1-进程vs线程>1. 进程VS线程</h3><ul><li>启动一个程序至少启动了一个进程，启动一个进程至少启动了一个线程。</li></ul><table><thead><tr><th>名称</th><th>描述</th><th>切换开销</th><th>数据空间</th></tr></thead><tbody><tr><td>进程</td><td>OS进行分配和管理资源的基本单位</td><td>大</td><td>进程间独立</td></tr><tr><td>线程</td><td>CPU调度和分派的基本单位，是进程的一条执行路径</td><td>小</td><td>线程间共享</td></tr><tr><td>![[excalidraw/进程和线程的区别#^group=1KF5Ai7pvAYL6ECz9wVTz</td><td>9999]]</td><td></td><td></td></tr></tbody></table><h3 id=2-线程调度器>2. 线程调度器</h3><blockquote><p>心法: 线程调度器 <code>Thread Scheduler</code>，简称TS</p></blockquote><ul><li>线程调度：指操作系统在多线程环境下决定哪个线程应该在何时运行的过程：<ul><li>当多线程需要共享CPU资源时，需要一种机制来合理地分配CPU时间片，以最大程度地提高系统的吞吐量和响应性能。</li></ul></li><li>线程调度器：是操作系统内核中，负责线程调度的一个重要组件。</li></ul><table><thead><tr><th>线程调度方案</th><th>描述（线程调度器简称TS）</th></tr></thead><tbody><tr><td>抢占式调度</td><td>TS允许更高优先级的任务在任何时刻抢占当前任务，以确保系统能够及时响应高优先级任务的需求该方案是win11默认的调度方案</td></tr><tr><td>时间片轮转</td><td>TS先将CPU的执行时间划分成N个随机片段，然后为每个线程分配一个固定的时间片每个时间片内，TS都随机选择一个线程执行，当时间片结束时将CPU资源分配给下一个线程该方案可以避免线程饥饿，即避免某个线程长时间占用CPU的情况，从而提高了系统的响应速度和效率</td></tr><tr><td>优先级调度</td><td>TS根据线程的优先级来确定下一个执行的线程，容易产生线程饥饿问题</td></tr><tr><td>多级反馈队列调度</td><td>假设创建3个优先级队列A,B和C，三个队列优先级递减，且时间片递减（分别为10ms, 20ms和30ms）1. 当系统启动时，所有的线程都被TS放入队列A，分配时间片10ms2. 当线程T在10ms内仍没执行完任务，则让出CPU，降级到队列B，以获得更大的时间片3. 当线程T在20ms内仍没执行完任务，则让出CPU，降级到队列C，以获得更大的时间片4. 当线程T在30ms内仍没执行完任务，则重新分配到队列C，循环往复，直到完成</td></tr></tbody></table><h3 id=3-多线程优势>3. 多线程优势</h3><ul><li>CPU的工作就是从内存中将指令一条一条取出并执行，当内存中没有任何指令时，CPU就会处于空闲状态。</li><li>多线程模型的最大好处就是可以提高CPU的资源利用率，即让尽量少的CPU处于空闲状态。</li></ul><h3 id=4-并发vs并行>4. 并发VS并行</h3><blockquote><p>心法: 并发 Concurrency</p></blockquote><ul><li>多任务交替运行：在并发中，多个任务或操作可能交替执行，每个任务都在一段时间内得到处理，但不一定是同时执行。</li><li>并发通常用于描述系统中同时存在多个活动任务或操作的情况，这些任务可能是独立的，也可能是相关联的。</li></ul><blockquote><p>心法: 并行 Parallelism</p></blockquote><ul><li>多任务同时运行：在并行中，多个任务或操作确实同时执行，每个任务都在不同的处理器核心上独立运行。</li><li>并行通常用于描述系统中真正同时执行多个任务的情况，这些任务通常是相互独立的，彼此不受影响。</li></ul><h2 id=e02-线程创建方式>E02. 线程创建方式</h2><blockquote><p>心法: 何为用户线程？</p></blockquote><ul><li>用户线程也叫前台线程，在Java程序中，main方法中的主线程，junit方法中的主线程，以及在主线程中开启的子线程，都属于前台用户线程。</li></ul><h3 id=1-主线程的退出>1. 主线程的退出</h3><table><thead><tr><th>场景来源</th><th>退出时机</th><th>是否等待子线程结束</th></tr></thead><tbody><tr><td>main方法中的主线程</td><td>全部子线程结束后退出</td><td>等</td></tr><tr><td>junit方法中的主线程</td><td>主线程结束后立即退出</td><td>不等，但支持手动阻止主线程结束</td></tr></tbody></table><h3 id=2-创建用户线程>2. 创建用户线程</h3><blockquote><p>心法: 创建用户线程的流程</p></blockquote><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR
继承Thread方案 -.- 创建线程类
实现Runnable方案 -.- 创建线程类
创建线程类 --&gt; 重写run方法 --&gt; 实例化线程类 --&gt; 启动线程
</code></pre><ol><li>创建一个线程类，该线程类需要继承 <code>java.lang.Thread</code> 类或实现 <code>java.lang.Runnable</code> 接口：<ol><li>推荐使用实现接口的方式创建线程类，因为Java的单继承比如Java的多实现拓展性高。</li><li>Thread类本身也实现了Runnable接口。</li></ol></li><li>重写Runnable接口中的run方法，该方法也叫线程体，用于编写线程任务，无返回值。</li><li>实例化线程类，并对实例调用 <code>start()</code> 方法以启动该线程：<ol><li>调用 <code>start()</code> 方法不意味着线程立刻执行，而是进入READY状态，等待争抢CPU资源。</li><li>调用 <code>run()</code> 方法也可以执行线程体方法，但不具有任何线程特性，比如线程争抢等。</li></ol></li></ol><blockquote><p>武技: 测试通过继承Thread方式创建并启动线程</p></blockquote><p><code>start.NewByThreadTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NewByThreadTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 通过继承Thread的方式开发前台线程类 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SubThread</span> <span style=color:#66d9ef>extends</span> Thread {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 线程体: 该线程需要做的事情 */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 10; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;子线程A-thread: &#34;</span> <span style=color:#f92672>+</span> i);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>test</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建一个线程实例并启动</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> SubThread().<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 阻塞junit线程</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(10L);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>武技: 测试通过实现Runnable的方式创建并启动线程</p></blockquote><p><code>start.NewByRunnableTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NewByRunnableTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 通过实现Runnable的方式开发前台线程类 */</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SubThread</span> <span style=color:#66d9ef>implements</span> Runnable {  
</span></span><span style=display:flex><span>	  
</span></span><span style=display:flex><span>	    <span style=color:#75715e>/** 线程体: 该线程需要做的事情 */</span>  
</span></span><span style=display:flex><span>	    <span style=color:#a6e22e>@Override</span>  
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {  
</span></span><span style=display:flex><span>	        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 10; i<span style=color:#f92672>++</span>) {  
</span></span><span style=display:flex><span>	            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;子线程A-thread: &#34;</span> <span style=color:#f92672>+</span> i);  
</span></span><span style=display:flex><span>	        }  
</span></span><span style=display:flex><span>	    }  
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@Test</span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@SneakyThrows</span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>test</span>() {  
</span></span><span style=display:flex><span>	  
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// 创建一个线程实例并启动  </span>
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>new</span> Thread(<span style=color:#66d9ef>new</span> SubThread()).<span style=color:#a6e22e>start</span>();  
</span></span><span style=display:flex><span>	  
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// 阻塞junit线程  </span>
</span></span><span style=display:flex><span>	    TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(10L);  
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testByInnerClass</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建一个线程实例并启动</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 10; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;子线程B-thread: &#34;</span> <span style=color:#f92672>+</span> i);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 阻塞junit线程</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(10L);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=3-创建守护线程>3. 创建守护线程</h3><blockquote><p>心法: 何为守护线程？</p></blockquote><ul><li>守护线程也叫后台线程，仅当所有前台线程都死掉时才退出，否则就一直在后台活动，比如GC线程。</li><li>在守护线程中产生的新线程也是守护线程。</li></ul><table><thead><tr><th>相关API方法</th><th>描述</th></tr></thead><tbody><tr><td><code>t.setDaemon(true)</code></td><td>设置t线程为守护线程，代码必须写在启动代码前，否则爆发非法线程状态异常</td></tr><tr><td><code>t.isDaemon()</code></td><td>返回t线程是否是一个守护线程</td></tr></tbody></table><blockquote><p>武技: 5秒内守护线程每隔0.5秒输出一遍 &ldquo;t-daemon&rdquo;，5秒后主线程结束，守护线程也结束</p></blockquote><p><code>start.DaemonThreadTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DaemonThreadTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testDaemonThread</span>() {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建一个守护线程实例</span>
</span></span><span style=display:flex><span>        Thread daemonThread <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 线程会在这里睡眠500毫秒</span>
</span></span><span style=display:flex><span>                    TimeUnit.<span style=color:#a6e22e>MILLISECONDS</span>.<span style=color:#a6e22e>sleep</span>(500L);
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;t-daemon&#34;</span>);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                    e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 设置守护线程的操作必须在启动之前完成</span>
</span></span><span style=display:flex><span>        daemonThread.<span style=color:#a6e22e>setDaemon</span>(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 测试该线程是否为守护线程</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(daemonThread.<span style=color:#a6e22e>isDaemon</span>() <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;是守护线程&#34;</span> : <span style=color:#e6db74>&#34;不是守护线程&#34;</span>);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 启动守护线程</span>
</span></span><span style=display:flex><span>        daemonThread.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 让主线程睡眠5秒</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(5L);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;5秒后，主线程退出，守护线程也退出&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=4-相关api方法>4. 相关API方法</h3><blockquote><p>心法: 线程相关API方法</p></blockquote><table><thead><tr><th>相关API方法</th><th>描述</th></tr></thead><tbody><tr><td><code>Thread.currentThread()</code></td><td>返回 <strong>代码当前所在的线程</strong> 的线程实例</td></tr><tr><td><code>t.isAlive()</code></td><td>返回线程是否还活着</td></tr><tr><td><code>t.setName()</code></td><td>设置该线程的名字，也可以在Thread构造时指定。</td></tr><tr><td><code>t.getName()</code></td><td>返回该线程的名称，默认从 <code>thread-0</code> 开始递推。</td></tr><tr><td><code>t.setPriority(优先级)</code></td><td>设置线程优先级，建议使用Thread类的优先级常量。</td></tr><tr><td><code>t.getPriority()</code></td><td>获取线程优先级，默认是5。</td></tr></tbody></table><blockquote><p>武技: 测试线程相关API方法</p></blockquote><p><code>start.ThreadApiTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ThreadApiTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testCurrentThread</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// [thread-0, 5, main]</span>
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>());
</span></span><span style=display:flex><span>        }).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [main, 5, main]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 阻塞junit线程</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(5L);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testThreadName</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 可以在实例化Thread时，在第二个参数中，直接指定子线程的名称</span>
</span></span><span style=display:flex><span>        Thread thread <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>());
</span></span><span style=display:flex><span>        }, <span style=color:#e6db74>&#34;子线程A&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        thread.<span style=color:#a6e22e>setName</span>(<span style=color:#e6db74>&#34;子线程B&#34;</span>);
</span></span><span style=display:flex><span>        thread.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 阻塞junit线程</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(5L);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testIsAlive</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Thread thread <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(thread.<span style=color:#a6e22e>isAlive</span>() <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;子线程存活&#34;</span> : <span style=color:#e6db74>&#34;子线程未启动或挂起&#34;</span>);
</span></span><span style=display:flex><span>        thread.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(thread.<span style=color:#a6e22e>isAlive</span>() <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;子线程存活&#34;</span> : <span style=color:#e6db74>&#34;子线程未启动或挂起&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 阻塞junit线程</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(5L);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testPriority</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Thread thread <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>());
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        thread.<span style=color:#a6e22e>setPriority</span>(Thread.<span style=color:#a6e22e>MAX_PRIORITY</span>);
</span></span><span style=display:flex><span>        thread.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(thread.<span style=color:#a6e22e>getPriority</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 阻塞junit线程</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(5L);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=e03-线程生命周期>E03. 线程生命周期</h2><h3 id=1-七种生命状态>1. 七种生命状态</h3><blockquote><p>心法: 七种生命周期状态</p></blockquote><ul><li>线程的七种生命周期状态对应 <code>java.lang.Thread.State</code> 枚举类中封装的六种枚举常量：<ul><li>其中 <code>READY</code> 和 <code>RUNNING</code> 同时对应 <code>RUNNABLE</code> 状态。</li><li>可以在代码中可以通过 <code>t.getState()</code> 获取到对应的枚举常量。</li></ul></li><li>一个线程总是处于以下七种生命周期状态之一：
![[第1阶段-BASIC/JB1-7-并发编程/excalidraw/线程生命周期.md#^group=yQwWex23YQshg0KnZtA7S|9999]]</li></ul><table><thead><tr><th>线程状态</th><th>状态简述</th><th>状态详述</th></tr></thead><tbody><tr><td><code>NEW</code></td><td>初始状态</td><td>此时线程刚被创建，未启动，未执行，也无资格被TS选中若对其调用 <code>start()</code> 可立即切换到 <code>READY</code> 状态</td></tr><tr><td><code>READY</code></td><td>就绪状态</td><td>此时线程等待被TS选中若线程被TS选中，可立即切换到 <code>RUNNING</code> 状态若对其调用 <code>join()</code> 可立即切换到 <code>RUNNING</code> 状态</td></tr><tr><td><code>RUNNING</code></td><td>运行状态</td><td>此时线程正在执行若线程要访问已上锁的同步资源，则立即被动切换到 <code>BLOCKED</code> 状态若对其调用 <code>wait() / join() / park()</code> 可立即主动切换到 <code>WAITING</code> 状态若对其调用 <code>sleep(t) / wait(t) / join(t)</code> 可立即主动切换到 <code>TIME_WAITING</code> 状态若对其调用 <code>parkNanos(t) / parkUntil(t)</code> 可立即主动切换到 <code>TIME_WAITING</code> 状态</td></tr><tr><td><code>BLOCKED</code></td><td>阻塞状态</td><td>此时线程正在等待获取同步资源的锁若成功访问已上锁的同步资源，则立即切换到 <code>READY</code> 状态</td></tr><tr><td><code>WAITING</code></td><td>等待状态</td><td>此时线程正在等待被唤醒若对其调用 <code>notify() / notifyAll() / unpark()</code> 可立即切换到 <code>READY</code> 状态若对其调用 <code>interrupt()</code> 可立即切换到 <code>READY</code> 状态</td></tr><tr><td><code>TIME_WAITING</code></td><td>计时等待状态</td><td>此时线程正在等待超时若超时，可立即切换到 <code>READY</code> 状态若对其调用 <code>interrupt()</code> 可立即切换到 <code>READY</code> 状态</td></tr><tr><td><code>TERMINATED</code></td><td>终止状态</td><td>此时线程已经死亡当线程体执行完毕，或线程体中代码爆发异常且未处理时，才会进入该状态</td></tr></tbody></table><blockquote><p>武技: 测试线程生命周期状态</p></blockquote><p><code>start.ThreadLifecycleStateTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ThreadLifecycleStateTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testLifecycleState</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建一个线程实例</span>
</span></span><span style=display:flex><span>        Thread threadA <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;子线程A执行完毕..&#34;</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建一个线程实例</span>
</span></span><span style=display:flex><span>        Thread threadB <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                TimeUnit.<span style=color:#a6e22e>HOURS</span>.<span style=color:#a6e22e>sleep</span>(24L);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(e);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;子线程B执行完毕..&#34;</span>);
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 此时子线程刚被创建，处于NEW状态</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;当前子线程A的生命周期状态: &#34;</span> <span style=color:#f92672>+</span> threadA.<span style=color:#a6e22e>getState</span>());
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;当前子线程B的生命周期状态: &#34;</span> <span style=color:#f92672>+</span> threadB.<span style=color:#a6e22e>getState</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 启动子线程</span>
</span></span><span style=display:flex><span>        threadA.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        threadB.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 此时子线程已被启动，处于RUNNABLE状态</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;当前子线程A的生命周期状态: &#34;</span> <span style=color:#f92672>+</span> threadA.<span style=color:#a6e22e>getState</span>());
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;当前子线程B的生命周期状态: &#34;</span> <span style=color:#f92672>+</span> threadB.<span style=color:#a6e22e>getState</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 让主线程睡眠5秒</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(5L);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 此时子线程A早已结束，处于TERMINATED状态，但子线程B还在睡眠，处于TIME_WAITING状态</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;当前子线程A的生命周期状态: &#34;</span> <span style=color:#f92672>+</span> threadA.<span style=color:#a6e22e>getState</span>());
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;当前子线程B的生命周期状态: &#34;</span> <span style=color:#f92672>+</span> threadB.<span style=color:#a6e22e>getState</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-阻塞vs等待>2. 阻塞VS等待</h3><blockquote><p>心法：阻塞和等待有什么区别？</p></blockquote><ul><li>相同点：阻塞和等待都会让线程止步不前：<ul><li>阻塞会让线程进入锁池，不占用CPU资源。</li><li>等待会让线程进入等待池，不占用CPU资源。</li></ul></li><li>不同点：<ul><li>阻塞是一种被动状态，是为了解决多线程之间的资源竞争问题而设计的。</li><li>等待是一种主动手段，是为了解决多线程之间的数据通信方案而设计的。</li></ul></li></ul><h3 id=3-相关api方法>3. 相关API方法</h3><blockquote><p>心法: 线程生命周期相关API方法</p></blockquote><table><thead><tr><th>相关API方法</th><th>描述</th></tr></thead><tbody><tr><td><code>Thread.sleep(1000L)</code></td><td>线程睡眠并进入 <code>TIME_WAITING</code> 状态，睡眠结束后退回到 <code>READY</code> 状态，单位毫秒</td></tr><tr><td><code>TimeUnit.SECONDS.sleep(1L)</code></td><td>TimeUnit工具类中提供的 <code>sleep()</code> 的上层封装</td></tr><tr><td><code>t.join()</code></td><td>将t线程临时加入到 <strong>代码当前所在的线程</strong> 中插队执行线程体任务插队代码必须写在启动代码后，否则无插队效果</td></tr><tr><td><code>Thread.yield()</code></td><td>让出一次被线程调度器选中的机会，但线程调度器下一次还是有可能选择该线程</td></tr></tbody></table><blockquote><p>武技: 测试线程生命周期相关API方法</p></blockquote><p><code>start.ThreadLifecycleApiTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ThreadLifecycleApiTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testSleep</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 让主线程睡眠2秒</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;主线程: 开始睡眠...&#34;</span>);
</span></span><span style=display:flex><span>        Thread.<span style=color:#a6e22e>sleep</span>(2000L);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;主线程: 睡眠结束...&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testTimeUnit</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 让主线程睡眠2秒</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;主线程: 开始睡眠...&#34;</span>);
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(2L);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;主线程: 睡眠结束...&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testJoin</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建子线程</span>
</span></span><span style=display:flex><span>        Thread subThread <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 5; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 子线程启动</span>
</span></span><span style=display:flex><span>        subThread.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 子线程插主线程的队，则必须子线程执行完毕后，主线程才能继续执行</span>
</span></span><span style=display:flex><span>        subThread.<span style=color:#a6e22e>join</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 主线程任务</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 5; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testYield</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建子线程</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 5; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 子线程让出一个时间片，但调度器下一次还是有可能选择我</span>
</span></span><span style=display:flex><span>                Thread.<span style=color:#a6e22e>yield</span>();
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 主线程任务</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 5; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 阻塞junit线程</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(3L);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=e04-停止线程方式>E04. 停止线程方式</h2><h3 id=1-停止运行的线程>1. 停止运行的线程</h3><ul><li>当一个 <code>RUNNABLE</code> 状态的线程完成了自己的线程体任务，就表示这个线程停止了。</li><li>可以人为更改循环标志，迫使线程体运行完毕而结束线程。</li></ul><table><thead><tr><th>相关API方法</th><th>描述</th></tr></thead><tbody><tr><td><code>t.stop()</code></td><td>方法已过时且容易产生线程状态不一致等问题，不建议使用</td></tr></tbody></table><blockquote><p>武技: 测试停止一个运行的线程</p></blockquote><p><code>start.StopRunnableThreadTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StopRunnableThreadTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 本类用于测试使用标识变量的方式停止运行中的线程 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SubThread</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 标识当前线程体中的while循环是否可以结束 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>boolean</span> isStop;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>isStop) {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;子线程运行..&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;子线程结束..&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 停止一个正常运行的线程 */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testStopRunnableThread</span>() {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建线程类</span>
</span></span><span style=display:flex><span>        SubThread subThread <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SubThread();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建线程并启动这个线程</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(subThread).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 主线程在5s后手动更改线程实例中的isStop标识变量</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(5L);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 在主线程中更改 `isStop` 标识变量</span>
</span></span><span style=display:flex><span>        subThread.<span style=color:#a6e22e>isStop</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 阻塞junit线程</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(10L);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-停止挂起的线程>2. 停止挂起的线程</h3><ul><li>若当前线程处于挂起状态，如进行了 <code>wait()/sleep()</code> 等操作，则建议先强行打断该线程，然后在异常处理中更改循环标志，迫使线程体运行完毕而结束线程。</li></ul><table><thead><tr><th>相关API方法</th><th>描述</th></tr></thead><tbody><tr><td><code>t.interrupt()</code></td><td>强行打断t线程，该方法会抛出一个 <code>InterruptedException</code> 异常</td></tr></tbody></table><blockquote><p>武技: 测试停止一个挂起的线程</p></blockquote><p><code>start.StopSleepThreadTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> start;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StopSleepThreadTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 本类用于测试强行停止挂起中的线程 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SleepThread</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 标识当前线程体中的while循环是否可以结束 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>boolean</span> isStop;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>isStop) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 让子线程挂起: 睡眠24小时</span>
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;子线程挂起...&#34;</span>);
</span></span><span style=display:flex><span>                    TimeUnit.<span style=color:#a6e22e>HOURS</span>.<span style=color:#a6e22e>sleep</span>(24L);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;5s后，子线程被interrupt打断...&#34;</span>);
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 更改循环标志</span>
</span></span><span style=display:flex><span>                    isStop <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;子线程结束...&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testStopSleepThread</span>() {
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建线程并启动这个线程</span>
</span></span><span style=display:flex><span>        Thread thread <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(<span style=color:#66d9ef>new</span> SleepThread());
</span></span><span style=display:flex><span>        thread.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 主线程在5s后强行打断该线程，会爆发InterruptedException异常</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(5L);
</span></span><span style=display:flex><span>        thread.<span style=color:#a6e22e>interrupt</span>();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 阻塞junit线程</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(10L);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=s02-多线程内存模型>S02. 多线程内存模型</h1><h2 id=e01-电脑内存通信模型>E01. 电脑内存通信模型</h2><blockquote><p>心法: 计算机中大部分元件都是通过总线和IO桥和来进行通信的</p></blockquote><ul><li>CPU通过系统总线（硬件）连接到IO-Bridge。</li><li>内存通过内存总线（硬件）连接到IO-Bridge。</li><li>其他元件如USB/显卡/磁盘/网卡驱动等，通过IO总线（硬件）连接到IO-Bridge。</li></ul><p>![[第1阶段-BASIC/JB1-7-并发编程/excalidraw/计算机通信模型.md#^group=IfoNynHfyOUwLORERDNQv|9999]]</p><h3 id=1-cpu硬件>1. CPU硬件</h3><ul><li>一般个人用笔记本都是单CPU主板，只能安装一颗CPU，服务器才有可能使用多CPU主板。</li><li>可通过 <code>任务管理器 -> 性能 -> CPU -> 插槽</code> 查看CPU插槽个数。</li></ul><h3 id=2-cpu核心>2. CPU核心</h3><ul><li>一颗CPU中存在多个核心，如双核/四核/八核等。</li><li>一个CPU核心由CPU运算器（计算），CPU控制器（收发指令）和CPU寄存器（保存计算中间值）组成。</li><li>每个核心都独有一级高速缓存L1和二级高速缓存L2，一个CPU中的全部CPU核心共享三级高速缓存L3。</li><li>可通过 <code>任务管理器 -> 性能 -> CPU -> 内核</code> 查看CPU核数。</li><li>可通过 <code>任务管理器 -> 性能 -> CPU -> L1/L2/L3</code> 查看三个级别缓存的空间大小。</li></ul><h3 id=3-cpu线程>3. CPU线程</h3><ul><li>每个核心都能独立运行至少一个线程。</li><li>Intel发明了超线程技术，让一个核心可以模拟两个线程，但四核八线程仍远不及真八核效率高。</li><li>每个线程都有一个独享的工作内存，可以对应理解为Java中的线程栈内存空间。</li><li>可通过 <code>任务管理器 -> 性能 -> CPU -> 逻辑处理器</code> 查看CPU线程数。</li></ul><h3 id=4-主内存>4. 主内存</h3><ul><li>主内存:来自物理内存条中的概念。</li><li>全部CPU核心共享同一个主内存，多线程从主存中获取数据，但并不在主存上直接操作数据。</li><li>CPU读取数据的顺序为 <code>L1 -> L2 -> L3 -> 主存</code>: 读取成功时会依次向前备份。</li></ul><h3 id=5-jmm通信原理>5. JMM通信原理</h3><blockquote><p>心法: Java内存模型简称JMM，拥有8种原子性操作，共同完成线程和主存的通信过程</p></blockquote><table><thead><tr><th>命令</th><th>中文</th><th>描述</th></tr></thead><tbody><tr><td>lock</td><td>锁定</td><td>对主内存变量加锁，标识一个线程独占状态</td></tr><tr><td>read</td><td>读取</td><td>从主内存读取数据</td></tr><tr><td>load</td><td>载入</td><td>将主内存的数据写入工作内存</td></tr><tr><td>use</td><td>使用</td><td>从工作内存读取数据计算</td></tr><tr><td>assign</td><td>赋值</td><td>将计算好的值重新赋值到工作内存中</td></tr><tr><td>store</td><td>存储</td><td>将工作内存的值写入主内存</td></tr><tr><td>write</td><td>写入</td><td>将store过去的变量值赋值给主内存中的变量</td></tr><tr><td>unlock</td><td>解锁</td><td>将主内存变量解锁，解锁后才允许其他线程操作该变量</td></tr></tbody></table><blockquote><p>心法: 假设某个线程的任务是将 <code>a = 18</code> 重新赋值为 <code>a = 60</code>，那么流程是什么？</p></blockquote><ol><li>lock加锁：对主存中的变量 <code>a</code> 进行加锁，标识该变量被本线程独占，此过程在同步时才会生效。</li><li>read读取：该线程将主内存中的 <code>a</code> 进行拷贝，此时原变量 <code>a</code> 和临时变量 <code>a</code> 仍在主存中。</li><li>load载入：将临时变量 <code>a</code> 通过总线加载到线程的工作内存中。</li><li>use使用：对线程工作内存中的临时变量 <code>a</code> 进行计算：<ol><li>CPU控制器负责接收计算指令。</li><li>CPU运算器负责计算，并得到 <code>a = 60</code> 结果。</li><li>CPU寄存器负责存储计算结果。</li></ol></li><li>assign赋值：将计算结果 <code>60</code> 重新赋值给工作内存中的临时变量 <code>a</code> 。</li><li>store存储：线程的工作内存中的临时变量 <code>a</code> 通过总线存储到主存。</li><li>write写入：在主存中，将变量 <code>a</code> 重新赋值为 <code>60</code>。</li><li>unlock解锁：对主存中的变量 <code>a</code> 进行解锁，解锁后才允许其他线程操作该变量，此过程在同步时才会生效。</li></ol><p><img src=/%E7%AC%AC1%E9%98%B6%E6%AE%B5-BASIC/JB1-7-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image/aef9e22b5b8a1d55395f1c349781c034.png alt=计算机通信操作></p><h2 id=e02-volatile关键字>E02. Volatile关键字</h2><h3 id=1-volatile保证可见性>1. Volatile保证可见性</h3><blockquote><p>心法: volatile关键字可以保证可见性</p></blockquote><ul><li>使用volatile修饰的变量可以保证该变量的可见性，开启MESI缓存一致性协议:<ul><li>当某线程操作volatile变量后，立刻通知全部CPU核心缓存中的该变量立刻失效，然后原子性地回写主存。</li><li>当某线程读取volatile变量时，重新到主存中获取该变量最新的值。</li></ul></li><li>尽量仅使用volatile修饰基本类型，修饰引用类型时只对其本身的改动保证可见性:<ul><li><code>volatile User user</code> -> <code>user = new User()</code>: 本身地址发生改动，保证可见性。</li><li><code>volatile User user</code> -> <code>user.setName("赵四")</code>: 内部属性发生改动，不保证可见性。</li></ul></li></ul><blockquote><p>武技: 测试volatile关键字是否可以保证可见性</p></blockquote><p><code>memory.VolatileVisibleTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>VolatileVisibleTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 用于测试volatile可见性效果 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SubThread</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** volatile保证变量可见性 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>boolean</span> flag;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 使用空的循环体来阻塞当前线程，死等flag值的变化</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>flag) {}
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;子线程执行完毕..&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>test</span>() {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 启动一个子线程</span>
</span></span><span style=display:flex><span>        SubThread subThread <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SubThread();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(subThread).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 主线程2秒后，改变子线程的flag标识变量为true</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(2L);
</span></span><span style=display:flex><span>        subThread.<span style=color:#a6e22e>flag</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;主线程改变了子线程中flag变量的值为true..&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 阻止主线程结束</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(5L);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;主线程执行完毕..&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-volatile保证有序性>2. Volatile保证有序性</h3><blockquote><p>心法: 指令重排</p></blockquote><ul><li>在不影响最终结果的前提下，JVM可能会将代码的指令重排序后执行，以提高运行效率。</li><li>但也可能会对我们的代码逻辑产生影响。</li><li>volatile会对指令添加内存屏障，故而volatile修饰的变量会禁止JVM对其进行指令重排，从而保证有序性。</li></ul><blockquote><p>武技: 测试volatile关键字是否可以保证有序性</p></blockquote><p><code>memory.VolatileOrderTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>VolatileOrderTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** volatile指令重排序测试属性 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> 0, y <span style=color:#f92672>=</span> 0, a <span style=color:#f92672>=</span> 0, b <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testOrderReorder</span>() {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 无限循环，仅当出现了指令重排的情况下，跳出循环</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; <span style=color:#66d9ef>true</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 创建子线程A，将a修改为1，将x修改为b的值</span>
</span></span><span style=display:flex><span>            Thread threadA <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>                a <span style=color:#f92672>=</span> 1;
</span></span><span style=display:flex><span>                x <span style=color:#f92672>=</span> b;
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 创建子线程B，将b修改为1，将y修改为a的值</span>
</span></span><span style=display:flex><span>            Thread threadB <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>                b <span style=color:#f92672>=</span> 1;
</span></span><span style=display:flex><span>                y <span style=color:#f92672>=</span> a;
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 启动两个子线程</span>
</span></span><span style=display:flex><span>            threadA.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>            threadB.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 让两个子线程插主线程的队，否则可能出现子线程还没赋值完毕，主线程就开始打印的问题</span>
</span></span><span style=display:flex><span>            threadA.<span style=color:#a6e22e>join</span>();
</span></span><span style=display:flex><span>            threadB.<span style=color:#a6e22e>join</span>();
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 打印每一次的赋值的结果</span>
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;第%d次: x=%d，y=%d\n&#34;</span>, i, x, y);
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 若出现 x=0, y=0 的情况，一定发生了执行重排序，结束无限循环</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 第1步 执行: x = b(0) =&gt; x = 0</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 第2步 执行: y = a(0) =&gt; y = 0</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 第3步 执行: a = 1</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 第4步 执行: b = 1</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (x <span style=color:#f92672>==</span> 0 <span style=color:#f92672>&amp;&amp;</span> y <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;发生指令重排序...&#34;</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 重置4个测试属性，然后再重新开启下一轮的测试</span>
</span></span><span style=display:flex><span>            x <span style=color:#f92672>=</span> y <span style=color:#f92672>=</span> a <span style=color:#f92672>=</span> b <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=3-volatile线程不安全>3. Volatile线程不安全</h3><blockquote><p>心法: volatile无法保证原子性</p></blockquote><ul><li>volatile能保证可见性，和有序性，但无法保证原子性:<ul><li>若线程1和线程2在进行read/load操作中，发现主内存中的age值都是5，则都会加载这个age值。</li><li>T1线程修改age为6，并write到主存，此时主存中的age值为6。</li><li>T2线程修改age为7，并write到主存，此时主存中的age值为7。</li><li>出现并发问题。</li></ul></li></ul><blockquote><p>武技: 测试volatile关键字是否可以保证原子性</p></blockquote><p><code>memory.VolatileAtomTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/**@author lsx*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>VolatileAtomTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 共享资源 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>int</span> num <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testAtom</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 创建两个线程，同时对num进行自增操作，各自10W次</span>
</span></span><span style=display:flex><span>        Thread t1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 10000; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                num<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Thread t2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 10000; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                num<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 启动两个线程并插队执行</span>
</span></span><span style=display:flex><span>        t1.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        t2.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        t1.<span style=color:#a6e22e>join</span>();
</span></span><span style=display:flex><span>        t2.<span style=color:#a6e22e>join</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 结果为20W，证明线程安全，小于20W，证明线程不安全</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(num);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=e03-处理器高速缓存行>E03. 处理器高速缓存行</h2><blockquote><p>心法: CPU高速缓存行</p></blockquote><ul><li>CPU在读取主存数据时会将目标值及其相邻的64个字节数据（称为一个高速缓存行）一起读取和回写:<ul><li>灵活使用缓存行可以提高程序效率。</li></ul></li><li>比如主存中数据 <code>a</code> 和数据 <code>volatile b</code> 在一个缓存行中:<ul><li>每次A线程对 <code>volatile b</code> 操作都难免携带着 <code>a</code> 一起在缓存和主存中传输以保持缓存一致性。</li><li>若此时恰好B线程在不断读取 <code>a</code>，则每次都被通知需要去主存中读取，效率变低。</li><li>此时建议将 <code>a</code> 和 <code>volatile b</code> 人为分开在不同的缓存行以提升两个线程的操作效率。</li></ul></li></ul><blockquote><p>武技: 测试CPU高速缓存行效果</p></blockquote><p><code>memory.CacheLineTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CacheLineTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 本类用于测试高速缓存行CacheLine */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CacheLineDemo</span> {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#75715e>/**在x属性的左侧设置 7 * 8 = 56 个字节的变量*/</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>long</span> p01, p02, p03, p04, p05, p06, p07;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>long</span> x <span style=color:#f92672>=</span> 0L;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>/**在x属性的右侧设置 7 * 8 = 56 个字节的变量*/</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>long</span> p09, p10, p11, p12, p13, p14, p15;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** static变量保证共享唯一且先行 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> CacheLineDemo<span style=color:#f92672>[]</span> cacheLineDemos;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将两个测试元素放入数组是为了保证在内存中相邻</span>
</span></span><span style=display:flex><span>        cacheLineDemos <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CacheLineDemo<span style=color:#f92672>[</span>2<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        cacheLineDemos<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CacheLineDemo();
</span></span><span style=display:flex><span>        cacheLineDemos<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CacheLineDemo();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testCacheLine</span>() {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 创建子线程A，修改3亿次demos[0]的x属性，计算耗时  </span>
</span></span><span style=display:flex><span>		Thread t01 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {  
</span></span><span style=display:flex><span>		    <span style=color:#66d9ef>long</span> start <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>currentTimeMillis</span>();  
</span></span><span style=display:flex><span>		    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>long</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 3_0000_0000L; i<span style=color:#f92672>++</span>) {  
</span></span><span style=display:flex><span>		        cacheLineDemos<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>.<span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> i;  
</span></span><span style=display:flex><span>		    }  
</span></span><span style=display:flex><span>		    <span style=color:#66d9ef>long</span> end <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>currentTimeMillis</span>();  
</span></span><span style=display:flex><span>		    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;线程A耗时: &#34;</span> <span style=color:#f92672>+</span> (end <span style=color:#f92672>-</span> start));  
</span></span><span style=display:flex><span>		}, <span style=color:#e6db74>&#34;A&#34;</span>);  
</span></span><span style=display:flex><span>		  
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 创建子线程B，修改3亿次demos[1]的x属性，计算耗时  </span>
</span></span><span style=display:flex><span>		Thread t02 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {  
</span></span><span style=display:flex><span>		    <span style=color:#66d9ef>long</span> start <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>currentTimeMillis</span>();  
</span></span><span style=display:flex><span>		    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>long</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 3_0000_0000L; i<span style=color:#f92672>++</span>) {  
</span></span><span style=display:flex><span>		        cacheLineDemos<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>.<span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> i;  
</span></span><span style=display:flex><span>		    }  
</span></span><span style=display:flex><span>		    <span style=color:#66d9ef>long</span> end <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>currentTimeMillis</span>();  
</span></span><span style=display:flex><span>		    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;线程B耗时: &#34;</span> <span style=color:#f92672>+</span> (end <span style=color:#f92672>-</span> start));  
</span></span><span style=display:flex><span>		}, <span style=color:#e6db74>&#34;B&#34;</span>);  
</span></span><span style=display:flex><span>		
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 启动两个线程并插队执行</span>
</span></span><span style=display:flex><span>		t01.<span style=color:#a6e22e>start</span>();  
</span></span><span style=display:flex><span>		t02.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>		t01.<span style=color:#a6e22e>join</span>();  
</span></span><span style=display:flex><span>		t02.<span style=color:#a6e22e>join</span>();  
</span></span><span style=display:flex><span>		  
</span></span><span style=display:flex><span>		System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;主线程结束&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=s03-多线程安全方案>S03. 多线程安全方案</h1><blockquote><p>心法: 何为线程不安全</p></blockquote><ul><li>当多线程并发访问同一个资源时容易得到错误结果，即线程不安全。</li></ul><blockquote><p>心法: 线程安全方案</p></blockquote><table><thead><tr><th>线程安全方案</th><th>描述</th></tr></thead><tbody><tr><td>加锁</td><td>尽量对共享资源使用同步的操作，如代码加锁等加锁是一种比较耗性能的线程安全方案，所以记住加锁的三条原则：1. 能不加锁就不加锁2. 加锁粒度尽量小3. 加锁数量尽量少</td></tr><tr><td>使用原子类</td><td>尽量对共享资源使用原子性的操作，如使用JDK提供的原子类等</td></tr><tr><td>使用私有资源</td><td>尽量少用共享资源，多用线程私有资源，如使用ThreadLocal等</td></tr></tbody></table><h2 id=e01-线程同步与异步>E01. 线程同步与异步</h2><blockquote><p>心法: 多线程的同步操作和异步操作</p></blockquote><ul><li>同步指多个线程轮流做同一件事，异步指多个线程自己做自己的事。</li><li>异步互不干扰，线程利用率高，但容易因争抢资源而导致数据不安全。</li><li>同步数据安全，不会争抢资源，但效率相对而言会低一些。</li></ul><blockquote><p>武技: 开发多线程售票系统 - 异步版本</p></blockquote><p><code>sync.SellTicketAsyncTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SellTicketAsyncTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 模拟售票厅售票程序 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Ticket</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 票号，多线程共享资源 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> ticketNo;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 每隔1秒钟卖一张票</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>                TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(1L);
</span></span><span style=display:flex><span>                sellTicket();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 卖票方法 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sellTicket</span>() {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%s卖了%d号的票\n&#34;</span>, Thread.<span style=color:#a6e22e>currentThread</span>(), <span style=color:#f92672>++</span>ticketNo);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testSellTicket</span>() {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建线程类</span>
</span></span><span style=display:flex><span>        Runnable runnable <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Ticket();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建两个线程</span>
</span></span><span style=display:flex><span>        Thread t01 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(runnable, <span style=color:#e6db74>&#34;江南售票厅&#34;</span>);
</span></span><span style=display:flex><span>        Thread t02 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(runnable, <span style=color:#e6db74>&#34;江北售票厅&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 启动两个线程并插队执行</span>
</span></span><span style=display:flex><span>        t01.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        t02.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        t01.<span style=color:#a6e22e>join</span>();
</span></span><span style=display:flex><span>        t02.<span style=color:#a6e22e>join</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;主线程结束&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=e02-synchronized锁>E02. synchronized锁</h2><blockquote><p>心法: synchronized关键字</p></blockquote><ul><li>synchronized用于隔离代码，可以保证可见性和原子性，但无法禁止指令重排。</li><li>synchronized底层仅支持非公平锁：<ul><li>非公平锁: 新来的线程不进等待队列，直接进入就绪状态，直接有机会争抢CPU资源。</li><li>公平锁: 新来的线程先入等待队列进行排队，等待线程调度器的调度。</li></ul></li><li>synchronized在字节码指令级:<ul><li>使用 <code>monitorenter</code> 获取锁并进入隔离区。</li><li>使用 <code>monitorexit</code> 释放锁并离开隔离区。</li></ul></li><li>synchronized可以保证可见性：<ul><li>当一个线程进入同步块时，会清空工作内存中的共享变量，并从主存中重新读取最新的共享变量值。</li><li>当一个线程退出同步块时，会强制将工作内存中的共享变量刷新到主存。</li><li>这种机制确保了多个线程在操作共享变量的时候，能够看到彼此的更新。</li></ul></li></ul><h3 id=1-同步锁添加方式>1. 同步锁添加方式</h3><blockquote><p>心法: synchronized同步</p></blockquote><ul><li>单独使用 <code>synchronized( 锁类型 ){ 同步代码 }</code> 可以对部分代码加锁隔离，粒度小:<ul><li>除 <code>String/Integer/Long</code> 外，都可以作为锁实例的类型。</li><li>锁实例建议使用 <code>final</code> 修饰，因为一旦运行中途锁实例被改变了，同步效果会立即消失。</li><li>多个线程必须申请同一把锁，即锁实例相同时才会发生同步现象。</li></ul></li><li>在方法签名中使用 <code>synchronized</code> 修饰可以对整个方法加锁隔离，粒度大，不推荐。</li></ul><blockquote><p>武技: 开发多线程售票系统 - 同步版本</p></blockquote><p><code>sync.SellTicketSyncTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SellTicketSyncTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 模拟售票厅售票程序 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Ticket</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 票号，多线程共享资源 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> ticketNo;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 锁实例 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Object obj <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 每隔1秒钟卖一张票</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>                TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(1L);
</span></span><span style=display:flex><span>                sellTicket();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#75715e>/*synchronized*/</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sellTicket</span>() {
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 使用synchronized局部锁，形成同步代码块，锁住共享资源代码</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>synchronized</span> (obj) {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%s卖了%d号的票\n&#34;</span>, Thread.<span style=color:#a6e22e>currentThread</span>(), <span style=color:#f92672>++</span>ticketNo);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testSellTicket</span>() {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建线程类</span>
</span></span><span style=display:flex><span>        Runnable runnable <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Ticket();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建两个线程</span>
</span></span><span style=display:flex><span>        Thread t01 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(runnable, <span style=color:#e6db74>&#34;江南售票厅&#34;</span>);
</span></span><span style=display:flex><span>        Thread t02 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(runnable, <span style=color:#e6db74>&#34;江北售票厅&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 启动两个线程并插队执行</span>
</span></span><span style=display:flex><span>        t01.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        t02.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        t01.<span style=color:#a6e22e>join</span>();
</span></span><span style=display:flex><span>        t02.<span style=color:#a6e22e>join</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;主线程结束&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-同步锁添加流程>2. 同步锁添加流程</h3><blockquote><p>心法: synchronized获取锁和释放锁的底层流程</p></blockquote><ol><li>申请: 线程A申请访问同步代码，观察锁实例的MarkWord，并未发现锁信息，表示该锁未被其他线程占有。</li><li>准备: 线程A在自己的线程栈中生成一个LockRecord，并备份锁实例的MarkWord内容。</li><li>占有: 线程A清空锁实例的MarkWord，并记录锁信息和自己的线程ID，表示已经占有这把锁。</li><li>执行: 线程A进入隔离区并开始执行自己的线程体任务。</li><li>并发: 线程B申请访问同步代码，观察锁实例对象头的MarkWord，发现了锁信息，于是只能在门口自旋等待。</li><li>释放: 线程A执行完毕，将LockRecord中备份的锁实例原来的MarkWord内容进行还原，并离开隔离区。</li><li>重复: 线程B重新申请访问同步代码，发现MarkWord信息中没有锁信息，重复上述流程。</li></ol><p><img src=/%E7%AC%AC1%E9%98%B6%E6%AE%B5-BASIC/JB1-7-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image/44c80042782b11d7a8a49195e83b6c90.png alt=synchronized获取锁与释放锁流程></p><h3 id=3-同步锁具体类型>3. 同步锁具体类型</h3><blockquote><p>心法: 当使用synchronized修饰方法时，具体使用的是什么锁型？</p></blockquote><ul><li>使用 <code>synchronized</code> 修饰成员方法时的锁类型是 <code>this</code> 锁。</li><li>使用 <code>synchronized</code> 修饰静态方法时的锁类型是 <code>所在类.class</code> 锁。</li></ul><blockquote><p>武技: synchronized锁实例的类型</p></blockquote><p><code>sync.SynchronizedLockTypeTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SynchronizedLockTypeTest</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MethodLockTypeDemo</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#75715e>/*static*/</span> <span style=color:#66d9ef>int</span> ticketNo;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 模拟每隔1s卖一次票</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                TimeUnit.<span style=color:#a6e22e>MILLISECONDS</span>.<span style=color:#a6e22e>sleep</span>(100L);
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 若子线程A进入，调用同步的sellTicket()方法，若子线程B进入，使用同步代码块</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>().<span style=color:#a6e22e>equals</span>(<span style=color:#e6db74>&#34;子线程A&#34;</span>)) {
</span></span><span style=display:flex><span>                    sellTicket();
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>synchronized</span> (<span style=color:#66d9ef>this</span>) {
</span></span><span style=display:flex><span>                        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%s卖了%d号的票\n&#34;</span>, Thread.<span style=color:#a6e22e>currentThread</span>(), <span style=color:#f92672>++</span>ticketNo);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#75715e>/*static*/</span> <span style=color:#66d9ef>synchronized</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sellTicket</span>() {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%s卖了%d号的票\n&#34;</span>, Thread.<span style=color:#a6e22e>currentThread</span>(), <span style=color:#f92672>++</span>ticketNo);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@SneakyThrows</span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@Test</span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testMethodLockType</span>() {  
</span></span><span style=display:flex><span>	  
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// 创建线程类  </span>
</span></span><span style=display:flex><span>	    Runnable runnable <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MethodLockTypeDemo();  
</span></span><span style=display:flex><span>	  
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// 创建两个线程  </span>
</span></span><span style=display:flex><span>	    Thread t01 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(runnable, <span style=color:#e6db74>&#34;子线程A&#34;</span>);  
</span></span><span style=display:flex><span>	    Thread t02 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(runnable, <span style=color:#e6db74>&#34;子线程B&#34;</span>);  
</span></span><span style=display:flex><span>	  
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// 启动两个线程并插队执行  </span>
</span></span><span style=display:flex><span>	    t01.<span style=color:#a6e22e>start</span>();  
</span></span><span style=display:flex><span>	    t02.<span style=color:#a6e22e>start</span>();  
</span></span><span style=display:flex><span>	    t01.<span style=color:#a6e22e>join</span>();  
</span></span><span style=display:flex><span>	    t02.<span style=color:#a6e22e>join</span>();  
</span></span><span style=display:flex><span>	  
</span></span><span style=display:flex><span>	    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;主线程结束&#34;</span>);  
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=4-同步锁可重入性>4. 同步锁可重入性</h3><blockquote><p>心法: synchronized重入性</p></blockquote><ul><li>synchronized具有可重入性:<ul><li>即同一个线程，在释放A锁之前，若需要再次A获取锁，则直接通过，视为一次重入。</li></ul></li><li>非OS锁通过空的LockRecord数量来记录重入次数:<ul><li>每重入1次，都会额外入栈1个空LockRecord。</li><li>每释放1次，都会栈顶弹出1个空LockRecord。</li></ul></li><li>OS锁的重入次数不通过空LockRecord记录，而是通过底层的一个本地变量来记录。</li></ul><blockquote><p>武技: 测试synchronized是否具有重入性</p></blockquote><p><code>sync.SynchronizedReentryTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SynchronizedReentryTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 本类用于测试synchronized的重入性 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ReentryLock</span> {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 递归方法 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>method</span>(<span style=color:#66d9ef>int</span> num) {
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 发现是同一个线程，允许重入，无需重新获取锁，若不允许重入，则会阻塞在这里</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>synchronized</span> (<span style=color:#66d9ef>this</span>) {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;num: &#34;</span> <span style=color:#f92672>+</span> num);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (num <span style=color:#f92672>&lt;=</span> 1) {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 递归出口</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> 1;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 在线程释放锁之前递归调用method方法</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> method(<span style=color:#f92672>--</span>num);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 测试synchronized锁是否具有重入性 */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testSynchronizedReentry</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> ReentryLock().<span style=color:#a6e22e>method</span>(5);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=5-同步锁死锁现象>5. 同步锁死锁现象</h3><blockquote><p>心法: synchronized死锁</p></blockquote><ul><li>死锁是指多个进程因竞争资源而造成的一种僵局，若无外力作用，这些进程都将无法向前推进。</li></ul><blockquote><p>心法: 死锁的必要条件</p></blockquote><table><thead><tr><th>死锁的必要条件</th><th>描述</th></tr></thead><tbody><tr><td>线程互斥</td><td>线程争抢的是一个共享资源，即资源被加了锁</td></tr><tr><td>保持不放</td><td>线程即使被阻塞，也不会主动放弃资源</td></tr><tr><td>不可剥夺</td><td>线程即使被阻塞，其已经获得的资源不会被剥夺</td></tr><tr><td>循环等待</td><td>线程A持有B的锁不释放，与此同时，线程B也持有A的锁不释放</td></tr></tbody></table><blockquote><p>心法: 如何规避死锁</p></blockquote><ul><li>提前根据锁实例的HashCode大小设置上锁规则，比如值大的先上锁，值小的后上锁。</li><li>适用带超时时间的锁，以避免死锁。</li></ul><blockquote><p>武技: synchronized死锁</p></blockquote><p><code>sync.SynchronizedDeadLockTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> thread.sync;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SynchronizedDeadLockTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 测试synchronized死锁现象 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DeadLock</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Object objA <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Object objB <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>().<span style=color:#a6e22e>equals</span>(<span style=color:#e6db74>&#34;子线程A&#34;</span>)) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>synchronized</span> (objA) {
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;if: objA&#34;</span>);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>synchronized</span> (objB) {
</span></span><span style=display:flex><span>                        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;if: objB&#34;</span>);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>synchronized</span> (objB) {
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;else: objB&#34;</span>);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>synchronized</span> (objA) {
</span></span><span style=display:flex><span>                        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;else: objA&#34;</span>);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testDeadLock</span>() {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建线程类</span>
</span></span><span style=display:flex><span>        Runnable runnable <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> DeadLock();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建两个线程</span>
</span></span><span style=display:flex><span>        Thread t01 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(runnable, <span style=color:#e6db74>&#34;子线程A&#34;</span>);
</span></span><span style=display:flex><span>        Thread t02 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(runnable, <span style=color:#e6db74>&#34;子线程B&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 启动两个线程并插队运行</span>
</span></span><span style=display:flex><span>        t01.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        t02.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        t01.<span style=color:#a6e22e>join</span>();
</span></span><span style=display:flex><span>        t02.<span style=color:#a6e22e>join</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;主线程结束&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=6-同步锁异常释放>6. 同步锁异常释放</h3><blockquote><p>心法: synchronized异常会导致释放锁</p></blockquote><ul><li>隔离区中的代码若正常执行完毕或爆发异常时，都会自动释放锁，此时允许其他线程进入隔离区。</li></ul><blockquote><p>武技: synchronized异常会导致释放锁</p></blockquote><p><code>sync.SynchronizedReleaseTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SynchronizedReleaseTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 本类用于测试当synchronized隔离区中的代码爆发异常时是否可以释放锁 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ExceptionDemo</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> count;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>synchronized</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;: &#34;</span> <span style=color:#f92672>+</span> count);
</span></span><span style=display:flex><span>                TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(1L);
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 当某线程执行4次输出后，立刻抛出异常，此时释放锁，其他线程可以进来继续操作</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (count<span style=color:#f92672>++</span> <span style=color:#f92672>==</span> 3) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> ArithmeticException();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testException</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 创建线程类  </span>
</span></span><span style=display:flex><span>		ExceptionDemo exceptionDemo <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ExceptionDemo();  
</span></span><span style=display:flex><span>		  
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 创建并启动两个子线程  </span>
</span></span><span style=display:flex><span>		Thread t01 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(exceptionDemo, <span style=color:#e6db74>&#34;子线程A&#34;</span>);  
</span></span><span style=display:flex><span>		Thread t02 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(exceptionDemo, <span style=color:#e6db74>&#34;子线程B&#34;</span>);  
</span></span><span style=display:flex><span>		  
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 启动两个子线程并插队运行  </span>
</span></span><span style=display:flex><span>		t01.<span style=color:#a6e22e>start</span>();  
</span></span><span style=display:flex><span>		t02.<span style=color:#a6e22e>start</span>();  
</span></span><span style=display:flex><span>		t01.<span style=color:#a6e22e>join</span>();  
</span></span><span style=display:flex><span>		t02.<span style=color:#a6e22e>join</span>();  
</span></span><span style=display:flex><span>		  
</span></span><span style=display:flex><span>		System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;主线程结束&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=7-同步锁升级流程>7. 同步锁升级流程</h3><blockquote><p>心法: 锁类型的信息</p></blockquote><ul><li>锁实例的MarkWord信息中的后两个，或后三个bit位中记录着锁类型的信息。</li></ul><table><thead><tr><th>MarkWord组成</th><th>单词</th><th>描述</th></tr></thead><tbody><tr><td><code>实例信息 + 001</code></td><td><code>non-biase</code></td><td>普通实例，没有任何锁信息</td></tr><tr><td><code>null + 101</code></td><td><code>biaseable</code></td><td>匿名偏向锁</td></tr><tr><td><code>线程ID + 101</code></td><td><code>biased</code></td><td>偏向锁</td></tr><tr><td><code>线程LR + 00</code></td><td><code>thin-lock</code></td><td>轻锁（轻量级锁），即自旋锁</td></tr><tr><td><code>线程ID + 10</code></td><td><code>fat-lock</code></td><td>重锁（重量级锁），即OS锁</td></tr></tbody></table><blockquote><p>心法: synchronized锁升级</p></blockquote><ul><li>即使在多线程环境下，某些共享资源也有可能极少发生线程争抢，即大多数的情况下都是只有一个线程在访问这个共享资源。</li></ul><p><img src=/%E7%AC%AC1%E9%98%B6%E6%AE%B5-BASIC/JB1-7-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image/%E9%94%81%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B.png alt>
tips: JDK8可以通过 <code>-XX:BiasdLockingStartupDelay=0</code> 运行参数来调整匿名偏向锁的启动延迟时间。
tips: JDK11可以通过 <code>-XX:-UseBiasedLocking</code> 运行参数来禁用偏向锁功能，默认打开。</p><blockquote><p>武技: 在子项目中添加jol依赖</p></blockquote><ol><li>在 <code>java-book</code> 父项目中添加全局属性:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#75715e>&lt;!--jol-core--&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>&lt;groupId&gt;</span>org.openjdk.jol<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>&lt;artifactId&gt;</span>jol-core<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>&lt;version&gt;</span>0.16<span style=color:#f92672>&lt;/version&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span></code></pre></div><h3 id=8-偏向锁基本概念>8. 偏向锁基本概念</h3><blockquote><p>心法: synchronized偏向锁</p></blockquote><ul><li>偏向锁偏向首次获取锁的线程，是一种最轻量级的加锁模式，但严格意义上来讲，不算是锁。</li></ul><blockquote><p>心法: JDK11偏向锁升级流程</p></blockquote><p><img src=/%E7%AC%AC1%E9%98%B6%E6%AE%B5-BASIC/JB1-7-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image/JDK11%E9%94%81%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B.png alt></p><blockquote><p>武技: 测试偏向锁升级流程</p></blockquote><p><code>sync.BiasedUpgradeTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BiasedUpgradeTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 创建一个锁实例 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Object obj <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 封装jol的layout对象 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> ClassLayout layout <span style=color:#f92672>=</span> ClassLayout.<span style=color:#a6e22e>parseInstance</span>(obj);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 测试锁实例的初始状态 */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testBiased</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 若开启了偏向锁功能，则输出 `biasable`: 匿名偏向锁 [null + 101]</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 若禁用了偏向锁功能，则输出 `non-biasable`: 无锁 [实例信息 + 001]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;初始值: \n&#34;</span> <span style=color:#f92672>+</span> layout.<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 测试: 匿名偏向锁 -&gt; 偏向锁 */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testBiasableToBiased</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// biasable: 匿名偏向锁 [null + 101]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;初始值: \n&#34;</span> <span style=color:#f92672>+</span> layout.<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 持有锁: 主线程持有了obj锁</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>synchronized</span> (obj) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// biased: 偏向锁 [主线程ID + 101]</span>
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;持有锁: \n&#34;</span> <span style=color:#f92672>+</span> layout.<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 释放锁: 主线程释放锁之后，obj锁的MarkWord中仍记录着对主线程的偏向信息</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;释放锁: \n&#34;</span> <span style=color:#f92672>+</span> layout.<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=9-自旋锁基本概念>9. 自旋锁基本概念</h3><blockquote><p>心法: synchronized轻量级锁 - 自旋锁</p></blockquote><ul><li>自旋可以理解为在隔离代码块的"门口"，建立一个死循环不停地尝试获取锁的过程。</li><li>自旋锁会消耗CPU资源，所以不适用于同步代码的执行时间长，或并发访问量高的情况。</li></ul><blockquote><p>武技: 测试自旋锁升级流程</p></blockquote><p><code>sync.ThinLockUpgradeTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ThinLockUpgradeTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 创建一个锁实例 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Object obj <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 封装jol的layout对象 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> ClassLayout layout <span style=color:#f92672>=</span> ClassLayout.<span style=color:#a6e22e>parseInstance</span>(obj);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 偏向锁 -&gt; 轻锁 */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testBiasedToThinLock</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// biased: 偏向锁 [主线程ID + 101]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>synchronized</span> (obj) {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;初始值: \n&#34;</span> <span style=color:#f92672>+</span> layout.<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 开启一个子线程，使其与主线程发生轻度竞争</span>
</span></span><span style=display:flex><span>        Thread t01 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>synchronized</span> (obj) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// thin lock: 轻锁 [线程LR记录 + 00]</span>
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;持有锁: \n&#34;</span> <span style=color:#f92672>+</span> layout.<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 启动子线程并插队执行</span>
</span></span><span style=display:flex><span>        t01.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        t01.<span style=color:#a6e22e>join</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 释放锁: 主线程释放锁之后，obj锁恢复到初始的无锁状态 [实例信息 + 001]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;释放锁: \n&#34;</span> <span style=color:#f92672>+</span> layout.<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 无锁 -&gt; 轻锁 */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testNonBiasedToThinLock</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// non-biasable: 无锁 [实例信息 + 001]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;初始值: \n&#34;</span> <span style=color:#f92672>+</span> layout.<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 持有锁: 主线程持有了obj锁</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>synchronized</span> (obj) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// thin lock: 轻锁 [线程LR记录 + 00]</span>
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;持有锁: \n&#34;</span> <span style=color:#f92672>+</span> layout.<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 释放锁: 主线程释放锁之后，obj锁恢复到初始的无锁状态 [实例信息 + 001]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;释放锁: \n&#34;</span> <span style=color:#f92672>+</span> layout.<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=10-系统锁基本概念>10. 系统锁基本概念</h3><blockquote><p>心法: synchronized重量级锁 - 系统锁</p></blockquote><ul><li>系统OS锁需要向内核空间申请并得到返回，效率比自旋锁低。</li><li>系统OS锁底层使用等待队列来存放和调度那些没能获取锁的线程，不消耗CPU资源:<ul><li>所以OS锁更适用于同步代码的执行时间长，或并发访问量高的情况。</li></ul></li></ul><blockquote><p>心法: 如何升级到重量级锁 - 系统锁</p></blockquote><ul><li>当某个线程自旋次数超过10次，或所有自旋线程个数总和超过CPU核数的一半时，自旋锁将升级为重量级锁。</li><li>JDK6之前可以使用 <code>-XX:PreBlockSpin</code> 调整自旋最大次数。</li><li>JDK6之后JVM引入了自适应自旋的概念，即JVM自动管理自旋最大次数，无需我们操心。</li></ul><blockquote><p>武技: 测试系统锁升级流程</p></blockquote><p><code>sync.FatLockUpgradeTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FatLockUpgradeTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 创建一个锁实例 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Object obj <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 封装jol的layout对象 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> ClassLayout layout <span style=color:#f92672>=</span> ClassLayout.<span style=color:#a6e22e>parseInstance</span>(obj);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 偏向锁 -&gt; 重锁 */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testBiasedToFatLock</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// biased: 偏向锁 [主线程ID + 101]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>synchronized</span> (obj) {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;初始值: \n&#34;</span> <span style=color:#f92672>+</span> layout.<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 开启10个子线程，使其与主线程发生重度竞争</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 10; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>synchronized</span> (obj) {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// fat lock: 重量级锁 [10 + 线程ID]</span>
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;持有锁: \n&#34;</span> <span style=color:#f92672>+</span> layout.<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 让全部子线程先执行完毕</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(10L);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 释放锁: 主线程释放锁之后，obj锁恢复到初始的无锁状态 [实例信息 + 001]</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;释放锁: \n&#34;</span> <span style=color:#f92672>+</span> layout.<span style=color:#a6e22e>toPrintable</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=s04-cas概念入门>S04. CAS概念入门</h1><h2 id=e01-比较与交换算法>E01. 比较与交换算法</h2><blockquote><p>心法: CAS全称 <code>Compare And Swap</code></p></blockquote><ul><li>CAS操作是一条汇编指令 <code>lock cmpxchg</code>，是一种乐观锁。</li><li>CAS优势：<ul><li>CAS系统原语（即一条CPU原子指令，执行过程中不允许被中断），可以保证原子性。</li><li>CAS本质上没有使用锁，所以在线程安全的前提下提升了效率，且不会出现死锁问题。</li></ul></li><li>CAS实现：<ul><li>自定义的CAS实现要注意，对共享变量添加 <code>volatile</code> 修饰，且CAS整个过程是原子性的。</li><li><code>j.u.c.atomic</code> 包中提供了大量原子类，利用CAS自旋锁成为保证线程安全的第二方案。</li></ul></li></ul><h3 id=1-悲观锁与乐观锁>1. 悲观锁与乐观锁</h3><blockquote><p>心法: 悲观锁与乐观锁</p></blockquote><table><thead><tr><th></th><th>悲观锁</th><th>乐观锁</th></tr></thead><tbody><tr><td>描述</td><td>一定有人和我抢，我先上锁，然后做任务，走的时候再解锁</td><td>可能没人和我抢，我先看看有没有人和我抢，没人抢我就做任务，有人抢我等一会在来</td></tr><tr><td>并发效率</td><td>需要频繁加锁解锁，高并发时效率低</td><td>不需要加锁解锁等操作，高并发时效率高</td></tr><tr><td>实现难度</td><td>最少一个关键字即可搞定，开发简单</td><td>需要考版本控制，超时重试等问题，开发难度高</td></tr><tr><td>实现方案</td><td><code>synchroinzed</code> 锁</td><td><code>CAS</code>，如JUC原子类等</td></tr><tr><td>适用场景</td><td>并发量大，写多读少</td><td>并发量小，读多写少</td></tr></tbody></table><h3 id=2-cas操作流程>2. CAS操作流程</h3><blockquote><p>心法: CAS操作流程</p></blockquote><ul><li>假设线程A和线程B，都要执行 <code>CAS(num, 3, 4)</code> 操作，那么：
![[excalidraw/CAS操作流程#^group=P-nWJgUQfXBwq37ZkCj4s|9999]]</li></ul><h3 id=3-aba问题描述>3. ABA问题描述</h3><blockquote><p>心法: 即使最终获取到的确实是最初的期望值，也无法保证该值没有被其他线程修改过</p></blockquote><ul><li>对于基本类型的共享资源：<ul><li>ABA问题影响不大，无论中间过程中经历了什么，只要最后是期望值即可。</li></ul></li><li>对于引用类型的共享资源：<ul><li>发生ABA问题，则无法保证该引用实例中的某些属性值没有被修改过。</li></ul></li></ul><h3 id=4-aba解决方案>4. ABA解决方案</h3><blockquote><p>心法: 添加版本戳，随修改而递增版本戳，当线程在判断期望值时，连同版本戳一同检查</p></blockquote><ul><li><code>j.u.c.AtomicMarkableReference</code>：带boolean型版本戳的引用型原子类，可解决ABA问题。</li><li><code>j.u.c.AtomicStampedReference</code>：带int型版本戳的引用型原子类，可解决ABA问题。</li></ul><h3 id=5-cas原子类测试>5. CAS原子类测试</h3><blockquote><p>武技: 测试Atomic原子类是否可以保证原子性</p></blockquote><p><code>atomic.AtomicTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AtomicTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 普通的Integer变量，用于测试自增是否线程安全 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Integer num <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 原子的Integer变量，用于测试自增是否线程安全 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> AtomicInteger atomicNum <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AtomicInteger(0);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testAtomicOperate</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 开启100个线程</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 100; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 每个线程执行100次普通num自增和原子num自增</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> 0; j <span style=color:#f92672>&lt;</span> 100; j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                    num<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                    atomicNum.<span style=color:#a6e22e>incrementAndGet</span>();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 防止主线程在子线程执行自增操作完毕之前输出</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(10L);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 普通num自增：最后可能会丢失一批数据，最终值达不到1W。</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 原子num自增：最后不会丢失任何数据，最终值一定为1W。</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;num: &#34;</span> <span style=color:#f92672>+</span> num);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;atomicNum: &#34;</span> <span style=color:#f92672>+</span> atomicNum);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=e02-基础原子类>E02. 基础原子类</h2><blockquote><p>心法: 基础原子类</p></blockquote><table><thead><tr><th>原子类</th><th>描述</th></tr></thead><tbody><tr><td><code>AtomicInteger</code></td><td>支持对某个Integer型属性的原子操作</td></tr><tr><td><code>AtomicLong</code></td><td>支持对某个Long型属性的原子操作</td></tr><tr><td><code>AtomicBoolean</code></td><td>支持对某个Boolean型属性的原子操作</td></tr></tbody></table><blockquote><p>武技: 测试基础原子类相关API方法</p></blockquote><h3 id=1-atomicinteger>1. AtomicInteger</h3><p><code>atomic.AtomicIntegerTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AtomicIntegerTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> AtomicInteger num <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AtomicInteger(0);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testApi</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取num对应的int型值，相当于num.intValue()</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;num: &#34;</span> <span style=color:#f92672>+</span> num.<span style=color:#a6e22e>get</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 对num加1并返回</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;++num: &#34;</span> <span style=color:#f92672>+</span> num.<span style=color:#a6e22e>incrementAndGet</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 对num减1并返回</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;--num: &#34;</span> <span style=color:#f92672>+</span> num.<span style=color:#a6e22e>decrementAndGet</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 对num加6并返回</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;num+=6: &#34;</span> <span style=color:#f92672>+</span> num.<span style=color:#a6e22e>addAndGet</span>(6));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 自定义计算：先计算，再返回</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// p1为Lambda表达式中temp的初始值</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// p2是计算过程，其中curVal的值为当前的num值，temp是p1的值</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;accumulate: &#34;</span> <span style=color:#f92672>+</span> num.<span style=color:#a6e22e>accumulateAndGet</span>(
</span></span><span style=display:flex><span>                5, (curVal, temp) <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;curVal: %s temp: %s\n&#34;</span>, curVal, temp);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> curVal <span style=color:#f92672>+</span> temp;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>        ));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 查看num最终的值</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;num: &#34;</span> <span style=color:#f92672>+</span> num.<span style=color:#a6e22e>get</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-atomiclong>2. AtomicLong</h3><p><code>atomic.AtomicLongTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AtomicLongTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> AtomicLong num <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AtomicLong(0L);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testApi</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取num对应的Long型值，相当于num.longValue()</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;num: &#34;</span> <span style=color:#f92672>+</span> num.<span style=color:#a6e22e>get</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 返回num后加1</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;num++: &#34;</span> <span style=color:#f92672>+</span> num.<span style=color:#a6e22e>getAndIncrement</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 返回num后减1</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;num--: &#34;</span> <span style=color:#f92672>+</span> num.<span style=color:#a6e22e>getAndDecrement</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 返回num后减6</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;num-=6: &#34;</span> <span style=color:#f92672>+</span> num.<span style=color:#a6e22e>getAndAdd</span>(<span style=color:#f92672>-</span>6));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 自定义计算：先计算，再返回</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// p1为Lambda表达式中temp的初始值</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// p2是计算过程，其中curVal的值为当前的num值，temp是p1的值</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;accumulate: &#34;</span> <span style=color:#f92672>+</span> num.<span style=color:#a6e22e>getAndAccumulate</span>(
</span></span><span style=display:flex><span>                5L, (curVal, temp) <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;curVal: %s temp: %s\n&#34;</span>, curVal, temp);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> curVal <span style=color:#f92672>+</span> temp;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>        ));
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 查看num最终的值</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;num: &#34;</span> <span style=color:#f92672>+</span> num);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=3-atomicboolean>3. AtomicBoolean</h3><p><code>atomic.AtomicBooleanTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AtomicBooleanTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> AtomicBoolean flag <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AtomicBoolean(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testApi</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取flag对应的boolean型值</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;flag: &#34;</span> <span style=color:#f92672>+</span> flag.<span style=color:#a6e22e>get</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 先将flag返回，然后再修改flag为true</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;flag=true: &#34;</span> <span style=color:#f92672>+</span> flag.<span style=color:#a6e22e>getAndSet</span>(<span style=color:#66d9ef>true</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 查看num最终的值</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;flag: &#34;</span> <span style=color:#f92672>+</span> flag.<span style=color:#a6e22e>get</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=e03-数组原子类>E03. 数组原子类</h2><blockquote><p>心法: 数组原子类</p></blockquote><table><thead><tr><th>原子类</th><th>描述</th></tr></thead><tbody><tr><td><code>AtomicIntegerArray</code></td><td>支持对某个Integer数组型属性的原子操作</td></tr><tr><td><code>AtomicLongArray</code></td><td>支持对某个Long数组型属性的原子操作</td></tr><tr><td><code>AtomicReferenceArray</code></td><td>支持对某个引用数组型属性的原子操作</td></tr></tbody></table><blockquote><p>武技: 测试数组原子类相关API方法</p></blockquote><h3 id=1-atomicintegerarray>1. AtomicIntegerArray</h3><p><code>atomic.AtomicIntegerArrayTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AtomicIntegerArrayTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 创建一个原子的Integer[]实例，初始值为{3, 2} */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> AtomicIntegerArray arr <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AtomicIntegerArray(<span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span>{3, 2});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testApi</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取arr[0]的值</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;arr[0]: &#34;</span> <span style=color:#f92672>+</span> arr.<span style=color:#a6e22e>get</span>(0));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 对arr[0]加1并返回</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;++(arr[0]): &#34;</span> <span style=color:#f92672>+</span> arr.<span style=color:#a6e22e>incrementAndGet</span>(0));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 对arr[0]减1并返回</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;--(arr[0]): &#34;</span> <span style=color:#f92672>+</span> arr.<span style=color:#a6e22e>decrementAndGet</span>(0));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 对arr[0]加6并返回</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;(arr[0])+=6: &#34;</span> <span style=color:#f92672>+</span> arr.<span style=color:#a6e22e>addAndGet</span>(0, 6));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 自定义计算：先计算，再返回</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// p1为数组角标</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// p1为Lambda表达式中temp的初始值</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// p2是计算过程，其中curVal的值为当前的num值，temp是p1的值</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;accumulate: &#34;</span> <span style=color:#f92672>+</span> arr.<span style=color:#a6e22e>accumulateAndGet</span>(
</span></span><span style=display:flex><span>                0, 5, (curVal, temp) <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;curVal: %s temp: %s\n&#34;</span>, curVal, temp);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> curVal <span style=color:#f92672>+</span> temp;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>        ));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 查看arr[0]最终的值</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;arr[0]: &#34;</span> <span style=color:#f92672>+</span> arr.<span style=color:#a6e22e>get</span>(0));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-atomiclongarray>2. AtomicLongArray</h3><p><code>atomic.AtomicLongArrayTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AtomicLongArrayTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 创建一个原子的Long[]实例，初始值为{3L, 2L} */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> AtomicLongArray arr <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AtomicLongArray(<span style=color:#66d9ef>new</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>[]</span>{3L, 2L});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testApi</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取arr[0]的值</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;arr[0]: &#34;</span> <span style=color:#f92672>+</span> arr.<span style=color:#a6e22e>get</span>(0));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 对arr[0]返回后加1</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;(arr[0])++: &#34;</span> <span style=color:#f92672>+</span> arr.<span style=color:#a6e22e>getAndIncrement</span>(0));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 对arr[0]返回后减1</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;(arr[0])--: &#34;</span> <span style=color:#f92672>+</span> arr.<span style=color:#a6e22e>getAndDecrement</span>(0));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 对arr[0]返回后加-6</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;(arr[0])-=6: &#34;</span> <span style=color:#f92672>+</span> arr.<span style=color:#a6e22e>getAndAdd</span>(0, <span style=color:#f92672>-</span>6));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 自定义计算：先计算，再返回</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// p1为数组角标</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// p1为Lambda表达式中temp的初始值</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// p2是计算过程，其中curVal的值为当前的num值，temp是p1的值</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;accumulate: &#34;</span> <span style=color:#f92672>+</span> arr.<span style=color:#a6e22e>getAndAccumulate</span>(
</span></span><span style=display:flex><span>                0, 5, (temp, curVal) <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;temp: %s b: %s\n&#34;</span>, temp, curVal);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> temp <span style=color:#f92672>+</span> curVal;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>        ));
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 查看arr[0]最终的值</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;arr[0]: &#34;</span> <span style=color:#f92672>+</span> arr.<span style=color:#a6e22e>get</span>(0));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=3-atomicreferencearray>3. AtomicReferenceArray</h3><p><code>atomic.AtomicReferenceArrayTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AtomicReferenceArrayTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 创建一个原子的 String[] 实例，初始值为 {&#34;jack&#34;, &#34;rose&#34;} */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> AtomicReferenceArray<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> arr
</span></span><span style=display:flex><span>            <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AtomicReferenceArray<span style=color:#f92672>&lt;&gt;</span>(<span style=color:#66d9ef>new</span> String<span style=color:#f92672>[]</span>{<span style=color:#e6db74>&#34;jack&#34;</span>, <span style=color:#e6db74>&#34;rose&#34;</span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testApi</span>() {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 返回arr[0]的值</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;arr[0]: &#34;</span> <span style=color:#f92672>+</span> arr.<span style=color:#a6e22e>get</span>(0));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 修改0号位的值，将其变为大写后返回</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;修改后: &#34;</span> <span style=color:#f92672>+</span> arr.<span style=color:#a6e22e>updateAndGet</span>(0, String::toUpperCase));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 查看arr[0]最终的值</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;arr[0]: &#34;</span> <span style=color:#f92672>+</span> arr.<span style=color:#a6e22e>get</span>(0));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=e04-属性原子类>E04. 属性原子类</h2><blockquote><p>心法: 属性原子类</p></blockquote><table><thead><tr><th>原子类</th><th>描述</th></tr></thead><tbody><tr><td><code>AtomicIntegerFieldUpdater</code></td><td>支持对某个类中，Integer型属性的原子操作</td></tr><tr><td><code>AtomicLongFieldUpdater</code></td><td>支持对某个类中，Long型属性的原子操作</td></tr><tr><td><code>AtomicReferenceFieldUpdater</code></td><td>支持对某个类中，引用型属性的原子操作</td></tr></tbody></table><blockquote><p>武技: 测试属性原子类相关API方法</p></blockquote><h3 id=1-atomicintegerfieldupdater>1. AtomicIntegerFieldUpdater</h3><p><code>atomic.AtomicIntegerFieldUpdaterTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AtomicIntegerFieldUpdaterTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 要求成员属性必须被volatile修饰，不能被 private/static/final 修饰 */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Data</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@AllArgsConstructor</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@NoArgsConstructor</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>implements</span> Serializable {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testApi</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建Student实例，并为成员属性赋予初始值</span>
</span></span><span style=display:flex><span>        Student student <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Student(58);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 使用AtomicIntegerFieldUpdater绑定Student类中的age属性</span>
</span></span><span style=display:flex><span>        AtomicIntegerFieldUpdater<span style=color:#f92672>&lt;</span>Student<span style=color:#f92672>&gt;</span> ageUpdater <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>                AtomicIntegerFieldUpdater.<span style=color:#a6e22e>newUpdater</span>(Student.<span style=color:#a6e22e>class</span>, <span style=color:#e6db74>&#34;age&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 对student中的age进行原子操作</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;age++: &#34;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                ageUpdater.<span style=color:#a6e22e>getAndIncrement</span>(student));
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;age--: &#34;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                ageUpdater.<span style=color:#a6e22e>getAndDecrement</span>(student));
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;先返回age的值，然后 age+=5: &#34;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                ageUpdater.<span style=color:#a6e22e>getAndAdd</span>(student, 5));
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;先返回age的值，然后 accumulate: &#34;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                ageUpdater.<span style=color:#a6e22e>getAndAccumulate</span>(student, 5, (curVal, temp) <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;curVal: %s temp: %s\n&#34;</span>, curVal, temp);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> curVal <span style=color:#f92672>+</span> temp;
</span></span><span style=display:flex><span>                }));
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;age的最终值: &#34;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>+</span> ageUpdater.<span style=color:#a6e22e>get</span>(student));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-atomiclongfieldupdater>2. AtomicLongFieldUpdater</h3><p><code>atomic.AtomicLongFieldUpdaterTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AtomicLongFieldUpdaterTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 要求成员属性必须被volatile修饰，不能被private/static/final修饰 */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Data</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@AllArgsConstructor</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@NoArgsConstructor</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>implements</span> Serializable {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>long</span> id;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testApi</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建Student实例，并为成员属性赋予初始值</span>
</span></span><span style=display:flex><span>        Student student <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Student(1L);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 使用AtomicLongFieldUpdater绑定Student类中的id属性</span>
</span></span><span style=display:flex><span>        AtomicLongFieldUpdater<span style=color:#f92672>&lt;</span>Student<span style=color:#f92672>&gt;</span> idUpdater <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>                AtomicLongFieldUpdater.<span style=color:#a6e22e>newUpdater</span>(Student.<span style=color:#a6e22e>class</span>, <span style=color:#e6db74>&#34;id&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 对student中的id进行原子操作</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;id: &#34;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                student.<span style=color:#a6e22e>getId</span>());
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;++id: &#34;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                idUpdater.<span style=color:#a6e22e>incrementAndGet</span>(student));
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;--id: &#34;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                idUpdater.<span style=color:#a6e22e>decrementAndGet</span>(student));
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;id+=5: &#34;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                idUpdater.<span style=color:#a6e22e>addAndGet</span>(student, 5));
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;accumulate: &#34;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                idUpdater.<span style=color:#a6e22e>accumulateAndGet</span>(student, 5, (curVal, temp) <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;curVal: %s temp: %s\n&#34;</span>, curVal, temp);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> curVal <span style=color:#f92672>+</span> temp;
</span></span><span style=display:flex><span>                }));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=3-atomicreferencefieldupdater>3. AtomicReferenceFieldUpdater</h3><p><code>atomic.AtomicReferenceFieldUpdaterTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AtomicReferenceFieldUpdaterTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 要求成员属性必须被volatile修饰，不能被private/static/final修饰 */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Data</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@AllArgsConstructor</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@NoArgsConstructor</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>implements</span> Serializable {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>volatile</span> String name;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testApi</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建Student实例，并为成员属性赋予初始值</span>
</span></span><span style=display:flex><span>        Student student <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Student(<span style=color:#e6db74>&#34;赵四&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 使用AtomicReferenceFieldUpdater绑定Student类中的name属性</span>
</span></span><span style=display:flex><span>        AtomicReferenceFieldUpdater<span style=color:#f92672>&lt;</span>Student, String<span style=color:#f92672>&gt;</span> nameUpdater <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>                AtomicReferenceFieldUpdater.<span style=color:#a6e22e>newUpdater</span>(Student.<span style=color:#a6e22e>class</span>, String.<span style=color:#a6e22e>class</span>, <span style=color:#e6db74>&#34;name&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 对student中的name进行原子操作</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;将name修改为飞机: &#34;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>+</span> nameUpdater.<span style=color:#a6e22e>getAndSet</span>(student, <span style=color:#e6db74>&#34;飞机&#34;</span>));
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;name当前值: &#34;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>+</span> nameUpdater.<span style=color:#a6e22e>get</span>(student));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=e05-分段锁原子类>E05. 分段锁原子类</h2><blockquote><p>心法: 分段锁类型原子类</p></blockquote><ul><li>JUC包中，Atomic分段锁原子类包括 <code>LongAdder/DoubleAdder</code> 等。</li><li>分段锁原子类内部维护一个cell数组，数组容量最大不超过CPU核数：<ul><li><code>LongAdder</code> 中的每个cell都有一个独立的long变量，初始值为 <code>0L</code>。</li><li><code>DoubleAdder</code> 中的每个cell都有一个独立的Double变量，初始值为 <code>0.0</code>。</li></ul></li><li>无并发时，直接在分段锁原子类内部的 <code>base区</code> 进行CAS操作即可。</li><li>高并发时，没比较成功的线程会被分摊到单独的cell中进行CAS操作：<ul><li>最终再将每个cell的结果进行汇总，以此提高并发效率。</li></ul></li></ul><blockquote><p>心法: 假设线程A要执行 <code>num += 3</code>，线程B要执行 <code>num++</code>，线程C要执行 <code>num--</code></p></blockquote><ol><li>假设线程A <code>compare</code> 成功，在base区进行 <code>swap</code>，得到第1段结果 <code>3</code>：<ol><li>与此同时，线程B <code>compare</code> 失败，立刻扩容一个包含long变量（初值0）的cell。</li><li>与此同时，线程C <code>compare</code> 失败，立刻扩容一个包含long变量（初值0）的cell。</li></ol></li><li>线程B在自己的cell中，对本cell中的long变量进行 <code>swap</code>，得到第2段结果 <code>1</code>。</li><li>线程C在自己的cell中，对本cell中的long变量进行 <code>swap</code>，得到第2段结果 <code>-1</code>。</li><li>汇总三个分段的结果，得到最终结果为 <code>3</code>。</li></ol><p>![[第1阶段-BASIC/JB1-7-并发编程/excalidraw/分段锁原子类.md#^group=vpWdz2Q_zXX_x90W_e-bZ|9999]]</p><blockquote><p>武技: 测试分段类型原子类常用的API方法</p></blockquote><h3 id=1-longadder>1. LongAdder</h3><p><code>atomic.LongAdderTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AtomicLongAdderTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 创建一个原子的LongAdder实例，初始值为0 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> LongAdder num <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LongAdder();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testApi</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// LongAdder允许直接输出</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;num: &#34;</span> <span style=color:#f92672>+</span> num);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        num.<span style=color:#a6e22e>add</span>(5);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;after +5: &#34;</span> <span style=color:#f92672>+</span> num);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        num.<span style=color:#a6e22e>increment</span>();
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;after +1: &#34;</span> <span style=color:#f92672>+</span> num);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        num.<span style=color:#a6e22e>decrement</span>();
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;after -1: &#34;</span> <span style=color:#f92672>+</span> num);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-doubleadder>2. DoubleAdder</h3><p><code>atomic.DoubleAdderTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DoubleAdderTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 创建一个原子的DoubleAdder实例，初始值为0.0 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> DoubleAdder num <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> DoubleAdder();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testApi</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// DoubleAdder允许直接输出</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;num: &#34;</span> <span style=color:#f92672>+</span> num);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        num.<span style=color:#a6e22e>add</span>(5.<span style=color:#a6e22e>5</span>);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;after +5.5: &#34;</span> <span style=color:#f92672>+</span> num);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=e06-threadlocal类>E06. ThreadLocal类</h2><h3 id=1-threadlocal内部结构>1. ThreadLocal内部结构</h3><blockquote><p>心法: ThreadLocal内部结构</p></blockquote><ul><li>每个 <code>Thread</code> 都独有一个 <code>ThreadLocal.ThreadLocalMap</code> 类型的属性：<ul><li>其内部通过 <code>ThreadLocal.ThreadLocalMap.Entry</code> 类存值。</li></ul></li><li>每个 <code>ThreadLocal.ThreadLocalMap</code> 的KEY值，都通过弱引用指向当前 <code>ThreadLocal</code> 实例：<ul><li>也正因如此，每个 <code>ThreadLocal</code> 对象只能存储一个值。</li></ul></li></ul><p>![[第1阶段-BASIC/JB1-7-并发编程/excalidraw/ThreadLocal内部结构.md#^group=QOLeXw1fUDEvZXZlfizEX|9999]]</p><h3 id=2-threadlocal对象特点>2. ThreadLocal对象特点</h3><blockquote><p>心法: 使用ThreadLocal可以保证资源只能被当前线程设置，获取和删除</p></blockquote><ol><li>使用ThreadLocal获取或操作值时。</li><li>先根据当前线程获取到对应的ThreadLocalMap对象。</li><li>再使用当前ThreadLocal实例的内存地址作为KEY来查找或操作对应的值。</li></ol><h3 id=3-threadlocal强弱引用>3. ThreadLocal强弱引用</h3><blockquote><p>心法: 为何Entry使用弱引用？</p></blockquote><table><thead><tr><th></th><th>描述</th></tr></thead><tbody><tr><td>强引用</td><td>对于被强引用的对象，GC宁可抛出异常，也不会回收它</td></tr><tr><td>弱引用</td><td>对于被弱引用的对象，GC看到它，就会立刻回收它</td></tr></tbody></table><ol><li>当创建一个 ThreadLocal 实例时，会进行如下2步：<ol><li>将ThreadLocal实例强关联到栈变量上，此为强引用。</li><li>将ThreadLocal实例作为当前线程内部独立维护的Entry的key值。</li></ol></li><li>若Entry使用强引用，那么即使在外部将ThreadLocal实例和栈变量断连，ThreadLocal实例仍然还保留一个强引用，此时GC是无法回收这个实例的，会导致内存泄漏。</li><li>所以在设计上，将Entry设计为弱引用，当ThreadLocal实例身上所有的强引用都断连之后，弱引用也会被GC。</li></ol><h3 id=4-threadlocal内存泄漏>4. ThreadLocal内存泄漏</h3><blockquote><p>心法: ThreadLocal本身不会产生内存泄露，但若使用不当，比如线程未死但ThreadLocal已死时，有可能就会产生内存泄漏现象了</p></blockquote><ol><li>假设线程A在自己的 <code>ThreadLocal</code> 中存储 <code>"hello"</code> 字符串。<ol><li>线程A和其对应的 <code>ThreadLocalMap</code> 共享生命周期，同生共死。</li><li>若线程来自于线程池，则有可能线程永生，即其对应的 <code>ThreadLocalMap</code> 永生。</li><li>此时，<code>ThreadLocalMap.Entry</code> 中的 <code>key</code> 值通过弱引用指向 <code>ThreadLocal</code>：</li></ol></li><li>此时，在代码中设置 <code>ThreadLocal</code> 为null值（Map结构是允许null key的）：<ol><li>此时 <code>ThreadLocal</code> 仅剩一条弱引用，会被GC回收，但 <code>ThreadLocalMap</code> 还在。</li><li>于是 <code>ThreadLocalMap.Entry</code> 中的 <code>key</code> 值变为null。</li><li>但是 <code>ThreadLocalMap.Entry</code> 中的 <code>value</code> 无法被回收，造成泄漏。</li></ol></li><li>所以最好的做法是用完ThreadLocal之后，手动调用 <code>remove()</code> 方法删除。</li></ol><p><img src=/%E7%AC%AC1%E9%98%B6%E6%AE%B5-BASIC/JB1-7-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image/696529cff60772ed160000b147ebbe18.png alt=ThreadLocal内存泄漏></p><h3 id=5-threadlocal相关方法>5. ThreadLocal相关方法</h3><blockquote><p>武技: ThreadLocal本地线程常用API方法</p></blockquote><p><code>threadlocal.ThreadLocalTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ThreadLocalTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 创建一个专门用于存储Person实例的ThreadLocal实例 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> ThreadLocal<span style=color:#f92672>&lt;</span>Person<span style=color:#f92672>&gt;</span> threadLocal <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ThreadLocal<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testThreadLocal</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建子线程A并启动</span>
</span></span><span style=display:flex><span>        Thread t01 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 在线程A的threadLocal中存储一个Person实例，以this为key</span>
</span></span><span style=display:flex><span>                threadLocal.<span style=color:#a6e22e>set</span>(<span style=color:#66d9ef>new</span> Person());
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;0s时，子线程A向ThreadLocal中存储Person&#34;</span>);
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;0s时，子线程A从ThreadLocal中获取Person: &#34;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                        threadLocal.<span style=color:#a6e22e>get</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 3秒后，从线程A的threadLocal中删除Person实例，并再次获取验证是否删除成功</span>
</span></span><span style=display:flex><span>                TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(3L);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>				<span style=color:#75715e>// 用完之后记得删除，防止内存泄漏</span>
</span></span><span style=display:flex><span>                threadLocal.<span style=color:#a6e22e>remove</span>();
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;3s后，子线程A从ThreadLocal中删除Person: &#34;</span>
</span></span><span style=display:flex><span>                        <span style=color:#f92672>+</span> threadLocal.<span style=color:#a6e22e>get</span>());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建线程B并启动</span>
</span></span><span style=display:flex><span>        Thread t02 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 1秒后，测试是否可以从线程B的threadLocal中取出Person实例</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 因为是在线程A中使用threadLocal存储的Person，在线程B中无法获取</span>
</span></span><span style=display:flex><span>                TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(1L);
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;1s后，子线程B从ThreadLocal中获取Person: &#34;</span>
</span></span><span style=display:flex><span>                        <span style=color:#f92672>+</span> threadLocal.<span style=color:#a6e22e>get</span>());
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 启动两个线程并插队执行</span>
</span></span><span style=display:flex><span>        t01.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        t01.<span style=color:#a6e22e>join</span>();
</span></span><span style=display:flex><span>        t02.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        t02.<span style=color:#a6e22e>join</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=s05-aqs概念入门>S05. AQS概念入门</h1><blockquote><p>心法: AbstractQueuedSynchronizer类</p></blockquote><ul><li>AQS类是大部分锁的底层原理类，核心是一个 <code>volatile int state</code> 属性和CAS操作:
- 该属性关联着一个双链表队列，链表中每个节点都存储着一个线程实例。
- 该队列的入队和出队过程都采用CAS操作，效率更高。</li><li><code>state</code> 属性所表示的意义是随子类而变的:
- <code>ReentrantLock</code>: 使用state变量来记录线程重入次数。
- <code>CountDownLatch</code>: 使用state变量来记录线程倒数计数。
- <code>Semaphore</code>: 使用state变量来记录信号量个数。</li></ul><p><img src=/%E7%AC%AC1%E9%98%B6%E6%AE%B5-BASIC/JB1-7-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image/8ba1cc4a80d45357f2f805f47e262e4b.png alt=AbstractQueuedSynchronizer核心原理></p><blockquote><p>心法: AbstractQueuedSynchronizer类常用实现方案</p></blockquote><table><thead><tr><th>实现类</th><th>state作用</th><th>特点描述</th></tr></thead><tbody><tr><td><code>ReentrantLock</code></td><td>记录线程重入次数</td><td>可重入</td></tr><tr><td><code>ReentrantReadWriteLock</code></td><td>记录线程重入次数</td><td>读读共享，读写互斥，写写互斥</td></tr><tr><td><code>CountDownLatch</code></td><td>记录当前门闩数</td><td>state=0时放行，state>0时阻塞，关注门闩数</td></tr><tr><td><code>Semaphore</code></td><td>记录当前信号量</td><td>state=0时阻塞，state>0时放行，关注信号量（线程数）</td></tr></tbody></table><h2 id=e01-reentrantlock>E01. ReentrantLock</h2><h3 id=1-对比synchronized>1. 对比synchronized</h3><blockquote><p>心法: ReentrantLock VS synchronized</p></blockquote><table><thead><tr><th>上锁方式</th><th>可重入性</th><th>是否支持公平锁</th><th>是否支持尝试获取锁</th></tr></thead><tbody><tr><td>ReentrantLock</td><td>可重入</td><td>支持</td><td>支持：该过程不阻塞</td></tr><tr><td>synchronized</td><td>可重入</td><td>不支持</td><td>不支持：获取不到锁时只能阻塞</td></tr></tbody></table><h3 id=2-普通上锁方式>2. 普通上锁方式</h3><blockquote><p>心法: 普通上锁方式</p></blockquote><table><thead><tr><th>普通上锁相关API方法</th><th>描述</th></tr></thead><tbody><tr><td><code>lock.lock()</code></td><td>拿不到锁誓不罢休，不然线程就一直阻塞，比较无赖的做法</td></tr><tr><td><code>lock.unlock()</code></td><td>解锁，建议在 <code>finally {}</code> 中进行解锁操作</td></tr></tbody></table><blockquote><p>武技: 测试ReentrantLock普通上锁方式</p></blockquote><p><code>aqs.LockTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LockTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LockDemo</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 创建一个可重入锁实例 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Lock lock <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReentrantLock();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 添加可重入锁</span>
</span></span><span style=display:flex><span>            lock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 每隔1秒打印一次当前线程名称，共打印5次</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 5; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                    TimeUnit.<span style=color:#a6e22e>MILLISECONDS</span>.<span style=color:#a6e22e>sleep</span>(200L);
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;: &#34;</span> <span style=color:#f92672>+</span> i);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 调用method()方法，测试ReentrantLock是否可重入</span>
</span></span><span style=display:flex><span>                method();
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>                e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 释放可重入锁，必须写在finally块中</span>
</span></span><span style=display:flex><span>                lock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 方法内使用lock进行上锁和解锁 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>method</span>() {
</span></span><span style=display:flex><span>            lock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 能成功输出这句话，证明ReentrantLock具有重入性</span>
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;: 执行完毕&#34;</span>);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 释放锁的代码必须写在finally块中</span>
</span></span><span style=display:flex><span>                lock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testLock</span>() {
</span></span><span style=display:flex><span>        Runnable runnable <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LockDemo();
</span></span><span style=display:flex><span>        Thread t01 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(runnable, <span style=color:#e6db74>&#34;子线程A&#34;</span>);
</span></span><span style=display:flex><span>        Thread t02 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(runnable, <span style=color:#e6db74>&#34;子线程B&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 启动两个线程并插队执行</span>
</span></span><span style=display:flex><span>        t01.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        t02.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        t01.<span style=color:#a6e22e>join</span>();
</span></span><span style=display:flex><span>        t02.<span style=color:#a6e22e>join</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=3-尝试上锁方式>3. 尝试上锁方式</h3><blockquote><p>心法: 尝试上锁方式</p></blockquote><table><thead><tr><th>尝试上锁相关API方法</th><th>描述</th></tr></thead><tbody><tr><td><code>tryLock()</code></td><td>立刻返回结果，拿到锁就返回true并上锁否则就返回false，比较潇洒的做法</td></tr><tr><td><code>tryLock(超时时间)</code></td><td>拿到锁就返回true并上锁拿不到就等待一段时间，超时就返回false，比较聪明的做法</td></tr></tbody></table><blockquote><p>武技: 测试ReentrantLock尝试上锁方式</p></blockquote><p><code>aqs.TryLockTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TryLockTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/** 创建一个可重入锁实例 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Lock lock <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReentrantLock();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testTryLock</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 启动子线程A，每隔1秒打印一次当前线程名称，共打印5次</span>
</span></span><span style=display:flex><span>        Thread t01 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            lock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 5; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                    TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(1L);
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;: &#34;</span> <span style=color:#f92672>+</span> i);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>                e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                lock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }, <span style=color:#e6db74>&#34;子线程A&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 启动子线程B: 3秒内不断尝试获取锁</span>
</span></span><span style=display:flex><span>        Thread t02 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 记录是否获取到了锁</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>boolean</span> locked <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 3秒内不断尝试获取锁</span>
</span></span><span style=display:flex><span>                locked <span style=color:#f92672>=</span> lock.<span style=color:#a6e22e>tryLock</span>(3, TimeUnit.<span style=color:#a6e22e>SECONDS</span>);
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(locked <span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>                        Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;: 获取到了锁，子线程结束&#34;</span> :
</span></span><span style=display:flex><span>                        Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;: 没有获取到锁，子线程结束&#34;</span>);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>                e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (locked) {
</span></span><span style=display:flex><span>                    lock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }, <span style=color:#e6db74>&#34;子线程B&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 启动两个线程并插队执行</span>
</span></span><span style=display:flex><span>        t01.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        t02.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        t01.<span style=color:#a6e22e>join</span>();
</span></span><span style=display:flex><span>        t02.<span style=color:#a6e22e>join</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=4-上锁源码解析>4. 上锁源码解析</h3><blockquote><p>心法: ReentrantLock.lock() 源码</p></blockquote><ol><li>ReentrantLock上锁底层调用的是AQS的 <code>tryAcquire()</code> 方法：<ol><li>初入：通过CAS方式设置 <code>state = 1</code>，设置线程独占。</li><li>重入：设置 <code>state++</code>。</li></ol></li><li>若 <code>tryAcquire()</code> 失败，则通过CAS方式不断地加入等待队列尾部。</li><li>在队列中不断地尝试获取锁：<ol><li>头节点是在进行任务的线程，脖子节点是在抢锁的线程。</li></ol></li></ol><p><img src=/%E7%AC%AC1%E9%98%B6%E6%AE%B5-BASIC/JB1-7-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image/15a218d2ae3d625045862319db30e495.png alt=ReentrantLock之lock()源码></p><h3 id=5-解锁源码解析>5. 解锁源码解析</h3><blockquote><p>心法: ReentrantLock.unlock() 源码</p></blockquote><ol><li>ReentrantLock解锁底层调用的是AQS的 <code>tryRelease()</code> 方法：<ol><li>设置 <code>state--</code>。</li><li>判断是否是当前线程独占，若不是，抛异常。</li><li>判断 <code>state</code> 是否为0：<ol><li>若为0，表示全部锁都已解开，清空当前线程独占。</li><li>不为0，表示仍有一些锁没有解开。</li></ol></li></ol></li></ol><p><img src=/%E7%AC%AC1%E9%98%B6%E6%AE%B5-BASIC/JB1-7-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image/f96bd727c4244e31ce9d80b7f10a3772.png alt=ReentrantLock之unlock()源码></p><h2 id=e02-reentrantreadwritelock>E02. ReentrantReadWriteLock</h2><blockquote><p>心法: ReentrantReadWriteLock</p></blockquote><ul><li>ReentrantReadWriteLock是一种可重入的读写锁，可以分离出读锁和写锁两个子锁：<ul><li>读读共享: 我读的时候允许别人也来读。</li><li>读写互斥: 我写的时候不允许别人读，我读的时候不允许别人写。</li><li>写写互斥: 我写的时候不允许别人写。</li></ul></li><li>ReentrantReadWriteLock用于提高读的效率，特别适用于读多写少的场景。</li></ul><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR
RRW[&#34;
	ReentrantReadWriteLock
	可重入读写锁
&#34;]
RL[&#34;ReadLock读锁&#34;]
WL[&#34;WriteLock写锁&#34;]

RRW --调用readLock方法--&gt; RL
RRW --调用writeLock方法--&gt; WL
</code></pre><blockquote><p>武技: 测试ReentrantReadWriteLock</p></blockquote><p><code>aqs.ReentrantReadWriteLockTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ReentrantReadWriteLockTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 本类用于测试ReentrantReadWriteLock的读写效果 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ReadWriteLockDemo</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 读写锁实例 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> ReadWriteLock lock <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReentrantReadWriteLock();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 读锁 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Lock readLock <span style=color:#f92672>=</span> lock.<span style=color:#a6e22e>readLock</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 写锁 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Lock writeLock <span style=color:#f92672>=</span> lock.<span style=color:#a6e22e>writeLock</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 模拟读操作耗时5秒 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>read</span>() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 获取读锁</span>
</span></span><span style=display:flex><span>            readLock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;正在读...&#34;</span>);
</span></span><span style=display:flex><span>                TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(5L);
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;读完了...&#34;</span>);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 释放读锁</span>
</span></span><span style=display:flex><span>                readLock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 模拟写操作耗时2秒 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>write</span>() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 获取写锁</span>
</span></span><span style=display:flex><span>            writeLock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;正在写...&#34;</span>);
</span></span><span style=display:flex><span>                TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(2L);
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;写完了...&#34;</span>);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 释放写锁</span>
</span></span><span style=display:flex><span>                writeLock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testReadWriteLock</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ReadWriteLockDemo readWriteLockDemo <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReadWriteLockDemo();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建4个线程</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 相当于 new Thread(() -&gt; readWriteLockDemo.read(), &#34;读线程A&#34;)</span>
</span></span><span style=display:flex><span>        Thread t01 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(readWriteLockDemo::read, <span style=color:#e6db74>&#34;读线程A&#34;</span>);
</span></span><span style=display:flex><span>        Thread t02 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(readWriteLockDemo::read, <span style=color:#e6db74>&#34;读线程B&#34;</span>);
</span></span><span style=display:flex><span>        Thread t03 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(readWriteLockDemo::write, <span style=color:#e6db74>&#34;写线程C&#34;</span>);
</span></span><span style=display:flex><span>        Thread t04 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(readWriteLockDemo::write, <span style=color:#e6db74>&#34;写线程D&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 启动4个线程并插队执行</span>
</span></span><span style=display:flex><span>        t01.<span style=color:#a6e22e>start</span>(); t02.<span style=color:#a6e22e>start</span>(); t03.<span style=color:#a6e22e>start</span>(); t04.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        t01.<span style=color:#a6e22e>join</span>(); t02.<span style=color:#a6e22e>join</span>(); t03.<span style=color:#a6e22e>join</span>(); t04.<span style=color:#a6e22e>join</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=e03-countdownlatch>E03. CountDownLatch</h2><blockquote><p>心法: CountDownLatch</p></blockquote><ul><li>CountDownLatch线程门闩，使用时立刻阻塞当前线程:<ul><li>此时其他线程可以对门闩数递减，当门闩数递减为0时放行当前线程。</li></ul></li><li>整个过程不关注线程数，仅关注门闩数。</li></ul><table><thead><tr><th>相关API方法</th><th>描述</th></tr></thead><tbody><tr><td><code>new CountDownLatch(n)</code></td><td>创建一个N层的倒数门闩</td></tr><tr><td><code>latch.await()</code></td><td>代码所在线程进入等待状态，等待门闩数为0时自动唤醒，继续向下执行</td></tr><tr><td><code>latch.countDown()</code></td><td>拆掉1层门闩，即门闩计数器减1</td></tr></tbody></table><blockquote><p>武技: 使用赛马小程序测试CountDownLatch</p></blockquote><p><code>aqs.CountDownLatchTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CountDownLatchTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 一共几匹马 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> NUM <span style=color:#f92672>=</span> 8;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 创建门闩实例，并设置初始门闩数为8个 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> CountDownLatch LATCH <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CountDownLatch(NUM);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testCountDownLatch</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 使用主线程作为裁判线程</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;裁判线程: 比赛开始，一共%d匹马...\n&#34;</span>, LATCH.<span style=color:#a6e22e>getCount</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 开启8个线程，模拟8匹马</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1; i <span style=color:#f92672>&lt;=</span> NUM; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 模拟没匹马的运动耗时</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>int</span> spendTime <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Random().<span style=color:#a6e22e>nextInt</span>(5000);
</span></span><span style=display:flex><span>                    TimeUnit.<span style=color:#a6e22e>MILLISECONDS</span>.<span style=color:#a6e22e>sleep</span>(spendTime);
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 马到了终点，拆除一层门闩</span>
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%s 到达终点，耗时%d毫秒，&#34;</span>,
</span></span><span style=display:flex><span>                            Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>(), spendTime);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(e);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 拆掉1层门闩，即门闩计数器减1</span>
</span></span><span style=display:flex><span>                    LATCH.<span style=color:#a6e22e>countDown</span>();
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;剩余 %d 匹马\n&#34;</span>, LATCH.<span style=color:#a6e22e>getCount</span>());
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }, i <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;号马&#34;</span>).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 裁判线程挂起等待，门闩数为0时自动唤醒</span>
</span></span><span style=display:flex><span>        LATCH.<span style=color:#a6e22e>await</span>();
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;裁判线程: 比赛结束...&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=e04-semaphore>E04. Semaphore</h2><blockquote><p>心法: Semaphore</p></blockquote><ul><li>Semaphore信号，用于控制最大并发数量，即限流。</li></ul><p>![[第1阶段-BASIC/JB1-7-并发编程/excalidraw/Semaphore原理.md#^group=-daCd5zHAikddoXFo93vs|100%]]</p><table><thead><tr><th>相关API方法</th><th>描述</th></tr></thead><tbody><tr><td><code>new Semaphore(n)</code></td><td>创建一个初始信号量为 <code>n</code> 的信号实例</td></tr><tr><td><code>semaphore.acquire()</code></td><td>获取一个信号，获取不成功当前线程会阻塞等待</td></tr><tr><td><code>semaphore.release()</code></td><td>释放一个信号，此时其他线程可以重新获取这个信号</td></tr></tbody></table><blockquote><p>武技: 测试Semaphore</p></blockquote><p><code>aqs.SemaphoreTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SemaphoreTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testSemaphore</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建信号量实例，初始信号量为3</span>
</span></span><span style=display:flex><span>        Semaphore semaphore <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Semaphore(3);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 循环创建10个子线程</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 10; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 获取一个信号，获取不成功当前线程会阻塞等待</span>
</span></span><span style=display:flex><span>                    semaphore.<span style=color:#a6e22e>acquire</span>();
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 模拟线程执行任务</span>
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; 执行线程任务...&#34;</span>);
</span></span><span style=display:flex><span>                    TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(3L);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                    e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 释放一个信号，此时其他线程可以重新获取这个信号</span>
</span></span><span style=display:flex><span>                    semaphore.<span style=color:#a6e22e>release</span>();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }, <span style=color:#e6db74>&#34;子线程&#34;</span> <span style=color:#f92672>+</span> i).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 阻塞junit线程</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(30L);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=s06-多线程通信方式>S06. 多线程通信方式</h1><blockquote><p>心法: 多线程通信常用实现方案</p></blockquote><table><thead><tr><th></th><th>特点总结</th><th>等待方式</th><th>唤醒方式</th><th>环境要求</th></tr></thead><tbody><tr><td><code>WaitNotify</code></td><td>全部范围随机唤醒</td><td><code>锁.wait()</code></td><td><code>锁.notify()</code><code>锁.notifyAll()</code></td><td>同步环境</td></tr><tr><td><code>Condition</code></td><td>指定范围随机唤醒</td><td><code>队列.await()</code></td><td><code>队列.signal()</code><code>队列.sinalAll()</code></td><td>同步环境</td></tr><tr><td><code>LockSupport</code></td><td>指定线程唤醒</td><td><code>LockSupport.park()</code></td><td><code>LockSupport.unpark(线程)</code></td><td>无要求</td></tr><tr><td><code>CyclicBarrier</code></td><td>满足数量条件时一起唤醒</td><td><code>屏障实例.await()</code></td><td>等线程数达到指定值时</td><td>无要求</td></tr><tr><td><code>Exchanger</code></td><td>两个线程交换时一起唤醒</td><td><code>交换实例.exchange(数据)</code></td><td>出现2次 <code>交换实例.exchange(数据)</code></td><td>无要求</td></tr><tr><td><code>Phaser</code></td><td>线程成功晋级时唤醒</td><td><code>阶段实例.arriveAndAwaitAdvance()</code></td><td><code>阶段实例.arriveAndDeregister()</code></td><td>无要求</td></tr></tbody></table><h2 id=e01-waitnotify>E01. WaitNotify</h2><blockquote><p>心法: wait and notify</p></blockquote><ul><li>Object类提供了让线程等待或将线程唤醒的API方法，但均只能在同步代码区中使用。</li></ul><table><thead><tr><th>相关API方法</th><th>描述</th></tr></thead><tbody><tr><td><code>锁实例.wait()</code></td><td>让代码所在的线程进入等待队列，释放锁</td></tr><tr><td><code>锁实例.notify()</code></td><td>随机唤醒等待队列中的一个线程，不释放锁</td></tr><tr><td><code>锁实例.notifyAll()</code></td><td>唤醒等待队列中的所有等待线程，不释放锁</td></tr></tbody></table><blockquote><p>心法: <code>wait()</code> vs <code>sleep()</code></p></blockquote><table><thead><tr><th>方法</th><th>所属类</th><th>是否静态</th><th>是否释放锁</th><th>如何唤醒</th><th>其他</th></tr></thead><tbody><tr><td><code>wait()</code></td><td>Object</td><td>否</td><td>是</td><td><code>notify()/notifyAll()</code></td><td>必须在同步代码块中调用</td></tr><tr><td><code>sleep()</code></td><td>Thread</td><td>是</td><td>否</td><td><code>interreput()</code> 或超时</td><td>可以在任何地方调用</td></tr></tbody></table><blockquote><p>武技: 使用 WaitNotify 搭建生产消费模型，要求每生产一个就消费一个，轮流进行</p></blockquote><h3 id=1-开发共享资源类>1. 开发共享资源类</h3><p><code>communication.WaitNotifyTest$Food</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WaitNotifyTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 生产消费模型中的资源实体Food */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Data</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Food</span> {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 食物名称 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 该食物是否已经存在，即是否已被生产 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span> exist;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-开发生产者类>2. 开发生产者类</h3><blockquote><p>心法: 生产者线程在 <code>有资源</code> 时 wait 等待，并 notify 一个消费者线程进行消费</p></blockquote><p><code>communication.WaitNotifyTest$Producer</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WaitNotifyTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 生产者: 负责生产食物 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Producer</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Food food;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Producer(Food food) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>food</span> <span style=color:#f92672>=</span> food;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// wait()需要在同步代码中使用: 不要使用this锁</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>synchronized</span> (food) {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 若food已存在，则生产者线程进入wait状态</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (food.<span style=color:#a6e22e>isExist</span>()) {
</span></span><span style=display:flex><span>                        food.<span style=color:#a6e22e>wait</span>();
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 若food不存在，生产者生产一个food，并随机唤醒一个消费者</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>						TimeUnit.<span style=color:#a6e22e>MILLISECONDS</span>.<span style=color:#a6e22e>sleep</span>(200L);
</span></span><span style=display:flex><span>                        food.<span style=color:#a6e22e>setName</span>(<span style=color:#e6db74>&#34;米旗蛋糕&#34;</span>);
</span></span><span style=display:flex><span>                        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;生产: &#34;</span> <span style=color:#f92672>+</span> food.<span style=color:#a6e22e>getName</span>());
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// 更改food的exist为true，表示我已经生产完毕了</span>
</span></span><span style=display:flex><span>                        food.<span style=color:#a6e22e>setExist</span>(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// 随机唤醒一个等待的线程（唤醒的是消费者）</span>
</span></span><span style=display:flex><span>                        food.<span style=color:#a6e22e>notify</span>();
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=3-开发消费者类>3. 开发消费者类</h3><blockquote><p>心法: 消费者线程在 <code>无资源</code> 时 wait 等待，并 notify 一个生产者线程进行消费</p></blockquote><p><code>communication.WaitNotifyTest$Consumer</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WaitNotifyTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 消费者: 负责消费食物 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Consumer</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Food food;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Consumer(Food food) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>food</span> <span style=color:#f92672>=</span> food;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// wait()需要在同步代码中使用: 不要使用this锁</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>synchronized</span> (food) {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 若food已存在，消费者消费一个food，并随机唤醒一个生产者</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (food.<span style=color:#a6e22e>isExist</span>()) {
</span></span><span style=display:flex><span>						TimeUnit.<span style=color:#a6e22e>MILLISECONDS</span>.<span style=color:#a6e22e>sleep</span>(200L);
</span></span><span style=display:flex><span>                        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;消费: &#34;</span> <span style=color:#f92672>+</span> food.<span style=color:#a6e22e>getName</span>());
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// 更改food的exist为false，表示我已经消费完毕了</span>
</span></span><span style=display:flex><span>                        food.<span style=color:#a6e22e>setExist</span>(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// 随机唤醒一个等待的线程（唤醒的是生产者）</span>
</span></span><span style=display:flex><span>                        food.<span style=color:#a6e22e>notify</span>();
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 若food不存在，则消费者线程进入wait状态</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        food.<span style=color:#a6e22e>wait</span>();
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=4-测试waitnotify>4. 测试WaitNotify</h3><p><code>communication.WaitNotifyTest.testWaitNotify()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WaitNotifyTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 生产消费者模型: 要求每生产一个就消费一个，轮流进行 */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testWaitNotify</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建一个食物的实例</span>
</span></span><span style=display:flex><span>        Food food <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Food();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建一个生产者线程并启动</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(<span style=color:#66d9ef>new</span> Producer(food)).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建一个消费者者线程并启动</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(<span style=color:#66d9ef>new</span> Consumer(food)).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 阻塞junit线程</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(10L);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=e02-condition>E02. Condition</h2><blockquote><p>心法: <code>j.u.c.Condition</code></p></blockquote><ul><li>Condition内部维护了一个等待队列（不是AQS中的等待队列），用于将进行等待唤醒操作的线程分类：<ul><li>JUC包中的 <code>ArrayBlockingQueue</code> 就是通过Condition实现的。</li><li>Condition的相关API方法也必须在同步代码中进行使用。</li></ul></li><li>若将生产者线程放入生产者等待队列，将消费者线程放入消费者等待队列，可以对二者解耦。</li></ul><p>![[第1阶段-BASIC/JB1-7-并发编程/excalidraw/Condition原理.md#^group=WWBYo7i01-185xuIvAp3m|100%]]</p><table><thead><tr><th>相关API方法</th><th>描述（假设当前线程为T，Condition内部维护的等待队列为C）</th></tr></thead><tbody><tr><td><code>lock.newCondition()</code></td><td>创建一条等待队列底层调用的是AQS类中的 <code>sync.newCondition() -> new ConditionObject()</code></td></tr><tr><td><code>等待队列.await()</code></td><td>让代码所在的线程进入指定等待队列中1. 将T添加到队列C的末尾。2. 释放锁，此时其他线程允许进入同步代码区。3. 通过 <code>LockSupport.park()</code> 使该线程进入 <code>WAITING</code> 状态，让出CPU时间。</td></tr><tr><td><code>等待队列.signal()</code></td><td>随机唤醒指定等待队列中的一个 <code>await()</code> 状态的线程1. 将T从队列C移动到AQS等待队列的末尾，使其重新拥有竞争CPU资源的资格。2. 通过 <code>LockSupport.unpark()</code> 解除当前线程的 <code>WAITING</code> 状态状态。</td></tr><tr><td><code>等待队列.signalAll()</code></td><td>唤醒指定等待队列中的全部 <code>await()</code> 状态的线程</td></tr></tbody></table><blockquote><p>武技: 测试Condition条件对象</p></blockquote><h3 id=1-开发线程类>1. 开发线程类</h3><p><code>communication.ConditionTest$ConditionDemo</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ConditionTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 该类用于测试Condition的多条等待队列效果 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ConditionDemo</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 可重入锁 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Lock lock <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReentrantLock();
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 通过可重入锁获取一条A队列 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Condition conditionA <span style=color:#f92672>=</span> lock.<span style=color:#a6e22e>newCondition</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 通过可重入锁获取一条B队列 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Condition conditionB <span style=color:#f92672>=</span> lock.<span style=color:#a6e22e>newCondition</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// await需要在同步代码中调用</span>
</span></span><span style=display:flex><span>            lock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>            String currentThreadName <span style=color:#f92672>=</span> Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 让子线程01进入conditionA等待队列，其余线程进入conditionB等待队列</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (currentThreadName.<span style=color:#a6e22e>equals</span>(<span style=color:#e6db74>&#34;子线程01&#34;</span>)) {
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(currentThreadName <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;进入conditionA等待队列&#34;</span>);
</span></span><span style=display:flex><span>                    conditionA.<span style=color:#a6e22e>await</span>();
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(currentThreadName <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;进入conditionB等待队列&#34;</span>);
</span></span><span style=display:flex><span>                    conditionB.<span style=color:#a6e22e>await</span>();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 当某个await状态的线程被唤醒时执行</span>
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(currentThreadName <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;被唤醒&#34;</span>);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>                e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                lock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 唤醒ConditionA等待队列中的全部线程 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>signalAllInConditionA</span>() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// signalAll需要在同步代码中调用</span>
</span></span><span style=display:flex><span>            lock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 将conditionA队列中的全部线程唤醒</span>
</span></span><span style=display:flex><span>                conditionA.<span style=color:#a6e22e>signalAll</span>();
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>                e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                lock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 唤醒ConditionB等待队列中的全部线程 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>signalAllInConditionB</span>() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// signalAll需要在同步代码中调用</span>
</span></span><span style=display:flex><span>            lock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 将conditionB队列中的全部线程唤醒</span>
</span></span><span style=display:flex><span>                conditionB.<span style=color:#a6e22e>signalAll</span>();
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>                e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                lock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-测试condition>2. 测试Condition</h3><p><code>communication.ConditionTest.test()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ConditionTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testCondition</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 实例化线程类</span>
</span></span><span style=display:flex><span>        ConditionDemo conditionDemo <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ConditionDemo();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 开启4个线程</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(conditionDemo, <span style=color:#e6db74>&#34;子线程01&#34;</span>).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(conditionDemo, <span style=color:#e6db74>&#34;子线程02&#34;</span>).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(conditionDemo, <span style=color:#e6db74>&#34;子线程03&#34;</span>).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(conditionDemo, <span style=color:#e6db74>&#34;子线程04&#34;</span>).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 主线程在3s后，调用signalAllInConditionA方法，唤醒ConditionA等待队列中的全部线程</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(3L);
</span></span><span style=display:flex><span>        conditionDemo.<span style=color:#a6e22e>signalAllInConditionA</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 主线程在6s后，调用signalAllInConditionB方法，唤醒ConditionB等待队列中的全部线程</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(3L);
</span></span><span style=display:flex><span>        conditionDemo.<span style=color:#a6e22e>signalAllInConditionB</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 阻塞junit线程</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(5L);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=e03-locksupport>E03. LockSupport</h2><blockquote><p>心法: <code>j.u.c.LockSupport</code></p></blockquote><ul><li>LockSupport可以指定某个线程的等待和唤醒。</li><li>LockSupport的相关API方法无需在同步代码中进行使用。</li></ul><p>![[第1阶段-BASIC/JB1-7-并发编程/excalidraw/LockSupport原理.md#^group=PemBoN2s5Mu7FCN15KpmD|100%]]</p><table><thead><tr><th>相关API方法</th><th>描述</th></tr></thead><tbody><tr><td><code>LockSupport.park()</code></td><td>将当前所在线程停驻等待</td></tr><tr><td><code>LockSupport.unpark(Thread t)</code></td><td>将指定线程 <code>t</code> 唤醒，若在 <code>park()</code> 之前被调用，则 <code>park()</code> 会失效</td></tr></tbody></table><blockquote><p>武技: 测试 LockSupport</p></blockquote><h3 id=1-开发线程类-1>1. 开发线程类</h3><p><code>communication.LockSupportTest$LockSupportDemo</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LockSupportTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 用于测试LockSupport的等待唤醒效果 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LockSupportDemo</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            String currentThreadName <span style=color:#f92672>=</span> Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 9; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(currentThreadName <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;: &#34;</span> <span style=color:#f92672>+</span> i);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>==</span> 3) {
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;: 被Park等待...&#34;</span>);
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 当前线程停驻等待</span>
</span></span><span style=display:flex><span>                    LockSupport.<span style=color:#a6e22e>park</span>();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-测试locksupport>2. 测试LockSupport</h3><p><code>communication.LockSupportTest.testLockSupport()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LockSupportTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testLockSupport</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 实例化线程类</span>
</span></span><span style=display:flex><span>        LockSupportDemo lockSupportDemo <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LockSupportDemo();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建子线程A和子线程B</span>
</span></span><span style=display:flex><span>        Thread threadA <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(lockSupportDemo, <span style=color:#e6db74>&#34;子线程A&#34;</span>);
</span></span><span style=display:flex><span>        Thread threadB <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(lockSupportDemo, <span style=color:#e6db74>&#34;子线程B&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 启动子线程A和子线程B</span>
</span></span><span style=display:flex><span>        threadA.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        threadB.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 主线程在5s后，唤醒子线程A</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(5L);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;5s后，子线程A被unPark放行...&#34;</span>);
</span></span><span style=display:flex><span>        LockSupport.<span style=color:#a6e22e>unpark</span>(threadA);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 阻塞junit线程</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(10);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=e04-cyclicbarrier>E04. CyclicBarrier</h2><blockquote><p>心法: CyclicBarrier</p></blockquote><ul><li>每个线程抵达屏障位置时都会立刻阻塞。</li><li>当抵达的线程数达到屏障设定的线程最大值时，屏障被推倒，屏障前的全部线程一起放行。</li><li>CyclicBarrier可循环使用。</li></ul><p>![[第1阶段-BASIC/JB1-7-并发编程/excalidraw/CyclicBarrier原理.md#^group=YXZDGlDQW4FuYW_3kPSnN|100%]]</p><table><thead><tr><th>相关API方法</th><th>描述</th></tr></thead><tbody><tr><td><code>new CyclicBarrier(int i, [Runnable r])</code></td><td>创建循环屏障实例param1: 指定屏障前阻塞线程的最大值。param2: 当屏障被推倒后执行的回调函数，该参数可选。</td></tr><tr><td><code>cyclicBarrier.await()</code></td><td>模拟一个线程达到了屏障处，阻塞等待</td></tr></tbody></table><blockquote><p>心法: CyclicBarrier的等待流程</p></blockquote><ol><li>底层调用 <code>dowait()</code> 将当前线程加入到一个Condition等待队列中:<ol><li>该方法使用ReentrantLock获取了锁。</li></ol></li><li>实例化一个 <code>generation</code> 轮次，若该轮次处于broken状态，则抛出异常:<ol><li>Generation是CyclicBarrier的内部类，仅拥有一个broken属性，用于表示一个轮次。</li></ol></li><li>若当前线程被interrupt打断，则直接调用 <code>breakBarrier()</code> 推倒屏障，并抛出异常:<ol><li>推倒屏障时: 将轮次的broken设置为true，重置屏障数。</li><li>并通过 <code>signalAll()</code> 唤醒全部 <code>await</code> 线程。</li></ol></li><li>对屏障数进行自减操作: 若屏障数已自减到0，则视为当前轮次结束:<ol><li>若存在回调函数，则执行回调函数，若执行异常，则调用 <code>breakBarrier()</code> 推倒屏障。</li><li>开启下一轮次时: 通过 <code>signalAll()</code> 唤醒全部 <code>await</code> 线程，并重置屏障数和 <code>generation</code> 轮次。</li></ol></li><li>开启自循环监控:<ol><li>通过 <code>await</code> 将线程加入等待队列，若添加异常，则调用 <code>breakBarrier()</code> 推倒屏障，并抛出异常。</li><li>开启自循环监控，当轮次变为broken状态则抛出异常，超时则直接调用 <code>breakBarrier()</code> 推倒屏障。</li></ol></li></ol><blockquote><p>武技: 测试CyclicBarrier</p></blockquote><h3 id=1-开发线程类-2>1. 开发线程类</h3><p><code>communication.CyclicBarrierTest$CyclicBarrierDemo</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CyclicBarrierTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 该类用于测试 CyclicBarrier的 await() 方法 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CyclicBarrierDemo</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建一个循环屏障: 当线程数达到3时放行，每次屏障被推倒时执行一次回调函数（可选）</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> CyclicBarrier cyclicBarrier <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CyclicBarrier(3,
</span></span><span style=display:flex><span>                () <span style=color:#f92672>-&gt;</span> System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;凑齐3人，开始斗地主\n&#34;</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 同步是为了让随机数和输出语句同步进行</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>synchronized</span> (<span style=color:#66d9ef>this</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 模拟每个玩家的准备时间</span>
</span></span><span style=display:flex><span>                    TimeUnit.<span style=color:#a6e22e>MILLISECONDS</span>.<span style=color:#a6e22e>sleep</span>(<span style=color:#66d9ef>new</span> Random().<span style=color:#a6e22e>nextInt</span>(2000));
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%s进入房间等待中..\n&#34;</span>, Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>());
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 当前线程在循环屏障前阻塞等待</span>
</span></span><span style=display:flex><span>                cyclicBarrier.<span style=color:#a6e22e>await</span>();
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (BrokenBarrierException <span style=color:#f92672>|</span> InterruptedException e) {
</span></span><span style=display:flex><span>                e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-测试cyclicbarrier>2. 测试CyclicBarrier</h3><p><code>communication.CyclicBarrierTest.testCyclicBarrier()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CyclicBarrierTest</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@SneakyThrows</span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@Test</span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testCyclicBarrier</span>() {  
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// 创建线程类实例  </span>
</span></span><span style=display:flex><span>	    CyclicBarrierDemo cyclicBarrierDemo <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CyclicBarrierDemo();  
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// 创建11个线程并启动，模拟11位玩家  </span>
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1; i <span style=color:#f92672>&lt;=</span> 11; i<span style=color:#f92672>++</span>) {  
</span></span><span style=display:flex><span>	        <span style=color:#66d9ef>new</span> Thread(cyclicBarrierDemo, i <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;号玩家&#34;</span>).<span style=color:#a6e22e>start</span>();  
</span></span><span style=display:flex><span>	    }  
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// 阻塞junit线程  </span>
</span></span><span style=display:flex><span>	    TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(20L);  
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=e05-exchanger>E05. Exchanger</h2><blockquote><p>心法: <code>j.u.c.Exchanger</code></p></blockquote><ul><li>Exchanger用于两个线程交换数据。</li></ul><p>![[第1阶段-BASIC/JB1-7-并发编程/excalidraw/Exchanger原理.md#^group=4WrKFWQYDDOzABJYOqcJa|100%]]</p><table><thead><tr><th>相关API方法</th><th>描述</th></tr></thead><tbody><tr><td><code>new Exchanger&lt;String>()</code></td><td>创建Exchanger实例，构造时需指定泛型，表示交换的数据的类型</td></tr><tr><td><code>exchanger.exchange(V x)</code></td><td>交换数据，方法会阻塞，直到第二个线程调用 <code>exchange()</code>：param1: 发送出去的数据return: 接收回来的数据</td></tr></tbody></table><blockquote><p>武技: 测试 Exchanger</p></blockquote><h3 id=1-测试-exchanger>1. 测试 Exchanger</h3><p><code>communication.ExchangerTest.testExchange()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ExchangerTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testExchange</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建一个线程交换实例</span>
</span></span><span style=display:flex><span>        Exchanger<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> exchanger <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Exchanger<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建一个买家线程并启动</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(3L);
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;买家就绪...&#34;</span>);
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 交换数据，方法会阻塞，一直到第二个线程调用 exchange()</span>
</span></span><span style=display:flex><span>                String exchangedValue <span style=color:#f92672>=</span> exchanger.<span style=color:#a6e22e>exchange</span>(<span style=color:#e6db74>&#34;10 RMB&#34;</span>);
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;买家获得了 &#34;</span> <span style=color:#f92672>+</span> exchangedValue);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建一个卖家线程并启动</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;卖家就绪...&#34;</span>);
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 交换数据，方法会阻塞，一直到第二个线程调用 exchange()</span>
</span></span><span style=display:flex><span>                String exchangedValue <span style=color:#f92672>=</span> exchanger.<span style=color:#a6e22e>exchange</span>(<span style=color:#e6db74>&#34;面包&#34;</span>);
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;卖家获得了 &#34;</span> <span style=color:#f92672>+</span> exchangedValue);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 阻塞junit线程</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(10);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=e06-phaser>E06. Phaser</h2><blockquote><p>心法: <code>j.u.c.Phaser</code></p></blockquote><ul><li>Phaser用于设置分阶段的一次性屏障，重写 <code>onAdvance(int phase, int registeredParties)</code> 可阶段处理内容：<ul><li>param1: 当前阶段标志，由整数表示，0表示第一阶段，以此类推。</li><li>param2: 晋级线程数，即当前阶段下仍处于注册状态的线程数。</li><li>return: false表示当前阶段结束，true表示所有阶段结束。</li></ul></li><li>前进方法 <code>onAdvance()</code> 会在每次进入一个新阶段时自动调用。</li></ul><p>![[第1阶段-BASIC/JB1-7-并发编程/excalidraw/Phaser原理.md#^group=k_n6Gdj5NrVsAsNccl67l|100%]]</p><table><thead><tr><th>相关API方法</th><th>描述</th></tr></thead><tbody><tr><td><code>new Phaser()</code></td><td>构建一个默认值为0的Phaser实例</td></tr><tr><td><code>phaser.bulkRegister(n)</code></td><td>指定初始注册线程数，await线程数达到该值时触发前进方法，进入下一阶段。</td></tr><tr><td><code>phaser.arriveAndAwaitAdvance()</code></td><td>成功抵达当前阶段并且等待前进，进入下一阶段。</td></tr><tr><td><code>phaser.arriveAndDeregister()</code></td><td>成功抵达当前阶段并且从屏障组中注销。</td></tr></tbody></table><blockquote><p>武技: 测试 Phaser</p></blockquote><h3 id=1-创建phaser实例>1. 创建Phaser实例</h3><p><code>communication.PhaserTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PhaserTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> Phaser phaser;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 在单元测试方法执行之前构建Phaser实例并重写前进方法 */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Before</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>before</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建Phaser实例并重写前进方法</span>
</span></span><span style=display:flex><span>        phaser <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Phaser() {
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>            <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>             * 前进方法在每次进入一个新阶段的时候自动调用
</span></span></span><span style=display:flex><span><span style=color:#75715e>             * 
</span></span></span><span style=display:flex><span><span style=color:#75715e>             * @param phase 当前阶段标志，由整数表示，0表示第一阶段，以此类推
</span></span></span><span style=display:flex><span><span style=color:#75715e>             * @param registeredParties 晋级的线程数，即当前阶段下仍处于注册状态的线程数
</span></span></span><span style=display:flex><span><span style=color:#75715e>             * @return false表示当前阶段结束，true表示所有阶段结束
</span></span></span><span style=display:flex><span><span style=color:#75715e>             */</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>onAdvance</span>(<span style=color:#66d9ef>int</span> phase, <span style=color:#66d9ef>int</span> registeredParties) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 第1阶段的时候进入</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (phase <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(registeredParties <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; 个英雄都已准备完毕...\n&#34;</span>);
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// false表示当前阶段结束</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 第2阶段的时候进入</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (phase <span style=color:#f92672>==</span> 1) {
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(registeredParties <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; 个英雄通过了第1关...\n&#34;</span>);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 第3阶段的时候进入</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (phase <span style=color:#f92672>==</span> 2) {
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(registeredParties <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; 个英雄通过了第2关...\n&#34;</span>);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;游戏结束...&#34;</span>);
</span></span><span style=display:flex><span>                <span style=color:#75715e>// true表示所有阶段结束</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-开发线程类>2. 开发线程类</h3><p><code>communication.PhaserTest$Hero</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PhaserTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 该类用于测试 Phaser 的一次性屏障 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Hero</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 英雄等级 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> heroLevel;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>Hero</span>(<span style=color:#66d9ef>int</span> heroLevel) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>heroLevel</span> <span style=color:#f92672>=</span> heroLevel;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 第1阶段，准备阶段 */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>ready</span>() {
</span></span><span style=display:flex><span>            TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(1L);
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; 就绪...&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 成功抵达当前阶段并且等待进入下一阶段，触发前进方法，此时phase为0</span>
</span></span><span style=display:flex><span>            phaser.<span style=color:#a6e22e>arriveAndAwaitAdvance</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* 第2阶段，只有英雄等级大于2的才能晋级 */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>levelOne</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (heroLevel <span style=color:#f92672>&gt;</span> 2) {
</span></span><span style=display:flex><span>                TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(1L);
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; 通过第1关...&#34;</span>);
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 成功抵达当前阶段并且等待进入下一阶段，触发前进方法，此时phase为1</span>
</span></span><span style=display:flex><span>                phaser.<span style=color:#a6e22e>arriveAndAwaitAdvance</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* 第3阶段，只有英雄等级大于4的才能晋级 */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>levelTwo</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (heroLevel <span style=color:#f92672>&gt;</span> 4) {
</span></span><span style=display:flex><span>                TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(1L);
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; 通过第2关...&#34;</span>);
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 成功抵达当前阶段并且等待进入下一阶段，触发前进方法，此时phase为2</span>
</span></span><span style=display:flex><span>                phaser.<span style=color:#a6e22e>arriveAndAwaitAdvance</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 淘汰的代码，即解除注册的代码只能写在最后一个阶段</span>
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; 淘汰...&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 成功抵达当前阶段并且从屏障组中注销，即淘汰某些英雄</span>
</span></span><span style=display:flex><span>            phaser.<span style=color:#a6e22e>arriveAndDeregister</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            ready();
</span></span><span style=display:flex><span>            levelOne();
</span></span><span style=display:flex><span>            levelTwo();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=3-测试phaser>3. 测试Phaser</h3><p><code>communication.PhaserTest.testPhaser()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PhaserTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testPhaser</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 指定初始注册线程数，await线程数量达到6时触发前进方法，即进入下一阶段</span>
</span></span><span style=display:flex><span>        phaser.<span style=color:#a6e22e>bulkRegister</span>(6);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建6个英雄线程</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(<span style=color:#66d9ef>new</span> Hero(1), <span style=color:#e6db74>&#34;蒙恬&#34;</span>).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(<span style=color:#66d9ef>new</span> Hero(2), <span style=color:#e6db74>&#34;娜可露露&#34;</span>).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(<span style=color:#66d9ef>new</span> Hero(3), <span style=color:#e6db74>&#34;杨戬&#34;</span>).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(<span style=color:#66d9ef>new</span> Hero(4), <span style=color:#e6db74>&#34;鲁班&#34;</span>).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(<span style=color:#66d9ef>new</span> Hero(5), <span style=color:#e6db74>&#34;后羿&#34;</span>).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(<span style=color:#66d9ef>new</span> Hero(6), <span style=color:#e6db74>&#34;安琪拉&#34;</span>).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 阻塞主线程  </span>
</span></span><span style=display:flex><span>		TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(10L);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=s07-多线程同步容器>S07. 多线程同步容器</h1><h2 id=e01-集合同步工具类>E01. 集合同步工具类</h2><blockquote><p>心法: <code>j.u.Collections</code></p></blockquote><ul><li>Collections工具类中提供了将异步的List，Map，Set转为同步的List，Map，Set的方法。</li><li>Collections同步的底层原理就是对整个添加，获取相关的操作方法添加大粒度的 <code>synchronized</code> 锁。</li></ul><table><thead><tr><th>相关API方法</th><th>描述</th></tr></thead><tbody><tr><td><code>Collections.synchronizedList(List&lt;T> list)</code></td><td>将异步List转为同步List</td></tr><tr><td><code>Collections.synchronizedMap(Map&lt;K, V> map)</code></td><td>将异步Map转为同步Map</td></tr><tr><td><code>Collections.synchronizedSet(Set&lt;T> set)</code></td><td>将异步Set转为同步Set</td></tr></tbody></table><blockquote><p>武技: 测试Collections常用API方法</p></blockquote><h3 id=1-synchronizedlist>1. synchronizedList</h3><p><code>collection.CollectionsTest.testSynchronizedList()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CollectionsTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testSynchronizedList</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将异步的ArrayList集合转换为同步的List集合</span>
</span></span><span style=display:flex><span>        List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> list <span style=color:#f92672>=</span> Collections.<span style=color:#a6e22e>synchronizedList</span>(<span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>());
</span></span><span style=display:flex><span>        list.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;赵四&#34;</span>);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(list.<span style=color:#a6e22e>get</span>(0));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-synchronizedmap>2. synchronizedMap</h3><p><code>collection.CollectionsTest.testSynchronizedMap()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CollectionsTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testSynchronizedMap</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将异步的HashMap集合转换为同步的Map集合</span>
</span></span><span style=display:flex><span>        Map<span style=color:#f92672>&lt;</span>String, Object<span style=color:#f92672>&gt;</span> map <span style=color:#f92672>=</span> Collections.<span style=color:#a6e22e>synchronizedMap</span>(<span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>(3));
</span></span><span style=display:flex><span>        map.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;name&#34;</span>, <span style=color:#e6db74>&#34;赵四&#34;</span>);
</span></span><span style=display:flex><span>        map.<span style=color:#a6e22e>forEach</span>((k, v) <span style=color:#f92672>-&gt;</span> System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(k <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;: &#34;</span> <span style=color:#f92672>+</span> v));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=3-synchronizedset>3. synchronizedSet</h3><p><code>collection.CollectionsTest.testSynchronizedSet()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CollectionsTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testSynchronizedSet</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将异步的HashSet集合转换为同步的Set集合</span>
</span></span><span style=display:flex><span>        Set<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> set <span style=color:#f92672>=</span> Collections.<span style=color:#a6e22e>synchronizedSet</span>(<span style=color:#66d9ef>new</span> HashSet<span style=color:#f92672>&lt;&gt;</span>());
</span></span><span style=display:flex><span>        set.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;赵四&#34;</span>);
</span></span><span style=display:flex><span>        set.<span style=color:#a6e22e>forEach</span>(System.<span style=color:#a6e22e>out</span>::println);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=e02-同步的list容器>E02. 同步的List容器</h2><blockquote><p>心法: 常用同步List</p></blockquote><table><thead><tr><th>实现</th><th>特点</th></tr></thead><tbody><tr><td><code>Vector</code></td><td>底层是可扩容缩容的数组，大部分操作方法都直接添加了 <code>synchronized</code> 锁，不推荐</td></tr><tr><td><code>CopyOnWriteArrayList</code></td><td>写时复制集合，初始容量为0，适用于读线程远多于写线程的场景写数据时: 加锁，复制原数组（原数组长度 + 1），将数据写入新数组并覆盖原数组，效率低读数据时: 不加锁，直接获取数据，效率高</td></tr></tbody></table><h3 id=1-vector>1. Vector</h3><blockquote><p>心法: Vector</p></blockquote><ul><li>Vector表示向量类或矢量类，底层是可扩容缩容的数组，大部分操作方法都直接添加了 <code>synchronized</code> 锁。</li></ul><blockquote><p>武技: 测试 Vector 常用API方法</p></blockquote><p><code>collection.VectorTest.testVector()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>VectorTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testVector</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建一个向量实例，初始容量5，默认是10</span>
</span></span><span style=display:flex><span>        Vector<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> vector <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Vector<span style=color:#f92672>&lt;&gt;</span>(5);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 添加</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(vector.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;赵四&#34;</span>) <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;赵四 追加成功&#34;</span> : <span style=color:#e6db74>&#34;赵四 追加失败&#34;</span>);
</span></span><span style=display:flex><span>        vector.<span style=color:#a6e22e>add</span>(0, <span style=color:#e6db74>&#34;刘能&#34;</span>);
</span></span><span style=display:flex><span>        vector.<span style=color:#a6e22e>add</span>(1, <span style=color:#e6db74>&#34;王云&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 查询</span>
</span></span><span style=display:flex><span>        vector.<span style=color:#a6e22e>forEach</span>(System.<span style=color:#a6e22e>out</span>::println);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;返回一号元素: &#34;</span> <span style=color:#f92672>+</span> vector.<span style=color:#a6e22e>get</span>(1));
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;返回初始容量: &#34;</span> <span style=color:#f92672>+</span> vector.<span style=color:#a6e22e>capacity</span>());
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;返回元素个数: &#34;</span> <span style=color:#f92672>+</span> vector.<span style=color:#a6e22e>size</span>());
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;返回王云位置: &#34;</span> <span style=color:#f92672>+</span> vector.<span style=color:#a6e22e>indexOf</span>(<span style=color:#e6db74>&#34;王云&#34;</span>));
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;返回首位元素: &#34;</span> <span style=color:#f92672>+</span> vector.<span style=color:#a6e22e>firstElement</span>());
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;返回末位元素: &#34;</span> <span style=color:#f92672>+</span> vector.<span style=color:#a6e22e>lastElement</span>());
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(vector.<span style=color:#a6e22e>contains</span>(<span style=color:#e6db74>&#34;王云&#34;</span>) <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;王云存在&#34;</span> : <span style=color:#e6db74>&#34;王云不存在&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 修改</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;将&#34;</span> <span style=color:#f92672>+</span> vector.<span style=color:#a6e22e>set</span>(1, <span style=color:#e6db74>&#34;长贵&#34;</span>) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;修改为&#34;</span> <span style=color:#f92672>+</span> vector.<span style=color:#a6e22e>get</span>(1));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 删除</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(vector.<span style=color:#a6e22e>removeElement</span>(<span style=color:#e6db74>&#34;刘能&#34;</span>) <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;刘能删除成功&#34;</span> : <span style=color:#e6db74>&#34;刘能删除失败&#34;</span>);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(vector.<span style=color:#a6e22e>remove</span>(0) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;删除成功&#34;</span>);
</span></span><span style=display:flex><span>        vector.<span style=color:#a6e22e>clear</span>();
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;全部元素删除完毕&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-copyonwritearraylist>2. CopyOnWriteArrayList</h3><blockquote><p>心法: CopyOnWriteArrayList</p></blockquote><ul><li>CopyOnWriteArrayList是写时复制集合，初始容量为0，适用于读线程远多于写线程的场景。</li><li>写数据时: 加锁，复制原数组（原数组长度 + 1），将数据写入新数组并覆盖原数组，效率低。</li><li>读数据时: 不加锁，直接获取数据，效率高。</li></ul><blockquote><p>武技: 测试 CopyOnWriteArrayList 常用API方法</p></blockquote><p><code>collection.CopyOnWriteArrayListTest.testCopyOnWriteArrayList()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CopyOnWriteArrayListTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testCopyOnWriteArrayList</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建写时复制List容器</span>
</span></span><span style=display:flex><span>        CopyOnWriteArrayList<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> copyOnWriteArrayList <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CopyOnWriteArrayList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// add方法是添加了 `synchronized` 锁的，更安全</span>
</span></span><span style=display:flex><span>        copyOnWriteArrayList.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;赵四&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// get方法是不添加 `synchronized` 锁的，更效率</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(copyOnWriteArrayList.<span style=color:#a6e22e>get</span>(0));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=e03-同步的map容器>E03. 同步的Map容器</h2><blockquote><p>心法: 常用同步Map</p></blockquote><table><thead><tr><th>实现</th><th>特点</th></tr></thead><tbody><tr><td><code>HashTable</code></td><td>大部分操作方法都直接添加了 <code>synchronized</code> 锁，不推荐不支持null值</td></tr><tr><td><code>ConcurrentHashMap</code></td><td>底层维护了一个Node数组，默认长度16，key和value都不允许null值发生哈希冲突时执行拉链法，链表节点超过8进行树化，树节点少于6退化为链表</td></tr><tr><td><code>ConcurrentSkipListMap</code></td><td>底层使用跳表结构，高并发情况下寻找元素效率更高，且支持排序</td></tr></tbody></table><h3 id=1-hashtable>1. HashTable</h3><blockquote><p>心法: HashTable</p></blockquote><ul><li>HashTable中的大部分方法都是线程同步的，不支持null值，其余和HashMap类似。</li></ul><blockquote><p>武技: 测试 HashTable 常用API方法</p></blockquote><p><code>collection.HashTableTest.testHashtable()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HashTableTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testHashtable</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建HashTable集合，初始容量为10，默认11</span>
</span></span><span style=display:flex><span>        Hashtable<span style=color:#f92672>&lt;</span>String, Object<span style=color:#f92672>&gt;</span> map <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Hashtable<span style=color:#f92672>&lt;&gt;</span>(10);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 添加: key值为null时直接抛异常</span>
</span></span><span style=display:flex><span>        map.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;name&#34;</span>, <span style=color:#e6db74>&#34;赵四&#34;</span>);
</span></span><span style=display:flex><span>        map.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;gender&#34;</span>, 1);
</span></span><span style=display:flex><span>        map.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;age&#34;</span>, 58);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 查询</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;元素个数: &#34;</span> <span style=color:#f92672>+</span> map.<span style=color:#a6e22e>size</span>());
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;获取name值 &#34;</span> <span style=color:#f92672>+</span> map.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;name&#34;</span>));
</span></span><span style=display:flex><span>        map.<span style=color:#a6e22e>forEach</span>((k, v) <span style=color:#f92672>-&gt;</span> System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(k <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;: &#34;</span> <span style=color:#f92672>+</span> v));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 删除</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;删除&#34;</span> <span style=color:#f92672>+</span> map.<span style=color:#a6e22e>remove</span>(<span style=color:#e6db74>&#34;name&#34;</span>) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;成功&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-concurrenthashmap>2. ConcurrentHashMap</h3><blockquote><p>心法: ConcurrentHashMap</p></blockquote><ul><li>ConcurrentHashMap底层维护了一个Node数组，默认长度16，key和value都不允许null值。</li><li><a href=res/ConcurrentHashMap%E6%BA%90%E7%A0%81.md>ConcurrentHashMap源码解读</a></li></ul><table><thead><tr><th>相关操作</th><th>描述</th></tr></thead><tbody><tr><td>添加元素</td><td>根据 <code>hash(key)</code> 的值定位到Entry数组的具体位置，使用CAS方式添加元素</td></tr><tr><td>获取元素</td><td>根据 <code>hash(key)</code> 的值定位到Entry数组的具体位置，直接获取元素</td></tr><tr><td>哈希冲突</td><td>在冲突位置形成链表，新Entry尾部插入数据，全过程加锁</td></tr><tr><td>链表变形</td><td>当Entry数组某位置上的链表长度大于8时，会转换成红黑树结构以提高操作效率当Entry数组某位置上的红黑树节点数量小于等于6时，会退化成链表结构以提高操作效率</td></tr></tbody></table><blockquote><p>武技: 测试 ConcurrentHashMap 常用API方法</p></blockquote><p><code>collection.ConcurrentHashMapTest.testConcurrentHashMap()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ConcurrentHashMapTest</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testConcurrentHashMap</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建ConcurrentHashMap实例，初始容量为3，默认16</span>
</span></span><span style=display:flex><span>        ConcurrentHashMap<span style=color:#f92672>&lt;</span>String, Object<span style=color:#f92672>&gt;</span> concurrentHashMap <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ConcurrentHashMap<span style=color:#f92672>&lt;&gt;</span>(3);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 存储键值对</span>
</span></span><span style=display:flex><span>        concurrentHashMap.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;name&#34;</span>, <span style=color:#e6db74>&#34;赵四&#34;</span>);
</span></span><span style=display:flex><span>        concurrentHashMap.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;age&#34;</span>, <span style=color:#e6db74>&#34;48&#34;</span>);
</span></span><span style=display:flex><span>        concurrentHashMap.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;gender&#34;</span>, <span style=color:#e6db74>&#34;男&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取值</span>
</span></span><span style=display:flex><span>        concurrentHashMap.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;name&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 遍历</span>
</span></span><span style=display:flex><span>        concurrentHashMap.<span style=color:#a6e22e>forEach</span>((k, v) <span style=color:#f92672>-&gt;</span> System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(k <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;: &#34;</span> <span style=color:#f92672>+</span> v));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=3-concurrentskiplistmap>3. ConcurrentSkipListMap</h3><blockquote><p>心法: ConcurrentSkipListMap</p></blockquote><ul><li>ConcurrentSkipListMap底层使用跳表结构，高并发情况下寻找元素效率更高，且支持排序。</li></ul><blockquote><p>武技: 测试ConcurrentSkipListMap常用API方法</p></blockquote><p><code>collection.ConcurrentSkipListMapTest.testConcurrentSkipListMap()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ConcurrentSkipListMapTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testConcurrentSkipListMap</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建ConcurrentSkipListMap实例</span>
</span></span><span style=display:flex><span>        ConcurrentSkipListMap<span style=color:#f92672>&lt;</span>Object, Object<span style=color:#f92672>&gt;</span> concurrentSkipListMap <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ConcurrentSkipListMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 存储数据</span>
</span></span><span style=display:flex><span>        concurrentSkipListMap.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;name&#34;</span>, <span style=color:#e6db74>&#34;赵四&#34;</span>);
</span></span><span style=display:flex><span>        concurrentSkipListMap.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;gender&#34;</span>, <span style=color:#e6db74>&#34;male&#34;</span>);
</span></span><span style=display:flex><span>        concurrentSkipListMap.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;age&#34;</span>, 58);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取数据</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(concurrentSkipListMap.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;age&#34;</span>));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 遍历数据</span>
</span></span><span style=display:flex><span>        concurrentSkipListMap.<span style=color:#a6e22e>forEach</span>((k, v) <span style=color:#f92672>-&gt;</span> System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(k <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;: &#34;</span> <span style=color:#f92672>+</span> v));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=e04-同步queue容器>E04. 同步Queue容器</h2><blockquote><p>心法: 常用同步Queue</p></blockquote><table><thead><tr><th>实现类</th><th>底层结构</th><th>是否支持阻塞</th><th>安全方式</th></tr></thead><tbody><tr><td><code>ConcurrentLinkedQueue</code></td><td>单链表</td><td>不支持阻塞</td><td>入队CAS，出队CAS</td></tr><tr><td><code>LinkedBlockingQueue</code></td><td>单链表</td><td>支持阻塞</td><td>入队一把锁，出队一把锁</td></tr><tr><td><code>LinkedBlockingDeque</code></td><td>双链表</td><td>支持阻塞</td><td>出入均使用可重入锁</td></tr><tr><td><code>ArrayBlockingQueue</code></td><td>数组</td><td>支持阻塞</td><td>出入均使用可重入锁</td></tr><tr><td><code>SynchronousQueue</code></td><td>无</td><td>支持阻塞</td><td>无需出队时，数据不入队</td></tr><tr><td><code>LinkedTransferQueue</code></td><td>单链表</td><td>支持阻塞</td><td>预先占位，自己领取自己的数据</td></tr><tr><td><code>DelayQueue</code></td><td>数组</td><td>支持阻塞</td><td>出入均使用可重入锁</td></tr></tbody></table><h3 id=1-concurrentlinkedqueue>1. ConcurrentLinkedQueue</h3><blockquote><p>心法: ConcurrentLinkedQueue，单链表，不阻塞</p></blockquote><ul><li>ConcurrentLinkedQueue的入队和出队均采用CAS操作以提高并发效率。</li></ul><table><thead><tr><th>相关API方法</th><th>描述</th></tr></thead><tbody><tr><td><code>queue.add(E)</code></td><td>使用CAS的方式，将指定元素添加到队列头</td></tr><tr><td><code>queue.poll()</code></td><td>使用CAS的方式，弹出队列头元素，若为队列为空直接返回null值</td></tr><tr><td><code>queue.peek()</code></td><td>使用CAS的方式，查看队列头元素，若为队列为空直接返回null值</td></tr></tbody></table><p>![[第1阶段-BASIC/JB1-7-并发编程/excalidraw/ConcurrentLinkedQueue原理.md#^group=2ARH-AwCoohE2HXRgwN3y|100%]]</p><blockquote><p>武技: 测试ConcurrentLinkedQueue常用API方法</p></blockquote><p><code>collection.ConcurrentLinkedQueueTest.testConcurrentLinkedQueue()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ConcurrentLinkedQueueTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@SneakyThrows</span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@Test</span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testConcurrentLinkedQueue</span>() {  
</span></span><span style=display:flex><span>	  
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// 创建ConcurrentLinkedQueue实例  </span>
</span></span><span style=display:flex><span>	    ConcurrentLinkedQueue<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> concurrentLinkedQueue <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ConcurrentLinkedQueue<span style=color:#f92672>&lt;&gt;</span>();  
</span></span><span style=display:flex><span>	  
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// 写  </span>
</span></span><span style=display:flex><span>	    concurrentLinkedQueue.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;赵四&#34;</span>);  
</span></span><span style=display:flex><span>	    concurrentLinkedQueue.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;刘能&#34;</span>);  
</span></span><span style=display:flex><span>	  
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// 读  </span>
</span></span><span style=display:flex><span>	    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;查看队列头: &#34;</span> <span style=color:#f92672>+</span> concurrentLinkedQueue.<span style=color:#a6e22e>peek</span>());  
</span></span><span style=display:flex><span>	    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;弹出队列头: &#34;</span> <span style=color:#f92672>+</span> concurrentLinkedQueue.<span style=color:#a6e22e>poll</span>());  
</span></span><span style=display:flex><span>	    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;删除队列头: &#34;</span> <span style=color:#f92672>+</span> concurrentLinkedQueue.<span style=color:#a6e22e>remove</span>(<span style=color:#e6db74>&#34;刘能&#34;</span>));  
</span></span><span style=display:flex><span>	    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;弹出队列头: &#34;</span> <span style=color:#f92672>+</span> concurrentLinkedQueue.<span style=color:#a6e22e>poll</span>());  
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-linkedblockingqueue>2. LinkedBlockingQueue</h3><blockquote><p>心法: LinkedBlockingQueue，单链表，阻塞</p></blockquote><ul><li>LinkedBlockingQueue的读操作和写操作分别使用不同的可重入锁，提升效率。</li><li>LinkedBlockingQueue在创建时建议指定队列容量，默认为int最大值，过大不推荐。</li></ul><table><thead><tr><th>相关API方法</th><th>描述</th></tr></thead><tbody><tr><td><code>queue.put(E)</code></td><td>获取 <code>putLock</code> 锁，然后将指定元素添加到队列头</td></tr><tr><td><code>queue.take()</code></td><td>获取 <code>takeLock</code> 锁，弹出队列头元素，若为队列为空则阻塞等待</td></tr><tr><td><code>queue.peek()</code></td><td>获取 <code>takeLock</code> 锁，查看队列头元素，若为队列为空则阻塞等待</td></tr><tr><td><code>queue.poll()</code></td><td>获取 <code>takeLock</code> 锁，弹出队列头元素，若为队列为空直接返回null值</td></tr></tbody></table><p>![[第1阶段-BASIC/JB1-7-并发编程/excalidraw/LinkedBlockingQueue原理.md#^group=2ARH-AwCoohE2HXRgwN3y|100%]]</p><blockquote><p>武技: LinkedBlockingQueue常用API方法</p></blockquote><p><code>collection.LinkedBlockingQueueTest.testLinkedBlockingQueue()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LinkedBlockingQueueTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@Test</span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testLinkedBlockingQueue</span>() {  
</span></span><span style=display:flex><span>	  
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// 创建LinkedBlockingQueue实例: 建议指定队列容量，默认为int最大值，过大不推荐  </span>
</span></span><span style=display:flex><span>	    LinkedBlockingQueue<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> linkedBlockingQueue <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LinkedBlockingQueue<span style=color:#f92672>&lt;&gt;</span>(5);  
</span></span><span style=display:flex><span>	  
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// 写  </span>
</span></span><span style=display:flex><span>	    linkedBlockingQueue.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;赵四&#34;</span>);  
</span></span><span style=display:flex><span>	  
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// 读  </span>
</span></span><span style=display:flex><span>	    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;查看队列头: &#34;</span> <span style=color:#f92672>+</span> linkedBlockingQueue.<span style=color:#a6e22e>peek</span>());  
</span></span><span style=display:flex><span>	    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;弹出队列头（非阻塞）: &#34;</span> <span style=color:#f92672>+</span> linkedBlockingQueue.<span style=color:#a6e22e>poll</span>());  
</span></span><span style=display:flex><span>	    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;弹出队列头（阻塞）: &#34;</span> <span style=color:#f92672>+</span> linkedBlockingQueue.<span style=color:#a6e22e>take</span>());  
</span></span><span style=display:flex><span>	    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;主线程退出&#34;</span>);  
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=3-linkedblockingdeque>3. LinkedBlockingDeque</h3><blockquote><p>心法: LinkedBlockingDeque，双链表，阻塞</p></blockquote><ul><li>LinkedBlockingDeque头尾皆可操作，多线程环境下可减少一半的竞争。</li><li>LinkedBlockingDeque在创建时建议指定队列容量，默认为int最大值，过大不推荐。</li></ul><table><thead><tr><th>相关API方法</th><th>描述</th></tr></thead><tbody><tr><td><code>queue.addFirst(E)</code></td><td>获取可重入锁，然后将指定元素添加到队列头</td></tr><tr><td><code>queue.addLast(E)</code></td><td>获取可重入锁，然后将指定元素添加到队列尾</td></tr><tr><td><code>queue.takeFirst()</code></td><td>获取可重入锁，然后弹出队列头元素，若为队列为空则阻塞等待</td></tr><tr><td><code>queue.takeLast()</code></td><td>获取可重入锁，然后弹出队列头元素，若为队列为空则阻塞等待</td></tr><tr><td><code>queue.pollFirst()</code></td><td>获取可重入锁，然后弹出队列头元素，若为队列为空则直接返回null</td></tr><tr><td><code>queue.pollLast()</code></td><td>获取可重入锁，然后弹出队列尾元素，若为队列为空则直接返回null</td></tr></tbody></table><p>![[第1阶段-BASIC/JB1-7-并发编程/excalidraw/LinkedBlockingDeque原理.md#^group=2ARH-AwCoohE2HXRgwN3y|100%]]</p><blockquote><p>武技: 测试LinkedBlockingDeque常用API方法</p></blockquote><p><code>collection.LinkedBlockingDequeTest.testLinkedBlockingDeque()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LinkedBlockingDequeTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@Test</span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testLinkedBlockingDeque</span>() <span style=color:#66d9ef>throws</span> InterruptedException {  
</span></span><span style=display:flex><span>	  
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// 创建一个LinkedBlockingDeque实例: 建议指定队列容量，默认为int最大值，过大不推荐  </span>
</span></span><span style=display:flex><span>	    LinkedBlockingDeque<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> linkedBlockingDeque <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LinkedBlockingDeque<span style=color:#f92672>&lt;&gt;</span>(5);  
</span></span><span style=display:flex><span>	  
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// 写  </span>
</span></span><span style=display:flex><span>	    linkedBlockingDeque.<span style=color:#a6e22e>addFirst</span>(<span style=color:#e6db74>&#34;赵四&#34;</span>);  
</span></span><span style=display:flex><span>	    linkedBlockingDeque.<span style=color:#a6e22e>addFirst</span>(<span style=color:#e6db74>&#34;刘能&#34;</span>);  
</span></span><span style=display:flex><span>	    linkedBlockingDeque.<span style=color:#a6e22e>addLast</span>(<span style=color:#e6db74>&#34;广坤&#34;</span>);  
</span></span><span style=display:flex><span>	  
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// 读  </span>
</span></span><span style=display:flex><span>	    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;查看队列头: &#34;</span> <span style=color:#f92672>+</span> linkedBlockingDeque.<span style=color:#a6e22e>peekFirst</span>());  
</span></span><span style=display:flex><span>	    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;查看队列尾: &#34;</span> <span style=color:#f92672>+</span> linkedBlockingDeque.<span style=color:#a6e22e>peekLast</span>());  
</span></span><span style=display:flex><span>	    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;弹出队列头（非阻塞）: &#34;</span> <span style=color:#f92672>+</span> linkedBlockingDeque.<span style=color:#a6e22e>pollFirst</span>());  
</span></span><span style=display:flex><span>	    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;弹出队列尾（非阻塞）: &#34;</span> <span style=color:#f92672>+</span> linkedBlockingDeque.<span style=color:#a6e22e>pollLast</span>());  
</span></span><span style=display:flex><span>	    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;弹出队列头（阻塞）: &#34;</span> <span style=color:#f92672>+</span> linkedBlockingDeque.<span style=color:#a6e22e>takeFirst</span>());  
</span></span><span style=display:flex><span>	    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;弹出队列尾（阻塞）: &#34;</span> <span style=color:#f92672>+</span> linkedBlockingDeque.<span style=color:#a6e22e>takeLast</span>());  
</span></span><span style=display:flex><span>	    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;主线程退出&#34;</span>);  
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=4-arrayblockingqueue>4. ArrayBlockingQueue</h3><blockquote><p>心法: ArrayBlockingQueue，数组，阻塞</p></blockquote><ul><li>ArrayBlockingQueue在创建时必须指定队列容量，且这个容量值永远固定不变。</li></ul><table><thead><tr><th>相关API方法</th><th>描述</th></tr></thead><tbody><tr><td><code>queue.put(E)</code></td><td>获取可重入锁，然后将指定元素添加到队列头，队列满时阻塞</td></tr><tr><td><code>queue.add(E)</code></td><td>获取可重入锁，然后将指定元素添加到队列头，队列满时抛出异常</td></tr><tr><td><code>queue.take()</code></td><td>获取可重入锁，然后弹出队列头元素，若为队列为空则阻塞等待</td></tr><tr><td><code>queue.poll()</code></td><td>获取可重入锁，然后弹出队列头元素，若为队列为空则直接返回null</td></tr></tbody></table><p>![[第1阶段-BASIC/JB1-7-并发编程/excalidraw/ArrayBlockingQueue原理.md#^group=2ARH-AwCoohE2HXRgwN3y|100%]]</p><blockquote><p>武技: 测试ArrayBlockingQueue常用API方法</p></blockquote><p><code>collection.ArrayBlockingQueueTest.testArrayBlockingQueue()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ArrayBlockingQueueTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testArrayBlockingQueue</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建一个ArrayBlockingQueue实例: 必须指定队列容量，且这个容量值永远固定不变</span>
</span></span><span style=display:flex><span>        ArrayBlockingQueue<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> arrayBlockingQueue <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayBlockingQueue<span style=color:#f92672>&lt;&gt;</span>(10);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 向队列中添加10个数据，塞满整个队列</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 10; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            arrayBlockingQueue.<span style=color:#a6e22e>put</span>(i);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;当前队列容量: &#34;</span> <span style=color:#f92672>+</span> arrayBlockingQueue.<span style=color:#a6e22e>size</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 子线程作为消费者：3s后从队列中取出一个值</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(3L);
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;子线程消费了: &#34;</span> <span style=color:#f92672>+</span> arrayBlockingQueue.<span style=color:#a6e22e>take</span>());
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }, <span style=color:#e6db74>&#34;消费者&#34;</span>).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 主线程作为生产者：因队列满了，所以阻塞生产者并等待其他消费者</span>
</span></span><span style=display:flex><span>        arrayBlockingQueue.<span style=color:#a6e22e>put</span>(250);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;生产者生产数据: 250&#34;</span>);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(arrayBlockingQueue);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 阻止主线程</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(10L);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=5-synchronousqueue>5. SynchronousQueue</h3><blockquote><p>心法: SynchronousQueue，同步交换，阻塞</p></blockquote><ul><li>SynchronousQueue没有容量，无法直接存储数据，它要求仅在有消费者想要消费时，生产者才准许生产。</li><li>SynchronousQueue主要用来向其他线程传递数据，是 <code>Exchanger</code> 的底层结构。</li></ul><table><thead><tr><th>相关API方法</th><th>描述</th></tr></thead><tbody><tr><td><code>queue.put(E)</code></td><td>当且仅当有人获取数据时，才将指定元素添加到队列头，队列满时阻塞</td></tr><tr><td><code>queue.add(E)</code></td><td>当且仅当有人获取数据时，将指定元素添加到队列头，队列满时抛出异常</td></tr><tr><td><code>queue.take()</code></td><td>弹出队列头元素，若为队列为空则阻塞等待</td></tr><tr><td><code>queue.poll()</code></td><td>弹出队列头元素，若为队列为空则直接返回null</td></tr></tbody></table><p>![[第1阶段-BASIC/JB1-7-并发编程/excalidraw/SynchronousQueue原理.md#^group=2ARH-AwCoohE2HXRgwN3y|100%]]</p><blockquote><p>武技: SynchronousQueue常用API方法</p></blockquote><p><code>collection.SynchronousQueueTest.testSynchronousQueue()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SynchronousQueueTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testSynchronousQueue</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建一个SynchronousQueue实例: 没有容量，无法直接存储数据</span>
</span></span><span style=display:flex><span>        SynchronousQueue<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> synchronousQueue <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SynchronousQueue<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 初始容量一定为0        // 创建一个消费者线程并启动</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;当前队列容量: &#34;</span> <span style=color:#f92672>+</span> synchronousQueue.<span style=color:#a6e22e>size</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;消费者睡眠中&#34;</span>);
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 两秒后，消费者消费数据</span>
</span></span><span style=display:flex><span>                TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(2L);
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;消费者消费数据: &#34;</span> <span style=color:#f92672>+</span> synchronousQueue.<span style=color:#a6e22e>take</span>());
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }, <span style=color:#e6db74>&#34;消费者&#34;</span>).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 使用主线程作为生产者</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;生产者阻塞中&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 生产者的 put() 方法会一直阻塞，直到到消费者调用了 take() 方法</span>
</span></span><span style=display:flex><span>        synchronousQueue.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;消息01&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;生产者生产数据完毕&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 此时队列容量仍然为0</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;当前队列容量: &#34;</span> <span style=color:#f92672>+</span> synchronousQueue.<span style=color:#a6e22e>size</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 主线程睡眠</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(10L);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=6-linkedtransferqueue>6. LinkedTransferQueue</h3><blockquote><p>心法: LinkedTransferQueue，单链表，预先占位</p></blockquote><ul><li>当消费者想要从队列中获取数据时：<ul><li>若队列不为空，则直接拿走数据。</li><li>若队列为空，则入队一个null值节点占位（预消费），然后让消费者在该节点上阻塞等待。</li></ul></li><li>当生产者在生产数据时：<ul><li>若队列中存在null值节点，则将数据直接填充到该节点，并唤醒该节点上的消费者，让它拿走数据。</li><li>若队列中不存在null值节点，则创建一个新节点，填充数据，并入队。</li></ul></li><li>LinkedTransferQueue整个的存取过程，都是相互隔离的，自己领取自己的数据，无争抢，以保证线程安全。</li></ul><table><thead><tr><th>相关API方法</th><th>描述</th></tr></thead><tbody><tr><td><code>queue.put(E)</code></td><td>将指定元素添加到队列头，队列满时阻塞若队列中不存在null节点，则创建新节点，并将数据填充到新节点若队列中已存在null节点，则将数据填充到该节点，并唤醒该节点上等待的线程</td></tr><tr><td><code>queue.add(E)</code></td><td>将指定元素添加到队列头，队列满时抛出异常若队列中不存在null节点，则创建新节点，并将数据填充到新节点若队列中已存在null节点，则将数据填充到该节点，并唤醒该节点上等待的线程</td></tr><tr><td><code>queue.take()</code></td><td>弹出队列头元素，若为队列为空则阻塞等待</td></tr><tr><td><code>queue.poll()</code></td><td>弹出队列头元素，若为队列为空则直接返回null</td></tr></tbody></table><p>![[第1阶段-BASIC/JB1-7-并发编程/excalidraw/LinkedTransferQueue原理.md#^group=2ARH-AwCoohE2HXRgwN3y|100%]]</p><blockquote><p>武技: 测试LinkedTransferQueue常用API方法</p></blockquote><p><code>collection.LinkedTransferQueueTest.testLinkedTransferQueue()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LinkedTransferQueueTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testLinkedTransferQueue</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建一个LinkedTransferQueue实例</span>
</span></span><span style=display:flex><span>        LinkedTransferQueue<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> linkedTransferQueue <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LinkedTransferQueue<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;0s: 主线程创建2个子线程并启动&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建并启动一个消费者线程</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;0s: 消费者线程意图消费数据，发现队列中无数据&#34;</span>);
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;0s: 消费者线程入队一个null值节点，并在该节点上等待&#34;</span>);
</span></span><span style=display:flex><span>                String message <span style=color:#f92672>=</span> linkedTransferQueue.<span style=color:#a6e22e>take</span>();
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;3s: 消费者线程获取到消息 -&gt; &#34;</span> <span style=color:#f92672>+</span> message);
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;3s: 消费者线程退出&#34;</span>);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        },<span style=color:#e6db74>&#34;消费者&#34;</span>).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建并启动一个生产者线程</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(3L);
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;3s: 生产者线程意图生产数据，发现队列中存在null值节点&#34;</span>);
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;3s: 生产者线程将数据填充到null值节点，并唤醒该节点上等待的线程&#34;</span>);
</span></span><span style=display:flex><span>                linkedTransferQueue.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;hello&#34;</span>);
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;3s: 生产者线程退出&#34;</span>);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        },<span style=color:#e6db74>&#34;生产者&#34;</span>).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 阻塞junit线程</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(9L);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;9s: 主线程退出&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=7-delayqueue>7. DelayQueue</h3><blockquote><p>心法: DelayQueue，延迟队列</p></blockquote><ul><li>DelayQueue是一个可以指定延迟时间的队列，底层是数组，初始默认容量11。</li><li>DelayQueue内部可以根据指定的延迟时间进行排序调度，比如指定任务A在3秒后执行，任务B在5秒后执行。</li><li>DelayQueue仅支持存储Delayed接口的实现类：<ul><li>需要重写 <code>long getDelay(TimeUnit unit)</code> 方法，该方法负责根据时间单位来获取延时间值。</li><li>需要重写 <code>int compareTo(Delayed o)</code> 方法，该方法负责根据延迟时间值进行比较和排序。</li></ul></li></ul><table><thead><tr><th>相关API方法</th><th>描述</th></tr></thead><tbody><tr><td><code>queue.put(E)</code></td><td>将指定元素添加到队列头，队列满时阻塞</td></tr><tr><td><code>queue.add(E)</code></td><td>将指定元素添加到队列头，队列满时抛出异常</td></tr><tr><td><code>queue.take()</code></td><td>弹出队列头元素，若为队列为空则阻塞等待</td></tr><tr><td><code>queue.poll()</code></td><td>弹出队列头元素，若为队列为空则直接返回null</td></tr><tr><td>![[第1阶段-BASIC/JB1-7-并发编程/excalidraw/DelayQueue原理.md#^group=2ARH-AwCoohE2HXRgwN3y</td><td>100%]]</td></tr></tbody></table><blockquote><p>武技: 测试DelayQueue常用API方法</p></blockquote><p><code>collection.DelayQueueTest.testDelayQueue()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DelayQueueTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 本类用于测试delayQueue的任务类 */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Data</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyTask</span> <span style=color:#66d9ef>implements</span> Delayed {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 任务的名称 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> String taskName;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 延迟时间戳 */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Long timestamp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        MyTask(String taskName, Long timestamp) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>taskName</span> <span style=color:#f92672>=</span> taskName;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>timestamp</span> <span style=color:#f92672>=</span> timestamp;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 负责根据时间单位来获取延迟的值
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @param unit 时间单位
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @return 延迟的毫秒数
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>getDelay</span>(TimeUnit unit) {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// 延迟的毫秒数 = 调用方传入的时间戳 - 当前时间戳  </span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 以毫秒为单位，将 param1 转为long值</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> unit.<span style=color:#a6e22e>convert</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>timestamp</span> <span style=color:#f92672>-</span> System.<span style=color:#a6e22e>currentTimeMillis</span>(), TimeUnit.<span style=color:#a6e22e>MILLISECONDS</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 根据延迟的值来进行比较和排序
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @param o 调用方传入的延迟时间
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * @return 若返回正数则正序，返回负数则倒序，返回0则不排序
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>compareTo</span>(Delayed o) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 比较当前Delayed实例的延迟毫秒数和下一个Delayed实例的延迟毫秒数</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Long.compare(): 比较两个Long型值，返回1/0/-1三种结果</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Long.<span style=color:#a6e22e>compare</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>getDelay</span>(TimeUnit.<span style=color:#a6e22e>MILLISECONDS</span>), o.<span style=color:#a6e22e>getDelay</span>(TimeUnit.<span style=color:#a6e22e>MILLISECONDS</span>));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testDelayQueue</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建一个DelayQueue实例</span>
</span></span><span style=display:flex><span>        DelayQueue<span style=color:#f92672>&lt;</span>MyTask<span style=color:#f92672>&gt;</span> delayQueue <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> DelayQueue<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> now <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>currentTimeMillis</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 内部自动根据延迟毫秒数排序</span>
</span></span><span style=display:flex><span>        delayQueue.<span style=color:#a6e22e>put</span>(<span style=color:#66d9ef>new</span> MyTask(<span style=color:#e6db74>&#34;任务01&#34;</span>, now <span style=color:#f92672>+</span> 3L));
</span></span><span style=display:flex><span>        delayQueue.<span style=color:#a6e22e>put</span>(<span style=color:#66d9ef>new</span> MyTask(<span style=color:#e6db74>&#34;任务04&#34;</span>, now <span style=color:#f92672>+</span> 1L));
</span></span><span style=display:flex><span>        delayQueue.<span style=color:#a6e22e>put</span>(<span style=color:#66d9ef>new</span> MyTask(<span style=color:#e6db74>&#34;任务05&#34;</span>, now <span style=color:#f92672>+</span> 2L));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 取出队列中的三个值，观察是否排序</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0, j <span style=color:#f92672>=</span> delayQueue.<span style=color:#a6e22e>size</span>(); i <span style=color:#f92672>&lt;</span> j; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;take: &#34;</span> <span style=color:#f92672>+</span> delayQueue.<span style=color:#a6e22e>take</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=s08-线程池使用方案>S08. 线程池使用方案</h1><h2 id=e01-线程池基础概念>E01. 线程池基础概念</h2><h3 id=1-线程池使用场景>1. 线程池使用场景</h3><blockquote><p>心法: 为何使用线程池</p></blockquote><ul><li>一般情况下，一个请求需要至少开启一个线程来执行具体的请求内容。</li><li>若请求数量特别多，且请求内容处理的时间非常短，则会造成频繁的创建和销毁线程的过程，系统开销大。</li><li>此时建议使用线程池来解决该问题。</li></ul><blockquote><p>心法: 阿里巴巴规约中的线程池</p></blockquote><ul><li>阿里巴巴Java开发手册中指出，线程资源必须通过线程池提供，不允许在应用中自行显示的创建线程。</li><li>一方面是线程的创建更加规范，可以合理控制开辟线程的数量。</li><li>一方面线程的细节管理交给线程池处理，优化了资源的开销。</li></ul><h3 id=2-线程池优点缺点>2. 线程池优点缺点</h3><blockquote><p>心法: 线程池优点</p></blockquote><ol><li>线程池可以维护多个线程的生命周期。</li><li>线程池可以通过线程复用来提高线程的利用率。</li><li>线程池可以提前创建好一批线程，在请求到达时线程直接获取，避免了线程的频繁创建和销毁。</li><li>线程池中可以适当地调整线程数，以对请求进行限流，从而可以防止资源不足。</li></ol><blockquote><p>心法: 线程池缺点</p></blockquote><ol><li>线程池本身也是需要维护的，当线程数量特别少，或者执行时间特别长的时候，不建议使用。</li><li>线程池容易遭受的并发风险，比如同步错误，与池有关的死锁，资源不足和线程泄漏。</li></ol><h2 id=e02-线程池使用流程>E02. 线程池使用流程</h2><blockquote><p>心法: 如何使用线程池</p></blockquote><ol><li>创建一个线程池，并进行基础的配置:<ul><li>可以通过 <code>ThreadPoolExecutor</code> 类来创建，推荐。</li><li>可以通过 <code>Executors</code> 类来创建，是前者的上层封装，不灵活，不推荐。</li></ul></li><li>将 <code>Runnable</code> 或 <code>Callable</code> 线程任务提交到线程池中：<ol><li>Runnable函数式线程接口，内部仅包含一个 <code>run()</code> 方法，无返回，不抛出异常。</li><li>Callable函数式线程接口，内部仅包含一个 <code>call()</code> 方法，有返回，抛出 <code>Exception</code> 异常。</li></ol></li><li>线程池自动为该任务分配线程并负责该线程从启动，运行到销毁的全部生命周期活动。</li></ol><table><thead><tr><th>相关API方法</th><th>描述</th></tr></thead><tbody><tr><td><code>threadPool.execute(线程任务)</code></td><td>提交Runnable任务到线程池，无返回值不支持提交Runnable任务该提交过程不阻塞当前所在线程</td></tr><tr><td><code>threadPool.submit(线程任务)</code></td><td>提交Runnable任务到线程池，返回一个 <code>Future&lt;?></code> 实例，实例中数据为空提交Callable任务到线程池，返回一个 <code>Future&lt;返回值类型></code> 实例该提交过程不阻塞当前所在线程</td></tr></tbody></table><h3 id=1-runnable线程任务>1. Runnable线程任务</h3><blockquote><p>心法: Runnable和线程池配合使用流程</p></blockquote><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR

n1[&#34;创建&lt;br/&gt;Runnable任务&#34;]
n1 --&gt; n2[&#34;创建&lt;br/&gt;线程池&#34;]
n2 --&gt; n3[&#34;将Runnable任务&lt;br/&gt;提交到线程池&#34;] -.- n3a[&#34;该过程&lt;br/&gt;不阻塞&#34;]
n3 --&gt; n4[&#34;线程池分配线程&lt;br/&gt;执行Runnable任务&#34;] -.- n4a[&#34;该过程&lt;br/&gt;不阻塞&#34;]
</code></pre><blockquote><p>武技: 测试将Runnable任务提交到线程池</p></blockquote><p><code>pool.RunnableThreadPoolTest.testExecute()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RunnableThreadPoolTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testExecute</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建一个可缓存的线程池</span>
</span></span><span style=display:flex><span>        ExecutorService threadPool <span style=color:#f92672>=</span> Executors.<span style=color:#a6e22e>newCachedThreadPool</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;0s: 线程池创建完毕&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建一个Runnable任务</span>
</span></span><span style=display:flex><span>        Runnable runnableTask <span style=color:#f92672>=</span> () <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;0s: runnable任务睡眠&#34;</span>);
</span></span><span style=display:flex><span>                TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(2L);
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;2s: runnable任务执行完毕&#34;</span>);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(e);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将Runnable任务异步提交到线程池中，该方法不会阻塞主线程</span>
</span></span><span style=display:flex><span>        threadPool.<span style=color:#a6e22e>execute</span>(runnableTask);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;0s: 若我立刻输出，则证明 execute 方法不阻塞主线程&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 不再新增线程，发出停止信号，等所有线程执行完毕，关闭线程池，节省资源</span>
</span></span><span style=display:flex><span>        threadPool.<span style=color:#a6e22e>shutdown</span>();
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;2s: 关闭线程池&#34;</span>);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;2s: 主线程退出&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-callable线程任务>2. Callable线程任务</h3><blockquote><p>心法: Callable和线程池配合使用流程</p></blockquote><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR

n1[&#34;创建&lt;br/&gt;Callable任务&#34;]
n1 --&gt; n2[&#34;创建&lt;br/&gt;线程池&#34;]
n2 --&gt; n3[&#34;将Callable任务&lt;br/&gt;提交到线程池&#34;] -.- n3a[&#34;该过程&lt;br/&gt;不阻塞&#34;]
n3 --&gt; n4[&#34;线程池分配线程&lt;br/&gt;执行Callable任务&#34;] -.- n4a[&#34;该过程&lt;br/&gt;不阻塞&#34;]
n4 --&gt; n5[&#34;线程池封装结果&lt;br/&gt;到Future中并返回&#34;]
n5 --&gt; n6[&#34;从Future中&lt;br/&gt;获取返回值&#34;] -.- n6a[&#34;该过程&lt;br/&gt;阻塞&#34;]
</code></pre><blockquote><p>武技: 测试将Callable任务提交到线程池</p></blockquote><p><code>pool.CallableThreadPoolTest.testSubmit()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CallableThreadPoolTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testSubmit</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建一个可缓存的线程池</span>
</span></span><span style=display:flex><span>        ExecutorService threadPool <span style=color:#f92672>=</span> Executors.<span style=color:#a6e22e>newCachedThreadPool</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;0s: 线程池创建完毕&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建一个Callable任务</span>
</span></span><span style=display:flex><span>        Callable<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> callableTask <span style=color:#f92672>=</span> () <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;0s: callable任务睡眠&#34;</span>);
</span></span><span style=display:flex><span>            TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(2L);
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;2s: callable任务执行完毕&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> 9527;
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将Callable任务异步提交到线程池中，该方法不会阻塞主线程</span>
</span></span><span style=display:flex><span>        Future<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> callableResult <span style=color:#f92672>=</span> threadPool.<span style=color:#a6e22e>submit</span>(callableTask);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;0s: 若我立刻输出，则证明 submit 方法不阻塞&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取任务方法的返回值，该方法会阻塞主线程，直到获取到结果</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;2s: 获取到call方法返回值 -&gt; &#34;</span> <span style=color:#f92672>+</span> callableResult.<span style=color:#a6e22e>get</span>());
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;2s: 若我立刻输出，则证明 get 方法不阻塞&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 不再新增线程，发出停止信号，等所有线程执行完毕，关闭线程池，节省资源</span>
</span></span><span style=display:flex><span>        threadPool.<span style=color:#a6e22e>shutdown</span>();
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;2s: 关闭线程池&#34;</span>);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;2s: 主线程退出&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=3-futuretask>3. FutureTask</h3><blockquote><p>心法: <code>j.u.c.FutureTask</code></p></blockquote><ul><li>FutureTask类既实现了 <code>Runnable</code> 接口，又实现了 <code>Future</code> 接口。</li><li>所以 <code>FutureTask</code> 既能作为一个线程类，又能直接存储Callable任务的结果。</li></ul><table><thead><tr><th>相关API方法</th><th>描述</th></tr></thead><tbody><tr><td><code>new FutureTask&lt;>(Callable任务)</code></td><td>创建一个FutureTask实例</td></tr><tr><td><code>new Thread(futureTask)</code></td><td>FutureTask可以直接作为一个实现了Runnable接口的线程类</td></tr><tr><td><code>futureTask.get()</code></td><td>获取任务方法的返回值，该方法会阻塞主线程，直到获取到结果</td></tr></tbody></table><blockquote><p>武技: 测试FutureTask</p></blockquote><p><code>pool.FutureTaskTest.testFutureTask()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FutureTaskTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@Test</span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testFutureTask</span>() {  
</span></span><span style=display:flex><span>	  
</span></span><span style=display:flex><span>	    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;0s: 子线程启动&#34;</span>);  
</span></span><span style=display:flex><span>	  
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// 创建一个FutureTask实例，参数是一个Callable任务  </span>
</span></span><span style=display:flex><span>	    FutureTask<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> futureTask <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> FutureTask<span style=color:#f92672>&lt;&gt;</span>(() <span style=color:#f92672>-&gt;</span> {  
</span></span><span style=display:flex><span>	        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;0s: Callable任务睡眠&#34;</span>);  
</span></span><span style=display:flex><span>	        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(2L);  
</span></span><span style=display:flex><span>	        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;2s: Callable任务结束，返回9527&#34;</span>);  
</span></span><span style=display:flex><span>	        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;2s: 子线程退出&#34;</span>);  
</span></span><span style=display:flex><span>	        <span style=color:#66d9ef>return</span> 9527;  
</span></span><span style=display:flex><span>	    });  
</span></span><span style=display:flex><span>	  
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// futureTask实现了Runnable接口，是一个线程类  </span>
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>new</span> Thread(futureTask).<span style=color:#a6e22e>start</span>();  
</span></span><span style=display:flex><span>	  
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// futureTask实现了Future接口，线程体方法支持返回值  </span>
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// 获取线程中call()的返回值，这个方法会阻塞主线程，直到获取到结果  </span>
</span></span><span style=display:flex><span>	    Integer callableResult <span style=color:#f92672>=</span> futureTask.<span style=color:#a6e22e>get</span>();  
</span></span><span style=display:flex><span>	    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;2s: call方法的返回值: &#34;</span> <span style=color:#f92672>+</span> callableResult);  
</span></span><span style=display:flex><span>	    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;2s: 主线程退出&#34;</span>);  
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=4-completablefuture>4. CompletableFuture</h3><blockquote><p>心法: <code>j.u.c.CompletableFuture</code></p></blockquote><ul><li>CompletableFuture类可以对多个任务进行异步执行和统一管理。</li></ul><table><thead><tr><th>相关API方法</th><th>描述</th></tr></thead><tbody><tr><td><code>CompletableFuture.supplyAsync(线程任务)</code></td><td>异步执行一个Callable线程任务要返回一个 <code>Future&lt;返回值类型></code> 结果</td></tr><tr><td><code>CompletableFuture.runAsync(线程任务)</code></td><td>异步执行一个Runnable线程任务即使没有返回值，也要返回一个 <code>Future&lt;Void></code> 结果</td></tr><tr><td><code>CompletableFuture.allOf(FutureA, FutureB ...)</code></td><td>汇总所有的Future结果，得到一个新的 <code>Future&lt;Void></code> 结果</td></tr></tbody></table><p>![[第1阶段-BASIC/JB1-7-并发编程/excalidraw/CompletableFuture原理.md#^group=STR9AeJ_d2bkYqTUW77Zg|100%]]</p><blockquote><p>武技: CompletableFuture异步调用耗时情况</p></blockquote><ol><li>开发6个任务方法，3个带返回值，3个不带返回值：</li></ol><p><code>pool.CompletableFutureTest.task*()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CompletableFutureTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String <span style=color:#a6e22e>taskA</span>() {
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(1L);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;1s: taskA执行完毕&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;A&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String <span style=color:#a6e22e>taskB</span>() {
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(2L);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;2s: taskB执行完毕&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;B&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String <span style=color:#a6e22e>taskC</span>() {
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(3L);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;3s: taskC执行完毕&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;C&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>taskD</span>() {
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(1L);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;1s: taskD执行完毕&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>taskE</span>() {
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(2L);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;2s: taskE执行完毕&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>taskF</span>() {
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(3L);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;3s: taskF执行完毕&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>测试同步调用6个任务时的总耗时：</li></ol><p><code>pool.CompletableFutureTest.testTask()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CompletableFutureTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/** 同步执行6个任务，计算总耗时 */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testTask</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> start <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>currentTimeMillis</span>();
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;1s: taskA返回值: &#34;</span> <span style=color:#f92672>+</span> taskA());
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;2s: taskB返回值: &#34;</span> <span style=color:#f92672>+</span> taskB());
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;3s: taskC返回值: &#34;</span> <span style=color:#f92672>+</span> taskC());
</span></span><span style=display:flex><span>        taskD();
</span></span><span style=display:flex><span>        taskE();
</span></span><span style=display:flex><span>        taskF();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> end <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>currentTimeMillis</span>();
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;耗时:&#34;</span> <span style=color:#f92672>+</span> (end <span style=color:#f92672>-</span> start));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li>测试使用CompletableFuture异步调用6个任务的总耗时：</li></ol><p><code>pool.CompletableFutureTest.testTaskByCompletableFuture()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CompletableFutureTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 使用CompletableFuture异步执行6个任务，计算总耗时 */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testTaskByCompletableFuture</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> start <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>currentTimeMillis</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// supplyAsync(): 执行三个带返回值的异步任务</span>
</span></span><span style=display:flex><span>        CompletableFuture<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> futureA <span style=color:#f92672>=</span> CompletableFuture.<span style=color:#a6e22e>supplyAsync</span>(<span style=color:#66d9ef>this</span>::taskA);
</span></span><span style=display:flex><span>        CompletableFuture<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> futureB <span style=color:#f92672>=</span> CompletableFuture.<span style=color:#a6e22e>supplyAsync</span>(<span style=color:#66d9ef>this</span>::taskB);
</span></span><span style=display:flex><span>        CompletableFuture<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> futureC <span style=color:#f92672>=</span> CompletableFuture.<span style=color:#a6e22e>supplyAsync</span>(<span style=color:#66d9ef>this</span>::taskC);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// runAsync(): 执行三个不带返回值的异步任务</span>
</span></span><span style=display:flex><span>        CompletableFuture<span style=color:#f92672>&lt;</span>Void<span style=color:#f92672>&gt;</span> futureD <span style=color:#f92672>=</span> CompletableFuture.<span style=color:#a6e22e>runAsync</span>(<span style=color:#66d9ef>this</span>::taskD);
</span></span><span style=display:flex><span>        CompletableFuture<span style=color:#f92672>&lt;</span>Void<span style=color:#f92672>&gt;</span> futureE <span style=color:#f92672>=</span> CompletableFuture.<span style=color:#a6e22e>runAsync</span>(<span style=color:#66d9ef>this</span>::taskE);
</span></span><span style=display:flex><span>        CompletableFuture<span style=color:#f92672>&lt;</span>Void<span style=color:#f92672>&gt;</span> futureF <span style=color:#f92672>=</span> CompletableFuture.<span style=color:#a6e22e>runAsync</span>(<span style=color:#66d9ef>this</span>::taskF);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 任务汇总: 当六个future全部完成之后，汇总到一个新的future实例中</span>
</span></span><span style=display:flex><span>        CompletableFuture<span style=color:#f92672>&lt;</span>Void<span style=color:#f92672>&gt;</span> future <span style=color:#f92672>=</span> CompletableFuture.<span style=color:#a6e22e>allOf</span>(
</span></span><span style=display:flex><span>                futureA, futureB, futureC, futureD, futureE, futureF);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 让任务汇总工作插主线程的队</span>
</span></span><span style=display:flex><span>        future.<span style=color:#a6e22e>join</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 当futureA/futureB/futureC任务均执行完毕后，获取其返回值</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (futureA.<span style=color:#a6e22e>isDone</span>() <span style=color:#f92672>&amp;&amp;</span> futureB.<span style=color:#a6e22e>isDone</span>() <span style=color:#f92672>&amp;&amp;</span> futureC.<span style=color:#a6e22e>isDone</span>()) {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;taskA返回值: &#34;</span> <span style=color:#f92672>+</span> futureA.<span style=color:#a6e22e>get</span>());
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;taskB返回值: &#34;</span> <span style=color:#f92672>+</span> futureB.<span style=color:#a6e22e>get</span>());
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;taskC返回值: &#34;</span> <span style=color:#f92672>+</span> futureC.<span style=color:#a6e22e>get</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>long</span> end <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>currentTimeMillis</span>();  
</span></span><span style=display:flex><span>		  
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 计算总耗时  </span>
</span></span><span style=display:flex><span>		System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;耗时:&#34;</span> <span style=color:#f92672>+</span> (end <span style=color:#f92672>-</span> start));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=e03-threadpoolexecutor>E03. ThreadPoolExecutor</h2><blockquote><p>心法: <code>j.u.c.ThreadPoolExecutor</code></p></blockquote><ul><li>ThreadPoolExecutor用于创建线程池，每个线程池内部都维护了一个HashSet结构的线程集合和一个任务队列。</li></ul><p>![[第1阶段-BASIC/JB1-7-并发编程/excalidraw/线程池内部结构.md#^group=LoBulytISp2ARNqjCkcGz|100%]]</p><h3 id=1-核心参数基础概念>1. 核心参数基础概念</h3><blockquote><p>心法: ThreadPoolExecutor构造器7个参数</p></blockquote><table><thead><tr><th>参数名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>corePoolSize</code></td><td><code>int</code></td><td>核心线程数，线程池维护的最少线程数量，即使空闲也不会给归还给OS</td></tr><tr><td><code>maximumPoolSize</code></td><td><code>int</code></td><td>线程池维护的最多线程数量，即当核心线程不够了，最大能拓展到多少</td></tr><tr><td><code>keepAliveTime</code></td><td><code>long</code></td><td>非核心线程所允许的最大的空闲时间某个线程的空闲时间如果超过此指定值，会被归还给OS</td></tr><tr><td><code>unit</code></td><td><code>TimeUnit</code></td><td>最大的空闲时间单位</td></tr><tr><td><code>workQueue</code></td><td><code>BlockingQueue&lt;Runnable></code></td><td>线程池所使用的工作队列类型，即BlockingQueue类型</td></tr><tr><td><code>threadFactory</code></td><td><code>ThreadFactory</code></td><td>线程工厂，用于产生线程，可以自定义，默认使用DefaultThreadFactory</td></tr><tr><td><code>handler</code></td><td><code>RejectedExecutionHandler</code></td><td>线程池对拒绝任务采取的拒绝策略，默认使用AbortPolicy</td></tr></tbody></table><blockquote><p>心法: ThreadPoolExecutor构造器7个参数配合流程</p></blockquote><ul><li>整体过程中，若某个线程执行完任务，则会优先从等待队列中拉取任务继续执行，而新来的任务继续进入等待队列。</li></ul><p>假设我们设置核心线程数为2，最大线程数为4，任务队列最大值为2，那么：</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR

n1[&#34;线程池&lt;br/&gt;首次创建&#34;] -.- n11[&#34;队列和集合均为空&#34;]

n2[&#34;任务A提交&lt;br/&gt;到线程池&#34;] --&gt; n21[&#34;启动1个核心线程T1&lt;br/&gt;处理任务A&#34;] 
	n21 -.- n211[&#34;核心线程&#34;] -.- n2111[&#34;T1&#34;]
	
n3[&#34;任务B提交&lt;br/&gt;到线程池&#34;] --&gt; n31[&#34;启动1个核心线程T2&lt;br/&gt;处理任务B&#34;] 
	n31 -.- n311[&#34;核心线程&#34;] -.- n3111[&#34;T1, T2&#34;] -.- n31111[&#34;已满&#34;]
	
n4[&#34;任务C提交&lt;br/&gt;到线程池&#34;] --&gt; n41[&#34;将任务C加入队列&#34;]
	n41 -.- n411[&#34;任务队列&#34;] -.- n4111[&#34;任务C&#34;] 
	n41 -.- n422[&#34;核心线程&#34;] -.- n4222[&#34;T1, T2&#34;] -.- n42222[&#34;已满&#34;]
	
n5[&#34;任务D提交&lt;br/&gt;到线程池&#34;] --&gt; n51[&#34;将任务D加入队列&#34;] 
	n51 -.- n511[&#34;任务队列&#34;] -.- n5111[&#34;任务C, 任务D&#34;] -.- n51111[&#34;已满&#34;]
	n51 -.- n522[&#34;核心线程&#34;] -.- n5222[&#34;T1, T2&#34;] -.- n52222[&#34;已满&#34;]

n6[&#34;任务E提交&lt;br/&gt;到线程池&#34;] --&gt; n61[&#34;拓展一个临时线程T3&lt;br/&gt;处理任务E&#34;] 
	n61 -.- n611[&#34;任务队列&#34;] -.- n6111[&#34;任务C, 任务D&#34;] -.- n61111[&#34;已满&#34;]
	n61 -.- n622[&#34;核心线程&#34;] -.- n6222[&#34;T1, T2&#34;] -.- n62222[&#34;已满&#34;]
	n61 -.- n633[&#34;临时线程&#34;] -.- n6333[&#34;T3&#34;]

n7[&#34;任务F提交&lt;br/&gt;到线程池&#34;] --&gt; n71[&#34;拓展一个临时线程T4&lt;br/&gt;处理任务F&#34;] 
	n71 -.- n711[&#34;任务队列&#34;] -.- n7111[&#34;任务C, 任务D&#34;] -.- n71111[&#34;已满&#34;]
	n71 -.- n722[&#34;核心线程&#34;] -.- n7222[&#34;T1, T2&#34;] -.- n72222[&#34;已满&#34;]
	n71 -.- n733[&#34;临时线程&#34;] -.- n7333[&#34;T3, T4&#34;] -.- n73333[&#34;已满&#34;]

n8[&#34;任务G提交&lt;br/&gt;到线程池&#34;] --&gt; n81[&#34;对任务G执行拒绝策略&#34;]	
</code></pre><h3 id=2-核心参数设计原则>2. 核心参数设计原则</h3><blockquote><p>心法: ThreadPoolExecutor中核心参数设计的原则</p></blockquote><ul><li>CPU密集型任务多，使用小线程池。</li><li>IO密集型任务多，使用大线程池。</li></ul><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR
n1a[&#34;数据加密&#34;] &amp; n1b[&#34;文件压缩&#34;] &amp; n1c[&#34;复杂计算&#34;] &amp; n1d[&#34;等等等等&#34;] 
	-.- n1[&#34;CPU密集型任务较多时&lt;br/&gt;CPU利用率很高，但IO读写次数很低&#34;] 
	--&gt; n11[&#34;使用小线程池&#34;]
	-.- n111[&#34;避免过度线程切换，加重CPU消耗&#34;]
n2a[&#34;文件读写&#34;] &amp; n2b[&#34;数据库通信&#34;] &amp; n2c[&#34;网络通信&#34;] &amp; n2d[&#34;等等等等&#34;] 
	-.- n2[&#34;IO密集型任务较多时&lt;br/&gt;CPU利用率很低，但IO读写很耗时&#34;] 
	--&gt; n22[&#34;使用大线程池&#34;] 
	-.- n222[&#34;让CPU在等待IO的时，&lt;br/&gt;有其他线程去处理别的任务，充分利用CPU时间&#34;]
</code></pre><h3 id=3-核心参数设计公式>3. 核心参数设计公式</h3><blockquote><p>心法: ThreadPoolExecutor中核心参数设计的公式</p></blockquote><ul><li>假设执行单个任务平均耗时0.1秒，系统每秒平均产生100个任务，若需要这100个任务可以在1秒内完成，则:<ul><li>核心线程数 = <code>总时间 * 平均任务数 * 单个任务平均耗时</code>，即 <code>1 * 100 * 0.1 = 10</code> 个。</li><li>队列容量 = <code>核心线程数 / 单个任务平均耗时 * 2</code>，即 <code>10 / 0.1 * 2 = 200</code> 个。</li></ul></li><li>假设系统最大产生1000个任务，则:<ul><li>最大线程数 = <code>(最大任务数 - 队列容量) * 单个任务平均耗时</code>，即 <code>(1000 - 200) * 0.1 = 80</code> 个。</li></ul></li></ul><h3 id=4-创建线程池>4. 创建线程池</h3><table><thead><tr><th>相关API方法</th><th>描述</th></tr></thead><tbody><tr><td><code>pool.execute(Runnable r)</code></td><td>将Runnable线程任务提交到线程池中并由线程池分配线程执行</td></tr><tr><td><code>pool.submit(Callable&lt;T> c)</code></td><td>将Callable线程任务异步提交到线程池中执行并返回Future结果</td></tr><tr><td><code>pool.shutdown()</code></td><td>不再新增线程，发出停止信号，等所有线程执行完毕，关闭线程池，节省资源</td></tr><tr><td><code>pool.shutdownNow()</code></td><td>不再新增线程，立即关闭线程池，节省资源</td></tr></tbody></table><blockquote><p>武技: 测试通过ThreadPoolExecutor创建线程池</p></blockquote><p><code>pool.ThreadPoolExecutorTest.testThreadPoolExecutor</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ThreadPoolExecutorTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testThreadPoolExecutor</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建一个线程池</span>
</span></span><span style=display:flex><span>        ThreadPoolExecutor threadPool <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ThreadPoolExecutor(
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 核心线程数，线程池维护的最少线程数量，即使空闲也不会给归还给OS</span>
</span></span><span style=display:flex><span>                2,
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 线程池维护的最多线程数量，即当核心线程不够了，最大能拓展到多少</span>
</span></span><span style=display:flex><span>                4,
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 非核心线程所允许的最大的空闲时间，某个线程的空闲时间如果超过此指定值，会被归还给OS</span>
</span></span><span style=display:flex><span>                3, TimeUnit.<span style=color:#a6e22e>SECONDS</span>,
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 线程池所使用的工作队列类型，即BlockingQueue类型</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> ArrayBlockingQueue<span style=color:#f92672>&lt;&gt;</span>(3),
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 线程工厂，用于产生线程，默认使用DefaultThreadFactory</span>
</span></span><span style=display:flex><span>                Executors.<span style=color:#a6e22e>defaultThreadFactory</span>(),
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 线程池对拒绝任务采取的拒绝策略，默认使用AbortPolicy</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> ThreadPoolExecutor.<span style=color:#a6e22e>AbortPolicy</span>()
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Runnable线程任务使用 execute() 提交到线程池中</span>
</span></span><span style=display:flex><span>        threadPool.<span style=color:#a6e22e>execute</span>(() <span style=color:#f92672>-&gt;</span> System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;runnable..&#34;</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(2L);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Callable线程任务使用 submit() 提交到线程池中</span>
</span></span><span style=display:flex><span>        Future<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> future <span style=color:#f92672>=</span> threadPool.<span style=color:#a6e22e>submit</span>(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;callable..&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> 9527;
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取Callable任务实例的返回值</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(future.<span style=color:#a6e22e>get</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 关闭线程池</span>
</span></span><span style=display:flex><span>        threadPool.<span style=color:#a6e22e>shutdown</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=e04-executors>E04. Executors</h2><blockquote><p>心法: <code>j.u.c.Executors</code></p></blockquote><ul><li>Executors工具用于创建线程池，是 <code>ThreadPoolExecutor</code> 类的上层封装。</li><li>尽量避免使用Executors创建线程池，因为它大部分实现都存在以下2种缺陷之一:<ul><li>允许的线程最大值为int最大值，很可能会创建大量的线程，从而导致OOM。</li><li>使用的工作队列为 <code>LinkedBlockingQueue</code>，容量默认为int最大值，易导致OOM。</li></ul></li></ul><blockquote><p>心法: Executors框架中的内置线程池</p></blockquote><table><thead><tr><th>线程池</th><th>核心线程数</th><th>最大线程数</th><th>最大空闲</th><th>工作队列</th></tr></thead><tbody><tr><td><code>CachedThreadPool</code></td><td>0</td><td>Integer最大值</td><td>60s</td><td><code>SynchronousQueue</code></td></tr><tr><td><code>FixedThreadPool</code></td><td>构造时指定</td><td>与核心线程数一致</td><td>0ms</td><td><code>LinkedBlockingQueue</code></td></tr><tr><td><code>ScheduledThreadPool</code></td><td>构造时指定</td><td>Integer最大值</td><td>10ms</td><td><code>DelayedWorkQueue</code></td></tr><tr><td><code>SingleThreadExecutor</code></td><td>1</td><td>1</td><td>0ms</td><td><code>LinkedBlockingQueue</code></td></tr></tbody></table><h3 id=1-cachedthreadpool>1. CachedThreadPool</h3><p><code>pool.CachedThreadPoolTest.testCachedThreadPool()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CachedThreadPoolTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testCachedThreadPool</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建一个缓存线程池</span>
</span></span><span style=display:flex><span>        ExecutorService executorService <span style=color:#f92672>=</span> Executors.<span style=color:#a6e22e>newCachedThreadPool</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0, j <span style=color:#f92672>=</span> 10; i <span style=color:#f92672>&lt;</span> j; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(1L);
</span></span><span style=display:flex><span>            executorService.<span style=color:#a6e22e>execute</span>(() <span style=color:#f92672>-&gt;</span> System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;hello!&#34;</span>));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(20L);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-fixedthreadpool>2. FixedThreadPool</h3><p><code>pool.FixedThreadPoolTest.testFixedThreadPool()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FixedThreadPoolTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testFixedThreadPool</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建一个固定线程池</span>
</span></span><span style=display:flex><span>        ExecutorService executorService <span style=color:#f92672>=</span> Executors.<span style=color:#a6e22e>newFixedThreadPool</span>(3);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 每隔1秒提交一个任务到线程池中</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0, j <span style=color:#f92672>=</span> 10; i <span style=color:#f92672>&lt;</span> j; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(1L);
</span></span><span style=display:flex><span>            executorService.<span style=color:#a6e22e>execute</span>(() <span style=color:#f92672>-&gt;</span> System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;hello!&#34;</span>));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(20L);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=3-scheduledthreadpool>3. ScheduledThreadPool</h3><p><code>pool.ScheduledThreadPoolTest.testSchedule()/testScheduleAtFixedRate()/testScheduleWithFixedDelay()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ScheduledThreadPoolTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testSchedule</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取当前时间中的秒</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Calendar.<span style=color:#a6e22e>getInstance</span>().<span style=color:#a6e22e>get</span>(Calendar.<span style=color:#a6e22e>SECOND</span>));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建一个定时线程池</span>
</span></span><span style=display:flex><span>        ScheduledExecutorService executorService <span style=color:#f92672>=</span> Executors.<span style=color:#a6e22e>newScheduledThreadPool</span>(3);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 延迟2秒后执行任务</span>
</span></span><span style=display:flex><span>        executorService.<span style=color:#a6e22e>schedule</span>(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Calendar.<span style=color:#a6e22e>getInstance</span>().<span style=color:#a6e22e>get</span>(Calendar.<span style=color:#a6e22e>SECOND</span>));
</span></span><span style=display:flex><span>        }, 2, TimeUnit.<span style=color:#a6e22e>SECONDS</span>);
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(20L);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testScheduleAtFixedRate</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取当前时间中的秒</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Calendar.<span style=color:#a6e22e>getInstance</span>().<span style=color:#a6e22e>get</span>(Calendar.<span style=color:#a6e22e>SECOND</span>));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建一个定时线程池</span>
</span></span><span style=display:flex><span>        ScheduledExecutorService executorService <span style=color:#f92672>=</span> Executors.<span style=color:#a6e22e>newScheduledThreadPool</span>(1);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 延迟2秒后执行任务，然后从上一个任务开始执行时始计算，每隔3秒执行一次</span>
</span></span><span style=display:flex><span>        executorService.<span style=color:#a6e22e>scheduleAtFixedRate</span>(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(2L);
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Calendar.<span style=color:#a6e22e>getInstance</span>().<span style=color:#a6e22e>get</span>(Calendar.<span style=color:#a6e22e>SECOND</span>));
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }, 2, 3, TimeUnit.<span style=color:#a6e22e>SECONDS</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(System.<span style=color:#a6e22e>in</span>.<span style=color:#a6e22e>read</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testScheduleWithFixedDelay</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取当前时间中的秒</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Calendar.<span style=color:#a6e22e>getInstance</span>().<span style=color:#a6e22e>get</span>(Calendar.<span style=color:#a6e22e>SECOND</span>));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建一个定时线程池</span>
</span></span><span style=display:flex><span>        ScheduledExecutorService executorService <span style=color:#f92672>=</span> Executors.<span style=color:#a6e22e>newScheduledThreadPool</span>(1);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 延迟2秒后执行任务，然后从上一个任务执行结束时始计算，每隔3秒执行一次</span>
</span></span><span style=display:flex><span>        executorService.<span style=color:#a6e22e>scheduleWithFixedDelay</span>(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(2L);
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Calendar.<span style=color:#a6e22e>getInstance</span>().<span style=color:#a6e22e>get</span>(Calendar.<span style=color:#a6e22e>SECOND</span>));
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }, 2, 3, TimeUnit.<span style=color:#a6e22e>SECONDS</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(System.<span style=color:#a6e22e>in</span>.<span style=color:#a6e22e>read</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=4-singlethreadexecutor>4. SingleThreadExecutor</h3><p><code>pool.SingleThreadExecutorTest.testSingleThreadExecutor()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SingleThreadExecutorTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testSingleThreadExecutor</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建单线程线程池</span>
</span></span><span style=display:flex><span>        ExecutorService executorService <span style=color:#f92672>=</span> Executors.<span style=color:#a6e22e>newSingleThreadExecutor</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 每隔1秒提交一个任务到线程池中</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0, j <span style=color:#f92672>=</span> 10; i <span style=color:#f92672>&lt;</span> j; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(1L);
</span></span><span style=display:flex><span>            executorService.<span style=color:#a6e22e>execute</span>(() <span style=color:#f92672>-&gt;</span> System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;hello!&#34;</span>));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(20L);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=e05-线程池拒绝策略>E05. 线程池拒绝策略</h2><blockquote><p>心法: 线程池拒绝策略</p></blockquote><ul><li>线程池拒绝策略指的是当总线程数已达最大时，对新申请提交的任务的拒绝方式。</li><li>ThreadPoolExecutor内置的拒绝策略包含以下四种：</li></ul><table><thead><tr><th>ThreadPoolExecutor内置拒绝策略</th><th>描述</th></tr></thead><tbody><tr><td><code>threadPoolExecutor.AbortPolicy()</code></td><td>直接抛出异常，阻止系统正常工作</td></tr><tr><td><code>threadPoolExecutor.DiscardPolicy()</code></td><td>啥事都不干，直接把任务丢弃</td></tr><tr><td><code>threadPoolExecutor.DiscardOldestPolicy()</code></td><td>丢弃等待队列中的第一个任务（最老），让新来的任务入队</td></tr><tr><td><code>threadPoolExecutor.CallerRunsPolicy()</code></td><td>只要线程池没有关闭，该策略直接在调用者线程中执行当前被丢弃的任务，即哪个线程调用了 <code>execute()/submit()</code> 方法，哪个线程执行这个任务</td></tr></tbody></table><h3 id=1-abortpolicy>1. AbortPolicy</h3><p><code>pool.AbortPolicyTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AbortPolicyTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@ToString</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyTask</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> i;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>MyTask</span>(<span style=color:#66d9ef>int</span> i) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;: &#34;</span> <span style=color:#f92672>+</span> i);
</span></span><span style=display:flex><span>                TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(10L);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>                e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testAbortPolicy</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建线程池</span>
</span></span><span style=display:flex><span>        ThreadPoolExecutor threadPool <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ThreadPoolExecutor(
</span></span><span style=display:flex><span>                2, 4, 60, TimeUnit.<span style=color:#a6e22e>SECONDS</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> ArrayBlockingQueue<span style=color:#f92672>&lt;&gt;</span>(4),
</span></span><span style=display:flex><span>                Executors.<span style=color:#a6e22e>defaultThreadFactory</span>(),
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> ThreadPoolExecutor.<span style=color:#a6e22e>AbortPolicy</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 提交8个任务，将线程池中的核心线程，工作队列和拓展线程都占满</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0, j <span style=color:#f92672>=</span> 8; i <span style=color:#f92672>&lt;</span> j; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            threadPool.<span style=color:#a6e22e>execute</span>(<span style=color:#66d9ef>new</span> MyTask(i));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 查看工作队列</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;queue:&#34;</span> <span style=color:#f92672>+</span> threadPool.<span style=color:#a6e22e>getQueue</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 再次提交一个任务</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;再次提交一个100号任务&#34;</span>);
</span></span><span style=display:flex><span>        threadPool.<span style=color:#a6e22e>execute</span>(<span style=color:#66d9ef>new</span> MyTask(100));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 查看工作队列</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;queue:&#34;</span> <span style=color:#f92672>+</span> threadPool.<span style=color:#a6e22e>getQueue</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 关闭线程池</span>
</span></span><span style=display:flex><span>        threadPool.<span style=color:#a6e22e>shutdown</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 阻止主线程</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(20L);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-discardpolicy>2. DiscardPolicy</h3><p><code>pool.DiscardPolicyTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DiscardPolicyTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@ToString</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyTask</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> i;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>MyTask</span>(<span style=color:#66d9ef>int</span> i) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;: &#34;</span> <span style=color:#f92672>+</span> i);
</span></span><span style=display:flex><span>                TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(10L);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>                e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testDiscardPolicy</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建线程池</span>
</span></span><span style=display:flex><span>        ThreadPoolExecutor threadPool <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ThreadPoolExecutor(
</span></span><span style=display:flex><span>                2, 4, 60, TimeUnit.<span style=color:#a6e22e>SECONDS</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> ArrayBlockingQueue<span style=color:#f92672>&lt;&gt;</span>(4),
</span></span><span style=display:flex><span>                Executors.<span style=color:#a6e22e>defaultThreadFactory</span>(),
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> ThreadPoolExecutor.<span style=color:#a6e22e>DiscardPolicy</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 提交8个任务，将线程池中的核心线程，工作队列和拓展线程都占满</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0, j <span style=color:#f92672>=</span> 8; i <span style=color:#f92672>&lt;</span> j; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            threadPool.<span style=color:#a6e22e>execute</span>(<span style=color:#66d9ef>new</span> MyTask(i));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 查看工作队列</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;queue:&#34;</span> <span style=color:#f92672>+</span> threadPool.<span style=color:#a6e22e>getQueue</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 再次提交一个任务</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;再次提交一个100号任务&#34;</span>);
</span></span><span style=display:flex><span>        threadPool.<span style=color:#a6e22e>execute</span>(<span style=color:#66d9ef>new</span> MyTask(100));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 查看工作队列</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;queue:&#34;</span> <span style=color:#f92672>+</span> threadPool.<span style=color:#a6e22e>getQueue</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 关闭线程池</span>
</span></span><span style=display:flex><span>        threadPool.<span style=color:#a6e22e>shutdown</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 阻止主线程</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(20L);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=3-discardoldestpolicy>3. DiscardOldestPolicy</h3><p><code>pool.DiscardOldestPolicyTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DiscardOldestPolicyTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@ToString</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyTask</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> i;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>MyTask</span>(<span style=color:#66d9ef>int</span> i) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;: &#34;</span> <span style=color:#f92672>+</span> i);
</span></span><span style=display:flex><span>                TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(10L);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>                e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testDiscardOldestPolicy</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建线程池</span>
</span></span><span style=display:flex><span>        ThreadPoolExecutor threadPool <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ThreadPoolExecutor(
</span></span><span style=display:flex><span>                2, 4, 60, TimeUnit.<span style=color:#a6e22e>SECONDS</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> ArrayBlockingQueue<span style=color:#f92672>&lt;&gt;</span>(4),
</span></span><span style=display:flex><span>                Executors.<span style=color:#a6e22e>defaultThreadFactory</span>(),
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> ThreadPoolExecutor.<span style=color:#a6e22e>DiscardOldestPolicy</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 提交8个任务，将线程池中的核心线程，工作队列和拓展线程都占满</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0, j <span style=color:#f92672>=</span> 8; i <span style=color:#f92672>&lt;</span> j; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            threadPool.<span style=color:#a6e22e>execute</span>(<span style=color:#66d9ef>new</span> MyTask(i));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 查看工作队列</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;queue:&#34;</span> <span style=color:#f92672>+</span> threadPool.<span style=color:#a6e22e>getQueue</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 再次提交一个任务</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;再次提交一个100号任务&#34;</span>);
</span></span><span style=display:flex><span>        threadPool.<span style=color:#a6e22e>execute</span>(<span style=color:#66d9ef>new</span> MyTask(100));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 查看工作队列</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;queue:&#34;</span> <span style=color:#f92672>+</span> threadPool.<span style=color:#a6e22e>getQueue</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 关闭线程池</span>
</span></span><span style=display:flex><span>        threadPool.<span style=color:#a6e22e>shutdown</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 阻止主线程</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(20L);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=4-callerrunspolicy>4. CallerRunsPolicy</h3><p><code>pool.CallerRunsPolicyTest</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CallerRunsPolicyTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@ToString</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyTask</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> i;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>MyTask</span>(<span style=color:#66d9ef>int</span> i) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;: &#34;</span> <span style=color:#f92672>+</span> i);
</span></span><span style=display:flex><span>                TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(10L);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>                e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testCallerRunsPolicy</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建线程池</span>
</span></span><span style=display:flex><span>        ThreadPoolExecutor threadPool <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ThreadPoolExecutor(
</span></span><span style=display:flex><span>                2, 4, 60, TimeUnit.<span style=color:#a6e22e>SECONDS</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> ArrayBlockingQueue<span style=color:#f92672>&lt;&gt;</span>(4),
</span></span><span style=display:flex><span>                Executors.<span style=color:#a6e22e>defaultThreadFactory</span>(),
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> ThreadPoolExecutor.<span style=color:#a6e22e>CallerRunsPolicy</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 提交8个任务，将线程池中的核心线程，工作队列和拓展线程都占满</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0, j <span style=color:#f92672>=</span> 8; i <span style=color:#f92672>&lt;</span> j; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            threadPool.<span style=color:#a6e22e>execute</span>(<span style=color:#66d9ef>new</span> MyTask(i));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 查看工作队列</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;queue:&#34;</span> <span style=color:#f92672>+</span> threadPool.<span style=color:#a6e22e>getQueue</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 再次提交一个任务</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;再次提交一个100号任务&#34;</span>);
</span></span><span style=display:flex><span>        threadPool.<span style=color:#a6e22e>execute</span>(<span style=color:#66d9ef>new</span> MyTask(100));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 查看工作队列</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;queue:&#34;</span> <span style=color:#f92672>+</span> threadPool.<span style=color:#a6e22e>getQueue</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 关闭线程池</span>
</span></span><span style=display:flex><span>        threadPool.<span style=color:#a6e22e>shutdown</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 阻止主线程</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(20L);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=e06-自定义线程池>E06. 自定义线程池</h2><blockquote><p>心法: 自定义线程池流程</p></blockquote><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR

n1[&#34;自定义任务类&#34;] --&gt; n2[&#34;自定义线程工厂&#34;] --&gt; n3[&#34;自定义拒绝策略&#34;] --&gt; n4[&#34;测试&#34;]
</code></pre><blockquote><p>武技: 自定义线程池</p></blockquote><h3 id=1-自定义线程任务类>1. 自定义线程任务类</h3><p><code>pool.MyThreadPoolTest$MyTask</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyThreadPoolTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 自定义线程任务类 */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Data</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyTask</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> String taskName;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        MyTask(String taskName) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>taskName</span> <span style=color:#f92672>=</span> taskName;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 打印哪个线程正在执行哪个任务</span>
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; 正在执行 &#34;</span> <span style=color:#f92672>+</span> taskName <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;任务&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 模拟任务耗时3L</span>
</span></span><span style=display:flex><span>            TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(10L);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-自定义线程工厂类>2. 自定义线程工厂类</h3><p>`pool.MyThreadPoolTest$MyThreadFactory</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyThreadPoolTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/** 自定义线程工厂 */</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyThreadFactory</span> <span style=color:#66d9ef>implements</span> ThreadFactory {
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> AtomicInteger mThreadNum <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AtomicInteger(1);
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>public</span> Thread <span style=color:#a6e22e>newThread</span>(<span style=color:#a6e22e>@NonNull</span> Runnable r) {
</span></span><span style=display:flex><span>	        Thread thread <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(r, <span style=color:#e6db74>&#34;自定义线程-&#34;</span> <span style=color:#f92672>+</span> mThreadNum.<span style=color:#a6e22e>getAndIncrement</span>());
</span></span><span style=display:flex><span>	        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(thread.<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; 被创建&#34;</span>);
</span></span><span style=display:flex><span>	        <span style=color:#66d9ef>return</span> thread;
</span></span><span style=display:flex><span>	    }
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=3-自定义拒绝策略类>3. 自定义拒绝策略类</h3><p>`pool.MyThreadPoolTest$MyRejectedPolicy</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyThreadPoolTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 自定义拒绝策略 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyRejectedPolicy</span> <span style=color:#66d9ef>implements</span> RejectedExecutionHandler {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>rejectedExecution</span>(Runnable r, ThreadPoolExecutor e) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 可以将未能处理的任务保存到Redis，MQ或者DB中，在其他时间进行处理</span>
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(((MyTask) r).<span style=color:#a6e22e>getTaskName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; 因线程池耗尽而被拒绝..&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=4-测试自定义线程池>4. 测试自定义线程池</h3><p><code>pool.MyThreadPoolTest.testMyThreadPool()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** @author lsx */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyThreadPoolTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testMyThreadPool</span>() {
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// 创建一个线程池实例: 使用自定义的线程工厂和拒绝策略</span>
</span></span><span style=display:flex><span>	    ThreadPoolExecutor threadPool <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ThreadPoolExecutor(
</span></span><span style=display:flex><span>	            2, 4, 10, TimeUnit.<span style=color:#a6e22e>SECONDS</span>,
</span></span><span style=display:flex><span>	            <span style=color:#66d9ef>new</span> ArrayBlockingQueue<span style=color:#f92672>&lt;&gt;</span>(2),
</span></span><span style=display:flex><span>	            <span style=color:#66d9ef>new</span> MyThreadFactory(),
</span></span><span style=display:flex><span>	            <span style=color:#66d9ef>new</span> MyRejectedPolicy());
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// 向线程池提交8个任务</span>
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// 核心线程执行2个任务，任务队列留存2个任务，拓展线程执行2个任务，其余2个任务被拒绝</span>
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1, j <span style=color:#f92672>=</span> 8; i <span style=color:#f92672>&lt;=</span> j; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>	        threadPool.<span style=color:#a6e22e>execute</span>(<span style=color:#66d9ef>new</span> MyTask(<span style=color:#e6db74>&#34;任务&#34;</span> <span style=color:#f92672>+</span> i));
</span></span><span style=display:flex><span>	    }
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// 阻止主线程结束</span>
</span></span><span style=display:flex><span>	    TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(20L);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><svg id="btt-button" class="arrow-logo" xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 384 512" onclick="scrollToTop()" title="Go to top"><path d="M177 159.7l136 136c9.4 9.4 9.4 24.6.0 33.9l-22.6 22.6c-9.4 9.4-24.6 9.4-33.9.0L160 255.9l-96.4 96.4c-9.4 9.4-24.6 9.4-33.9.0L7 329.7c-9.4-9.4-9.4-24.6.0-33.9l136-136c9.4-9.5 24.6-9.5 34-.1z"/></svg>
<script>let backToTopButton=document.getElementById("btt-button");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?backToTopButton.style.display="block":backToTopButton.style.display="none"}function scrollToTop(){window.scrollTo(0,0)}</script></div></main><footer class=footer><span>&copy; 2024 The Marauders</span>
<span>Made with &#10084;&#65039; using <a target=_blank href=https://github.com/gokarna-theme/gokarna-hugo>Gokarna</a></span></footer></body></html>