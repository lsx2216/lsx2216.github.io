<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>第3阶段-SSMs on lsx2216</title><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/</link><description>Recent content in 第3阶段-SSMs on lsx2216</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-1-MyBatis/frag/%E6%AE%8B%E5%8D%B7-MyBatis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-1-MyBatis/frag/%E6%AE%8B%E5%8D%B7-MyBatis/</guid><description>MyBatis Maven打包XML文件 Maven项目在打包时仅会将 src/main/java 中的 .java 文件进行打包，若希望将该包下的 .xml 文件一并打包，则需要在 pom.xml 中的 &amp;lt;build&amp;gt; 中进行如下配置：
pom.xml
&amp;lt;!--设置maven打包时将*Mapper文件一并打包--&amp;gt; &amp;lt;resources&amp;gt; &amp;lt;resource&amp;gt; &amp;lt;directory&amp;gt;src/main/java&amp;lt;/directory&amp;gt; &amp;lt;includes&amp;gt; &amp;lt;include&amp;gt;**/*Mapper.xml&amp;lt;/include&amp;gt; &amp;lt;/includes&amp;gt; &amp;lt;/resource&amp;gt; &amp;lt;/resources&amp;gt; MyBatisGenerator MyBatis Generator 是官网提供的根据数据表生成对应的实体类，Mapper配置，Mapper接口，MyBatis主配等文件的一个工具，仅支持单表。
添加依赖：
org.mybatis.mybatis(3.5.1) mybatis.mysql-connector-java(8.0.15)(runtime) org.mybatis.generator.mybatis-generator-core(1.3.2) 在工程的根目录下（非classpath下）开发主配 mbg.xml：
&amp;lt;plugin&amp;gt;：配置逆向工程插件，如序列化，主配文件等。 &amp;lt;commentGenerator&amp;gt;：配置是否添加工程注释，建议镇压。 &amp;lt;jdbcConnection&amp;gt;：配置JDBC连库信息。 &amp;lt;javaModelGenerator&amp;gt;：配置实体类生成位置。 &amp;lt;sqlMapGenerator&amp;gt;：配置Mapper配置文件生成位置。 &amp;lt;javaClientGenerator&amp;gt;：配置Mapper接口生成位置。 &amp;lt;table&amp;gt;：配置根据哪些数据库表生成信息。 开发主类 mybatis.util.MbgUtil 并使用main方法运行逆向工程：
再次生成时要先将之前生成的所有文件删除，否则信息叠加。 逆向工程API方法 insert()：缺省字段注入null，无主键回注，静态SQL。 insertSelective()：缺省字段被忽略，无主键回注，动态SQL。 updateByPrimaryKey()：按主键修改，缺省字段注入null，静态SQL。 updateByPrimaryKeySelective()：按主键修改，缺省字段被忽略，动态SQL。 updateByExample(XXXExample example)：按条件修改，缺省字段注入null，静态SQL： example.createCriteria().条件()：设置and条件。 example.or().条件()：设置or条件。 updateByExampleSelective(XXXExample example)：按条件修改，缺省字段被忽略，动态SQL。 deleteByPrimaryKey()：按主键删除信息。 deleteByExample(XXXExample example)：按条件删除信息。 selectByPrimaryKey()：通过主键查询信息。 selectByExample(XXXExample example)：通过条件查询符合的信息，空对象视为全查： example.setOrderByClause()：对结果集进行排序。 example.setDistinct()：对结果集去重。 countByExample(XXXExample example)：通过条件查询符合的条目数。 tst: mybatis.MbgTest Oracle主键自增 Oracle数据库不支持主键自增，可以使用如下方式进行主键回注： &amp;lt;insert id=&amp;#34;insert&amp;#34;&amp;gt; &amp;lt;!</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-1-MyBatis/qa/JB3-1-Mybatis-QA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-1-MyBatis/qa/JB3-1-Mybatis-QA/</guid><description> mybatis是哪一层的框架？ mybatis底层封装的是什么技术？ mybatis是半封装框架还是全封装框架？ mybatis和hibernate最大的区别是什么？ mybatis支持注解方式开发吗？ mybatis支持XML配置方式开发吗？ mybatis原名叫什么？ 目前mybatis的源码需要去哪个网站下载？ 你用的Mybatis是什么版本的？ 如果想使用SLF4J日志，需要引入几个依赖？ 将驱动，连接串，账号和密码配置在属性文件中有什么好处？ 日志文件 log4j.properties 的名称和位置是固定的吗？ mybatis主配文件的名称和位置是固定的吗？ &amp;lt;properties resource=&amp;quot;&amp;quot;/&amp;gt; 是做什么用的？ &amp;lt;environments&amp;gt; 和 &amp;lt;environment&amp;gt; 标签是什么关系？ &amp;lt;transactionManager&amp;gt; 是用于配置什么的？ 什么叫事务？如何保证两个业务在同一个事务中？ DQL需要事务保护吗？ mybatis如何配置事务保护？ &amp;lt;dataSource&amp;gt; 是用于配置什么的？ 连接池是做什么用的？ 连接池容量为10，当第11个线程申请连接时，如何处理？ 连接池容量为10，当第11个线程归还连接时，如何处理？ mybatis如何配置连接池？ mybatis的底层原理是什么？用文字叙述。 mybatis中的SqlSessionFactoryBuilder是做什么用的？ mybatis中的SqlSessionFactory是做什么用的，可以设计为单例么？ mybatis中的SqlSession是做什么用的，可以设计为单例么？ mybatis中的Executor是做什么用的？ mybatis中的MappedStatement是做什么用的？ mybatis中MappedStatement的输入映射和输出映射分别是什么意思？ 什么是DCL双重检查锁。 ORM是什么意思？ 你学过哪些ORM框架？ 数据库主键字段若设置了有符号sign，则java类中ORM的属性使用Integer还是Long对应？ ORM实体类中的属性必须设置setter和getter吗？ &amp;lt;typeAliases&amp;gt; 标签是做什么用的？ java.util.Map的别名是什么？ mybatis中的别名区分大小写吗？ Mapper接口属于MVC中的哪一层代码？是做什么用的？ Mapper配置是做什么用的？ Mapper配置必须和Mapper接口同名同包吗？ Mapper配置的根标签是什么？ Mapper配置必须使用Mapper接口的类全名作为命名空间吗？ 如何在主配中整包扫描Mapper接口？ Mapper接口方法的名称要和SQL语句块的什么属性对应？ Mapper接口入参要和SQL语句块的什么属性对应？ Mapper接口返回值要和SQL语句块的什么属性对应？ SQL语句块的id属性可以省略吗？ SQL语句块的parameterType属性可以省略吗？ SQL语句块的resultType属性可以省略吗？ SQL语句块中的占位符是如何写的？占位符中的值是随意编写的吗？ 如何从sqlSession中获取一个Mapper接口？ sqlSession默认需要手动提交吗？如何手动提交？ sqlSession使用完毕后需要关闭吗？为什么？ 使用哪个注解可以为接口方法的简单参数起别名？ 添加方法如何配置主键回注？ #{} 占位符和 ${} 拼接符的区别是什么？ 什么是注入漏洞？如何防止注入漏洞？ 什么是SQL重用块？有什么作用？ 查询多条的语句块的resultType是否只需要写集合泛型？ &amp;lt;resultMap&amp;gt; 是做什么用的，有哪些重要的属性？ resultMap和resultType这两个属性可以同时使用吗？ &amp;lt;id&amp;gt; 和 &amp;lt;reslut&amp;gt; 有什么区别？ &amp;lt;result&amp;gt; 中的column和property分别指向什么？ &amp;lt;result&amp;gt; 中的javaType和jdbcType分别指向什么？ mybatis二级缓存是默认开启的吗？如何设置开启？ 如何引入其他Mapper配置文件中的二级缓存配置？ mybatis注解开发和xml开发有什么区别？如何取舍？ @Results 注解的作用是什么？ mybatis注解开发中，如何配置高级映射中的 &amp;lt;id&amp;gt; 字段？ @Options 注解的作用是什么？ 如何在SQL语句中执行条件判断？ &amp;lt;if&amp;gt; 和 &amp;lt;choose&amp;gt; 的区别在哪？ &amp;lt;where&amp;gt; 标签有什么作用？ &amp;lt;trim&amp;gt; 标签有哪些常用属性？ 若要遍历一个数组类型的入参，则 &amp;lt;foreach&amp;gt; 中的 collection 值写什么？ 若要遍历一个List类型的入参，则 &amp;lt;foreach&amp;gt; 中的 collection 值写什么？ &amp;lt;foreach&amp;gt; 中的 item 值写什么？ &amp;lt;foreach&amp;gt; 中的 open/close/separator 属性分别需要配置什么值？ &amp;lt;set&amp;gt; 标签有什么作用？ _parameter 用来表示什么？ mybatis配置一对一关系和一对多关系有几种方案？ 什么叫级联查询？如何解决级联查询结果中的重复字段，如 deptno？ 级联查询时，和java属性名相同的表字段也需要使用 &amp;lt;resultMap&amp;gt; 进行映射吗？ 分步查询时，和java属性名相同的表字段也需要使用 &amp;lt;resultMap&amp;gt; 进行映射吗？ 分步查询的第2步SQL块，必须配置对应的接口方法吗？ 分步查询的第1步SQL块如何调用第2步SQL块？可以自动传递什么个值到第2步SQL块？ 分步查询时，第2步SQL块如何接收和使用第1步SQL块传递过来的值？ 什么是N+1问题？如何解决？ 级联查询有必要设置延迟加载吗？ &amp;lt;association&amp;gt; 和 &amp;lt;collection&amp;gt; 有什么区别？ &amp;lt;collection&amp;gt; 中使用哪个属性配置关联属性的泛型类型？ @One 和 @Many 有什么区别？</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-2-Spring/frag/%E6%AE%8B%E5%8D%B7-Spring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-2-Spring/frag/%E6%AE%8B%E5%8D%B7-Spring/</guid><description>AOP五大通知 武技：
添加依赖：org.springframework.spring-aspects(4.3.14.RELEASE) 开发客户类 spring.aspect.five.CustomerServiceImpl： 标记 @Component 以被spring容器扫描和管理。 在客户类中开发业务方法： void delete(String name, Integer id) List&amp;lt;String&amp;gt; select(String name) void update(Map&amp;lt;String, Object&amp;gt; user) List&amp;lt;Integer&amp;gt; insert(Map&amp;lt;String, Object&amp;gt; user) 注解配置 心法：
开发切面类：spring.aspect.advice.CustomerAspectByAnn： 添加 @Aspect 表示这是一个切面类。 添加 @Component 表示该类需要被spring容器扫描和管理。 开发切面类切点方法：方法名随意仅用于区分，但方法体必须为空： @Pointcut(&amp;quot;execution(* c.j.s.a.a.CustomerServiceImpl.delete(..))&amp;quot;) @Pointcut(&amp;quot;execution(* c.j.s.a.a.CustomerServiceImpl.select(..))&amp;quot;) @Pointcut(&amp;quot;execution(* c.j.s.a.a.CustomerServiceImpl.update(..))&amp;quot;) @Pointcut(&amp;quot;execution(* c.j.s.a.a.CustomerServiceImpl.insert(..))&amp;quot;) 在切面类中开发前后通知方法：在业务方法执行前后做一些事，但无法阻止方法的运行： 对前置通知方法标记 @Before(&amp;quot;deletePointCut())。 对后置通知方法标记 @After(&amp;quot;deletePointCut())。 若想在通知方法中获取业务方法形参： 在注解中的切点方法名后附加 &amp;amp;&amp;amp;args(形参列表)。 在注解中添加额外的 argNames=&amp;quot;形参列表&amp;quot;，更规范。 对通知方法添加形参，类型与业务方法一致，名与 args() 中一致。 在切面类中开发返回后通知：在业务方法return之后做一些事，但无法阻止方法的运行： 对返回后通知方法标记 @AfterReturning(&amp;quot;selectPointCut())。 在注解中添加额外的 returning 属性指定方法的返回值。 对通知方法添加形参，类型与业务方法返回值一致，名与 returning 的值一致。 若想在通知方法中获取业务方法形参，一样可以使用 args()。 在切面类中开发异常通知：在业务方法发生异常后做一些事： 对异常通知方法标记 @AfterThrowing(&amp;quot;updatePointCut())。 在注解中添加额外的 throwing 属性指定方法的异常对象。 对通知方法添加形参，类型与业务方法异常一致，名与 throwing 的值一致。 若想在通知方法中获取业务方法形参，一样可以使用 args()。 在切面类中开发环绕通知：实现前后、返回后和异常通知的所有功能： 对环绕通知方法标记 @Around(&amp;quot;insertPointCut())。 通知方法的参数必须是 ProceedingJoinPoint，代表连接点： pjp.</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-2-Spring/qa/JB3-2-Spring-QA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-2-Spring/qa/JB3-2-Spring-QA/</guid><description>Spring是Java开发的开源框架吗？
Spring解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发，对吗？
Spring除了XML配置外，还有哪两种配置方式？
Spring中使用到了哪些设计模式？
你使用的Spring是什么版本的？
Spring框架的核心依赖的名称是什么？
Spring主配文件的名称是固定的吗？
Spring主配文件的位置是固定的吗？
如何理解SpringIOC？
为何要使用SpringIOC？SpringIOC解决了哪些问题？
如何理解SpringDI？
Spring的核心特性是什么？
从Spring容器中获取bean有哪三种方式？
一个 &amp;lt;bean&amp;gt; 的id属性配置的是什么？可以省略吗？
一个 &amp;lt;bean&amp;gt; 的name属性配置的是什么？可以省略吗？
一个 &amp;lt;bean&amp;gt; 的class属性配置的是什么？可以省略吗？
ClassPathXmlApplicationContext容器在使用完毕之后需要销毁吗？
可以使用 &amp;lt;bean&amp;gt; 标签来直接管理一个接口类吗？
bean有哪三种创建方式？默认使用哪种？
我们可以通过哪些方式将bean加载到Spring容器中？
spring容器使用无参构造器的方式创建实例，和使用工厂的方式创建实例有什么不同？
spring容器使用静态工厂的方式创建实例，和使用实例工厂的方式创建实例有什么不同？
什么是bean的懒加载机制？默认是懒还是不懒？
bean的作用范围分为哪两种？默认是哪一种？
单例的bean可不可以设置懒加载？
原型的bean可不可以设置懒加载？
init-method 属性是什么意思？
destory-method 属性是什么意思？
使用哪个标签可以在一个 &amp;lt;bean&amp;gt; 中注入属性。
如果需要注入的属性是一个Integer，则使用 &amp;lt;property&amp;gt; 的哪个属性设置值？
如果需要注入的属性是一个实体类，则使用 &amp;lt;property&amp;gt; 的哪个属性设置值？
BeanFactory是什么？
Spring中，getBean() 方法源自于哪个类或接口？
一个Bean的生命周期分为哪几个步骤？
Spring是如何解决循环依赖问题的？
什么是动态代理？
jdk动态代理对客户有什么要求？
CGLIB动态代理对客户有什么要求？
final类可以使用CGLIB动态代理吗？
AOP在你的项目中主要用在了什么地方？
什么是切面类？做什么用的？
什么是切点方法？做什么用的？
什么是前置通知，能做什么用？
什么是后置通知，能做什么用？
什么是异常通知，能做什么用？
什么是返回后通知，能做什么用？
什么是环绕通知，能做什么用？
@Autowired可以标记在哪个地方？
@Autowired是如何自动注入一个 &amp;lt;bean&amp;gt; 的？
@Autowired + @Qualifier组合时，是如何自动注入一个 &amp;lt;bean&amp;gt; 的？</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-2-Spring/res/%E5%B0%8F%E8%AF%B4-JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-2-Spring/res/%E5%B0%8F%E8%AF%B4-JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</guid><description>JDK动态代理微小说
我是一名自于 UserService 公司的老板，目前我们公司主营的四个业务是增删改查 ，我希望在每个业务执行之前都能鉴权，在每个业务之后都能打印日志，如果每个业务都手动添加这两套代码的话实在是太麻烦了，所以我想去代理公司，和他们谈谈合作。
经过高人的指点，我来到了一个僻静的小山村，映入眼帘的是两家代理公司，一家叫jdk动态代理公司，一家叫cglib动态代理公司，我准备先去jdk动态代理公司碰碰运气。
走进这家代理公司，迎面走出来一个人，满脸堆笑的对我说：“欢迎光临，这里是jdk代理公司，全名 JdkProxy，我们公司是合理合法的正规公司，这是我们公司的营业证明，请问您是需要聘请代理帮您做事吗？”
说着，他拿出一个公司营业许可证明文件给我看，我看到如下内容：
public class JdkProxy implements InvocationHandler{} “是的，我是 UserService 公司的老板，想跟贵公司谈谈合作。”
“没问题，但是有一点我需要事先说明，我们公司有明文规定，只代理有接口的客户，因为我们的代理也需要来实现您的客户的接口，如果您的客户没有实现任何接口，请您出门左转，去隔壁cglib他们家聘用代理。”
“这个可以，我们公司都是接口加实现类的工作模式。” 我回答道。
“好的，接下来我会为您进行登记，请您编写一个召唤代理的咒语好吗？” 说着，他拿出一个本子，准备在上面写些什么。
“咒语的话，我觉得，要不然就叫 getProxy() 吧！” 我回答道。
“没问题，对了，召唤代理的时候，您还需要告诉我们为您公司的哪位员工进行代理，因为他才是我们的具体的客户对象，我们也需要为他进行登记。” 说着，他在本上写下如下内容：
private Object customer; public Object getProxy(Object customer){ this.customer = customer; } “接下来，我要为您编写这个咒语了，对了，召唤代理的时候，需要提供具体客户的类加载器和接口们，否则召唤不了代理哦，不要担心这个，就像您开房要提供身份证信息一样，我们也会为您保密这些信息的。” 说着，他在咒语的方法 getProxy() 中又添加了如下内容： return Proxy.newProxyInstance( customer.getClass().getClassLoader(), customer.getClass().getInterfaces(), this); “好了，咒语已经编写完成了，以后想召唤代理的时候，您只需要喊出 getProxy()，就可以召唤一个代理了，那么接下来，您需要提供一下代理的工作清单 invoke() ，也就是告诉我们，您聘用代理，需要它们做些什么内容，您召唤的代理会按照这个清单一步一步执行的。”
“嗯，我需要这个代理在帮我做任何事之前，都能帮我鉴权，并且在做完事之后，帮我打印日志。”
“好的。” 说着他在 invoke() 中添加了如下内容：
System.out.println(&amp;#34;鉴权...&amp;#34;); Object methodReturn = method.invoke(customer, args); System.out.println(&amp;#34;日志...&amp;#34;); return methodReturn; 我又问道：“需要我提前告诉您，我们要做的事情吗？”
“这个不需要，我们代理的工作模式是预编译，会自动在您使用代理的时候，通过反射的方式了解到您要做的业务方法，然后帮您去做( method.invoke()) ，但是每次都需要提供具体的客户和方法的参数，当然，最后我们会把业务方法的结果给您返回去。”</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-3-SpringMVC/frag/%E6%AE%8B%E5%8D%B7-SpringMVC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-3-SpringMVC/frag/%E6%AE%8B%E5%8D%B7-SpringMVC/</guid><description>S01. FileUpload上传 心法: FileUpload
FileUpload是由Apache提供的上传文件的相关组件。 武技: 在子项目整合FileUpload功能
在父项目中锁定版本: &amp;lt;fileupload-version&amp;gt;1.5&amp;lt;/fileupload-version&amp;gt; 在父项目中管理依赖: &amp;lt;!--commons-fileupload--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;commons-fileupload&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;commons-fileupload&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${fileupload-version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 在子项目中添加依赖: &amp;lt;!--commons-fileupload--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;commons-fileupload&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;commons-fileupload&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 在SpringMVC主配中配置文件上传相关参数: &amp;lt;!--配置文件上传解析器: id的值是固定的--&amp;gt; &amp;lt;bean id=&amp;#34;multipartResolver&amp;#34; class=&amp;#34;org.springframework.web.multipart.commons.CommonsMultipartResolver&amp;#34;&amp;gt; &amp;lt;!--设置全部文件的字节数限制200M，默认-1，表示无限制--&amp;gt; &amp;lt;property name=&amp;#34;maxUploadSize&amp;#34; value=&amp;#34;209715200&amp;#34;/&amp;gt; &amp;lt;!--设置单个文件的字节数限制为5M，默认-1，表示无限制--&amp;gt; &amp;lt;property name=&amp;#34;maxUploadSizePerFile&amp;#34; value=&amp;#34;5242880&amp;#34;/&amp;gt; &amp;lt;!--设置字符编码，默认ISO-8859-1--&amp;gt; &amp;lt;property name=&amp;#34;defaultEncoding&amp;#34; value=&amp;#34;utf-8&amp;#34;/&amp;gt; &amp;lt;/bean&amp;gt; E01. 文件上传 武技: 测试文件上传功能
开发上传本地文件的工具方法 LocalFileUtil -&amp;gt; upload(): package com.lsx.util; /** @author lsx */ @SuppressWarnings(&amp;#34;all&amp;#34;) public class LocalFileUtil { /** * 将文件上传到本地指定目录中 * * @param multipartFile 文件实例 * @param dir 文件上传目录 * @return 本地文件完整路径 + 文件名 */ @SneakyThrows public static String upload(MultipartFile multipartFile, String dir) { if (null == multipartFile || StrUtil.</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-3-SpringMVC/frag/%E6%AE%8B%E5%8D%B7-SSM%E6%95%B4%E5%90%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-3-SpringMVC/frag/%E6%AE%8B%E5%8D%B7-SSM%E6%95%B4%E5%90%88/</guid><description>CH01. 搭建SSM环境 EP01. 添加SSM依赖 武技: 在 ssm-merge 子项目中整合Spring + Mybatis + SpringMVC框架
在父项目中锁定版本: &amp;lt;junit-version&amp;gt;4.13.2&amp;lt;/junit-version&amp;gt; &amp;lt;lombok-version&amp;gt;1.18.24&amp;lt;/lombok-version&amp;gt; &amp;lt;hutool-version&amp;gt;5.8.14&amp;lt;/hutool-version&amp;gt; &amp;lt;mysql-connector-j-version&amp;gt;8.0.33&amp;lt;/mysql-connector-j-version&amp;gt; &amp;lt;mybatis-version&amp;gt;3.5.0&amp;lt;/mybatis-version&amp;gt; &amp;lt;spring-version&amp;gt;5.2.15.RELEASE&amp;lt;/spring-version&amp;gt; &amp;lt;druid-version&amp;gt;1.1.6&amp;lt;/druid-version&amp;gt; &amp;lt;mybatis-spring-version&amp;gt;1.3.0&amp;lt;/mybatis-spring-version&amp;gt; &amp;lt;servlet-version&amp;gt;3.1.0&amp;lt;/servlet-version&amp;gt; 在父项目中管理依赖: &amp;lt;!--junit--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${junit-version}&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--lombok--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${lombok-version}&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--hutool-all--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;cn.hutool&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;hutool-all&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${hutool-version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--mysql-connector-j--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-j&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${mysql-connector-j-version}&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--mybatis--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${mybatis-version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--spring-jdbc--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${spring-version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--spring-context-support--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-context-support&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${spring-version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--spring-test--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-3-SpringMVC/frag/%E6%AE%8B%E5%8D%B7-Struts2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-3-SpringMVC/frag/%E6%AE%8B%E5%8D%B7-Struts2/</guid><description>CH1. Struts2基本概念 Struts2是一个非常优秀的MVC开源框架，由传统的Struts1和WebWork两个经典的框架合并而来，核心就是WebWork，采用拦截器的机制来处理用户请求，它虽然是Struts1的升级版，但是相对于Struts1改动很大: 允许POJO对象作为action； 支持更多视图技术（JSP、freemarker等）； 与servlet解耦，完全脱离servlet-controller，如request，session等； 基于spring AOP思想的拦截器机制，更容易拓展； 支持文件上传下载； ognl表达式应用； 支持EL表达式； 下载安装 Struts2： struts-2.5.12-all.zip 目录结构： apps：基于Struts2的示例应用 docs：Struts2相关文档，API等 lib：Struts2核心类库以及第三方插件类库 src：Struts2的源码 访问配通 新建web项目 &amp;raquo; 导struts2包 &amp;raquo; 编写Action &amp;raquo; 配置Action &amp;raquo; 访问Action 引入依赖： org.apache.struts:struts2-core:2.5.12 开发控制器类 控制器类也被称为动作类，控制器类的生命周期就是一次请求： 创建：每次请求的时候都会创建一个Action对象（非单例，线程安全的）。 销毁：当Action的动作类执行完方法后，就消失了。 Action就是处理用户请求的动作类，类似于javaweb中的servlet。 /** * 类名后缀尽量采用Action，可读性强，当然也可以使用controller、servlet等。 * 方法修饰符使用public，因为需要外部访问。 * 方法返回值是String类型。 * */ public class HelloAction { public String hello() { System.out.println(&amp;#34;hello!!&amp;#34;); return &amp;#34;success&amp;#34;; } } 普通控制器类 方法修饰：public 方法返回值：String 方法参数：不需要 方法名：默认execute：当你不在xml文件中设置method的时候，会自动去寻找execute方法。 实现Action接口的控制器类 让普通的bean实现Action接口，就是比第一个多提供了一些情景常量。 SUCCESS：返回成功页面（你必须设置了result的name=&amp;ldquo;success&amp;rdquo;） NONE：不返回任何页面，也不报错 ERROR：返回错误页面 INPUT：返回当提交表单发生错误，就跳回到表单页面 LOGIN：返回登录界面 继承ActionSupport类的控制器类 让你的控制器类继承ActionSupport类，开发中常用。 配置控制器类 Action需要配置两个xml文件，一个是struts.</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-3-SpringMVC/qa/JB3-3-SpringMVC-QA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-3-SpringMVC/qa/JB3-3-SpringMVC-QA/</guid><description> spring是哪家公司开发的？ springmvc是表现层框架吗？ springmvc的一个核心三个组件分别是什么？ springmvc对比servlet和struts2来说，谁的效率高？ springmvc的访问流程是怎样的？ springmvc的核心依赖包是什么？ springmvc为什么要在web.xml中配置一个 DispatcherServlet？ DispatcherServlet 拦截 *.action 和拦截 / 有什么区别？ DispatcherServlet 会默认去寻找哪个核心配置文件？ DispatcherServlet 如果拦截了 /，导致静态资源无法访问怎么办？ 核心配置文件springmvc.xml文件的名字和位置都是不可更改的吗？ &amp;lt;mvc:annotation-driven /&amp;gt; 有什么作用？ &amp;lt;context:component-scan /&amp;gt; 主要是为了扫描哪四种注解？ InternalResourceViewResolver 视图解析器的作用是什么？ InternalResourceViewResolver 视图解析器的前后缀只在响应中生效吗？ @RequestMapping 和 @ResponseBody 有什么区别？ @RequestMapping 里面有哪些属性值，分别的作用是什么？ @RequestMapping 如果定义在控制器类上会有什么效果？ @RequestMapping 可以单独定义在控制器类上吗？ @RequestMapping 可以映射多个路径吗？ @RequestMapping 模糊映射规则中，?、*、** 分别代表什么意思？ @RequestMapping 中的 method = RequestMethod.POST 代表什么意思？ 大部分浏览器不支持put和delete请求，springmvc应该如何解决呢？ tomcat8以上版本不支持put和delete请求，springmvc应该如何解决呢？ springmvc如何解决post提交的中文乱码问题呢？ springmvc如何使用servlet原生对象？ springmvc可以利用哪个注解获取请求头信息？ springmvc可以利用哪个注解获取Cookie信息？ springmvc可以利用哪个注解获取Rest风格参数？ springmvc可以利用哪个注解获取键值对参数？ springmvc可以直接接收int数组和String数组类型的数据吗？ springmvc可以直接接收引用数据类型参数吗？如一个User实体类? springmvc如何接收一个 List&amp;lt;Pojo&amp;gt; 类型的参数完成批量修改？ 自定义一个类型转换器需要我们的转换器类实现什么接口？并覆盖什么方法？ 我们自定义的类型转换器需要在核心配置文件中配置吗？ @NumberFormat 和 @DateTimeFormat 分别是干什么用的？可以直接使用吗？ BindingResult 参数的作用是什么？ springmvc的存值方式有几种？分别是什么范围域的存值？ @sessionAttributes 注解是干什么的？如何使用它？ @ModeAttribute 注解是干什么用的？如何使用它？ springmvc转页的方式有几种？ 返回值为String的方法，如何实现重定向和转发？ 文件上传需要引入什么依赖？ 文件上传的时候必须在表单处添加 enctype=&amp;quot;multipart/form-data&amp;quot; 吗？ 自定义拦截器需要实现什么接口，并重写什么方法？ 自定义拦截器需要在核心配置文件中配置吗？ 自定义拦截器可以配置多个吗？执行的时候按照怎样的顺序执行？ 国际化属性文件的格式是什么？ 如何使用spring的 &amp;lt;spring:message /&amp;gt; 标签读取国际化信息？ springmvc中，异常处理的顶级接口是谁？</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-3-SpringMVC/res/%E5%B0%81%E8%A3%85Result%E5%93%8D%E5%BA%94%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-3-SpringMVC/res/%E5%B0%81%E8%A3%85Result%E5%93%8D%E5%BA%94%E7%B1%BB/</guid><description>S01. 开发响应枚举类 武技: 开发响应枚举类，用于和前端约定响应状态
开发响应枚举类 ResultCode: com.lsx.result.ResultCode
/** @author lsx */ @Getter public enum ResultCode { SUCCESS(200, &amp;#34;请求成功&amp;#34;), FAILED(500, &amp;#34;服务器错误&amp;#34;), BAD_PARAM(400, &amp;#34;请求参数有误&amp;#34;), VALIDATE_FAILED(403, &amp;#34;参数校验失败&amp;#34;), METHOD_NOT_ALLOW(405, &amp;#34;请求类型不匹配&amp;#34;), TOKEN_FAILED(1001, &amp;#34;Token过期或失效&amp;#34;), TOKEN_EXPIRING_SOON(1002, &amp;#34;Token即将过期&amp;#34;); private final int CODE; private final String MESSAGE; ResultCode(int code, String msg) { this.CODE = code; this.MESSAGE = msg; } } S02. 开发响应工具类 武技: 开发响应类，用于统一封装响应结果
开发响应类 Result: com.lsx.result.Result
/** @author lsx */ @Data @AllArgsConstructor @NoArgsConstructor public class Result&amp;lt;T&amp;gt; implements Serializable { /** 响应代码 */ private Integer code; /** 响应描述 */ private String message; /** 响应数据 */ private T data; /** * 创建Result类，手动传递响应代码，响应描述和响应数据 * * @param code 响应代码 * @param message 响应描述 * @param data 响应数据 */ public Result(int code, String message, T data) { this.</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-4-SpringBoot/draw/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-4-SpringBoot/draw/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/</guid><description>==⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠==
Text Elements 弃用 ^MJ3cOUij
1 bit ^2JiYTSmT
12 bit ^tUemv1K9
同1毫秒内产生的不同ID的序号 （最多4096个） ^b11tIwIv
机房ID （最多32个） ^wtq8HqUj
5 bit ^MFMwHUHu
机器ID （最多32个） ^5otvJCkT
5 bit ^EpTxkA2E
时间戳 （最多69年的时间） ^YCCUf4mG
41 bit ^Dj4HfeuU
%%
Drawing { &amp;#34;type&amp;#34;: &amp;#34;excalidraw&amp;#34;, &amp;#34;version&amp;#34;: 2, &amp;#34;source&amp;#34;: &amp;#34;https://github.com/zsviczian/obsidian-excalidraw-plugin/releases/tag/2.0.25&amp;#34;, &amp;#34;elements&amp;#34;: [ { &amp;#34;type&amp;#34;: &amp;#34;rectangle&amp;#34;, &amp;#34;version&amp;#34;: 258, &amp;#34;versionNonce&amp;#34;: 1740471753, &amp;#34;isDeleted&amp;#34;: false, &amp;#34;id&amp;#34;: &amp;#34;r7CF9ApcO29CP9rjNBFol&amp;#34;, &amp;#34;fillStyle&amp;#34;: &amp;#34;solid&amp;#34;, &amp;#34;strokeWidth&amp;#34;: 0.</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-4-SpringBoot/frag/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-4-SpringBoot/frag/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</guid><description>[!NOTE] Java道经第3卷 - 第4阶 - SpringBoot v3-4-ssm-springboot/shardingsphere
S01. 分库分表 E01. 分库分表概念 1. 何为分库分表 心法：通常分库与分表的操作会同时进行，以至于我们习惯性的将它们合在一起叫做分库分表
单机的容量可以随意扩展，但数据库的连接数却是有限的，它自身就很容易会成为系统的瓶颈： 当数据量过大时，导致数据库性能持续下降， 严重影响用户体验。 当访问量过高时，导致连接数耗尽抛出 too many connections 异常，数据库宕机。 分库分表通过将数据分散到多个数据库或表中，从而有效提升系统的处理能力和稳定性： 分库：就是将1个库拆为N个库。 分表：就是将1个表拆为N个表 分库分表 描述 优点 突破单体数据库的瓶颈，减少数据库负担，提升数据库性能 缺点 系统复杂度提升，需要额外考虑事务一致性，全局ID，跨节点查询（分页，排序等），数据迁移，服务治理等问题 武技：测试 MySQL 数据库的最大连接数
-- 151 show variables like &amp;#39;max_connections&amp;#39; 2. 何时分库分表 心法：什么情况下需要考虑进行分库分表
阿里开发手册建议，单表行数超500万行或者单表容量超过2GB时，推荐分库分表。 然而实际中很多公司单表数据几千万、 亿级别仍然不选择分库分表。 单表数据量 优化方案推荐 百万级以内 考虑通过添加从库、优化索引等手段提升性能 千万级以上 考虑分库分表 3. 分库分表产品 心法：常见的分库分表产品工具
客户端直连模式：直接在业务层连接数据库，性能略高： 优点：使用简单，通常引入一个jar包即可。 缺点：升级成本高，jar包若升级或Bug修改，则所有相关项目都要跟着升级。 代理连库模式：通过代理连接数据库，性能略低： 优点：升级成本低，jar包若升级或Bug修改，只需要重新部署代理服务即可，业务方无感知。 缺点：使用复杂，需要搭建单独的服务（还需要考虑高可用），有一定的维护成本。 对比项 shardingsphere cobar mycat TDDL mysql fabric 连接模式 两种都支持 代理连库 代理连库 客户端直连 代理连库 数据库支持 任意 仅MySQL 仅MySQL MySQL，Oracle，SQLServer 仅MySQL ORM框架支持 任意 任意 任意 任意 任意 工具来源 Apache基金会 阿里巴巴 社区爱好者 阿里巴巴 MySQL官方 社区活跃度 非常活跃 相对较低 相对较低 相对较低 相对较低 E02.</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-4-SpringBoot/frag/%E6%AE%8B%E5%8D%B7-Guava/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-4-SpringBoot/frag/%E6%AE%8B%E5%8D%B7-Guava/</guid><description>Guava本地缓存 心法: Guava缓存
Guava是谷歌出品的一款本地缓存，使用流程如下: 先从Guava中尝试获取指定的值，若存在则直接返回，视为缓存命中。 若缓存中不存在，则执行回调函数，查询数据库，并将结果缓存到Guava中，过期时间自定义。 每次重启项目都会清空Guava本地缓存中的全部数据。 武技: 在子项目中整合Guava本地缓存
在父项目中锁定版本: &amp;lt;guava-version&amp;gt;31.1-jre&amp;lt;/guava-version&amp;gt; 在父项目中管理依赖: &amp;lt;!--guava--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.google.guava&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;guava&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${guava-version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 在子项目中引入依赖: &amp;lt;!--guava--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.google.guava&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;guava&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 开发Guava缓存工具类 GuavaUtil: package com.lsx.util; /** @author lsx */ public class GuavaUtil { /** 使用静态内部类保证单例 */ private static final class CacheHolder { /** 10分钟的缓存实例 */ private static final Cache&amp;lt;String, Object&amp;gt; tenMinutesCache = CacheBuilder.newBuilder() .initialCapacity(10) .maximumSize(100) .concurrencyLevel(5) .expireAfterWrite(600, TimeUnit.SECONDS) .recordStats() .build(); /** 30分钟的缓存实例 */ private static final Cache&amp;lt;String, Object&amp;gt; halfHourCache = CacheBuilder.</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-4-SpringBoot/frag/%E6%AE%8B%E5%8D%B7-SpringBoot/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-4-SpringBoot/frag/%E6%AE%8B%E5%8D%B7-SpringBoot/</guid><description>Servlet原生组件 心法: springboot支持原生的servlet组件，如servlet过滤器和servlet监听器等:
开发原生servlet类 c.j.s.servlet.BeanServlet，无需添加注解。 开发原生过滤器类 c.j.s.servlet.filter.BeanFilter，无需添加注解。 开发原生监听器类 c.j.s.servlet.listener.BeanListener，无需添加注解。 开发配置类 c.j.s.servlet.BeanServletConfig: IOC o.s.b.w.s.ServletRegistrationBean 类，利用构造传入servlet实例和路由。 开发配置类 c.j.s.servlet.filter.BeanFilterConfig: IOC o.s.b.w.s.FilterRegistrationBean 过滤器链类。 filters.setFilter(): 在过滤器链中加入自定义过滤器。 filters.addUrlPatterns(): 在过滤器链中加入自定义过滤器拦截规则。 开发配置类 c.j.s.servlet.listener.BeanListenerConfig: IOC o.s.b.w.s.ServletListenerRegistrationBean 监听器类，利用构造传入监听器实例。 每个监听对应一个 @Bean。 psm测试: controller/servlet/bean。 注解配置方案 **流程: **
开发原生servlet类 c.j.s.servlet.ScanServlet，标记 @WebServlet。 开发原生过滤器类 c.j.s.servlet.filter.ScanFilter，标记 @WebFilter。 开发原生监听器类 c.j.s.servlet.listener.ScanListener，标记 @WebListener。 在启动类中使用 @ServletComponentScan 扫描servlet类，过滤器类和监听器类所在包。 psm测试: controller/servlet/scan。 同时配置方案 **流程: **
开发原生servlet类 c.j.s.servlet.ContextServlet，无需添加注解。 开发原生过滤器类 c.j.s.servlet.filter.ContextFilter，无需添加注解。 开发原生监听器类 c.j.s.servlet.listener.ContextListener，无需添加注解。 让启动类实现 ServletContextInitializer 接口并重写 onStartup(): context.addServlet().addMapping(): 配置servlet类并设置路由。 context.addFilter().addMappingForUrlPatterns(): 配置过滤器类并设置拦截规则。 context.addListener(): 配置监听器类。 psm测试: controller/servlet/context。 整合Thymeleaf 心法: Thymeleaf</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-4-SpringBoot/frag/%E6%AE%8B%E5%8D%B7-WebFlux/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-4-SpringBoot/frag/%E6%AE%8B%E5%8D%B7-WebFlux/</guid><description>WebFlux编程 心法: 响应式编程思维
假设一个请求需要做三件事ABC，非响应式的编程思路是这样的: ABC三个任务需要分配三个线程，T1，T2和T3。 T1抢到资源，执行任务A，其余任务阻塞。 任务A执行完毕，得到相应结果，但等待。 T3抢到资源，执行任务C，其余任务阻塞。 任务C执行完毕，得到相应结果，但等待。 T2抢到资源，执行任务B，得到相应结果。 此时ABC三个任务都有了结果，一并将其返回，客户端一次性得到结果。 共消耗3个线程资源。 假设一个请求需要做三件事ABC，响应式的编程思路是这样的: ABC三个任务需要仅需要一个线程T1。 T1抢到资源，执行任务A，提交任务后立刻得到结果，如 &amp;ldquo;任务A执行中，请等待&amp;hellip;&amp;quot;。 T1继续执行任务B，提交任务后立刻得到结果，如 &amp;ldquo;任务B执行中，请等待&amp;hellip;&amp;quot;。 T1继续执行任务C，提交任务后立刻得到结果，如 &amp;ldquo;任务C执行中，请等待&amp;hellip;&amp;quot;。 可以发现ABC三个任务是不阻塞的。 任务A执行完毕，得到结果，可以流数据形式直接返回。 任务B执行完毕，得到结果，可以流数据形式直接返回。 任务C执行完毕，得到结果，可以流数据形式直接返回。 客户端看到的是一部分部分的流数据。 总耗时不变，但仅消耗1个线程资源（提升了线程伸缩性）。 总结: 响应式编程可利用较少的线程数或硬件资源来处理任务，提高系统的伸缩性，但不会让程序运行的更快。 心法: WebFlux
WebFlux是Spring5中的异步非阻塞响应式编程框架。 WebFlux不依赖servlet，不能部署为war包，不使用webapp目录。 WebFlux使用 ServletRequest 请求对象和 ServletResponse 响应对象。 武技: 创建 springboot-webflux 子项目: 用于测试webflux效果
添加三方依赖: spring-boot-starter-webflux 比 spring-boot-starter-web 优先级低，共存时失效。 &amp;lt;!--三方依赖--&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;!--spring-boot-starter-webflux--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-webflux&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--reactor-property--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.projectreactor&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;reactor-property&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;property&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--lombok--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt; &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--spring-boot-starter-property--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-property&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;property&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 开发启动类 WebFluxApp: package com.</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-4-SpringBoot/qa/JB3-4-Springboot-QA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-4-SpringBoot/qa/JB3-4-Springboot-QA/</guid><description>什么是HTTP协议？
HTTP协议的底层是什么协议？
BS架构和CS架构有什么区别？
如何解决端口占用问题？
GET请求有请求体吗？POST请求有请求体吗？
GET请求有请求头吗？POST请求有请求头吗？
GET和POST谁更快？
GET和POST谁更安全？
GET和POST谁的数据携带量更大？
POST请求是否可以使用查询串？
springboot最大的特点是什么？
你使用的springboot版本是多少？
springboot框架可以简化项目搭建过程，开发过程和部署过程吗？
springboot项目是独立运行的，还是需要依赖外部web容器才能运行的？
springboot中的 &amp;lt;parent&amp;gt; 标签是干什么用的？
springboot项目的所有第三方依赖都会根据 &amp;lt;parent&amp;gt; 自动寻找适配的依赖版本吗？
启动类main方法中的哪行启动代码如何编写？
@SpringBootApplication注解有什么用？
控制类中的@ResponseBody注解有什么用？
控制类中的@RequestMapping注解有什么用？标记在类上和方法上有什么不同？
控制类中的@RestController注解组合了哪两个注解？
Get请求和Post请求有什么区别？
浏览器地址栏发送的请求都是Get请求吗？
对于一个简单参数，标记@RequestParam和不标记@RequestParam有什么区别？
@RequestParam中的value属性有什么作用？
@RequestParam中的required属性有什么作用？
@RequestParam中的defaultValue属性有什么作用？
springboot的控制方法是否可以直接使用数组类型的形参接收同名的URL请求参数？
springboot的控制方法是否可以直接使用实体类接收URL请求参数？
springboot的控制方法直接使用实体类接收URL请求参数时，是否可以添加@RequestParam？
springboot的控制方法直接使用实体类接收URL请求参数时，是否支持连调？
springboot使用哪个注解获取请求头中的Host值？
@PathVariable和@RequestParam在获取请求数据的时候有什么区别？
@CookieValue是做什么用的？
@SpringBootApplication注解会自动装配哪些类？
springboot中的@ComponentScan默认的扫描范围是什么？
什么叫全局异常处理？
@ControllerAdvice 是做什么用的？
springboot中的 @EnableScheduling 是做什么用的？
@Scheduled 中的fixedDelay和fixedRate有什么区别？
@Scheduled 中支持cron表达式吗？
异步执行方法不占用主线程资源吗？可以提高项目执行效率吗？
异步任务对比同步任务的优势在哪里？
是所有的任务都适合使用异步任务吗？
springboot中的 @EnableAsync 是做什么用的？
无返回值时Future的泛型应该写什么？
拦截器和拦截器链是什么关系？
拦截器是作用在请求阶段还是作用在响应阶段？
HandlerInterceptor中的preHandle()，postHandle()和afterCompletion() 分别作用在什么时机？
postHandle()多用于什么场景？
和afterCompletion()多用于什么场景？
拦截器的拦截规则和排除规则可以同时设置吗？
RestTemplate是干什么用的？
springboot默认支持的日志框架是什么？
logback可以同时将日志打印在控制台和日志文件中吗？
日志文件的后缀是什么？
常用的四种日志级别从小到大分别是什么？</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-4-SpringBoot/res/Echarts%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-4-SpringBoot/res/Echarts%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE/</guid><description>theme = { // 全图默认背景 // backgroundColor: &amp;#39;rgba(0,0,0,0)&amp;#39;, // 默认色板 color: [&amp;#39;#ff7f50&amp;#39;, &amp;#39;#87cefa&amp;#39;, &amp;#39;#da70d6&amp;#39;, &amp;#39;#32cd32&amp;#39;, &amp;#39;#6495ed&amp;#39;, &amp;#39;#ff69b4&amp;#39;, &amp;#39;#ba55d3&amp;#39;, &amp;#39;#cd5c5c&amp;#39;, &amp;#39;#ffa500&amp;#39;, &amp;#39;#40e0d0&amp;#39;, &amp;#39;#1e90ff&amp;#39;, &amp;#39;#ff6347&amp;#39;, &amp;#39;#7b68ee&amp;#39;, &amp;#39;#00fa9a&amp;#39;, &amp;#39;#ffd700&amp;#39;, &amp;#39;#6699FF&amp;#39;, &amp;#39;#ff6666&amp;#39;, &amp;#39;#3cb371&amp;#39;, &amp;#39;#b8860b&amp;#39;, &amp;#39;#30e0e0&amp;#39;], // 图表标题 title: { x: &amp;#39;left&amp;#39;, // 水平安放位置，默认为左对齐，可选为： // &amp;#39;center&amp;#39; ¦ &amp;#39;left&amp;#39; ¦ &amp;#39;right&amp;#39; // ¦ {number}（x坐标，单位px） y: &amp;#39;top&amp;#39;, // 垂直安放位置，默认为全图顶端，可选为： // &amp;#39;top&amp;#39; ¦ &amp;#39;bottom&amp;#39; ¦ &amp;#39;center&amp;#39; // ¦ {number}（y坐标，单位px） //textAlign: null // 水平对齐方式，默认根据x设置自动调整 backgroundColor: &amp;#39;rgba(0,0,0,0)&amp;#39;, borderColor: &amp;#39;#ccc&amp;#39;, // 标题边框颜色 borderWidth: 0, // 标题边框线宽，单位px，默认为0（无边框） padding: 5, // 标题内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css itemGap: 10, // 主副标题纵向间隔，单位px，默认为10， textStyle: { fontSize: 18, fontWeight: &amp;#39;bolder&amp;#39;, color: &amp;#39;#333&amp;#39; // 主标题文字颜色 }, subtextStyle: { color: &amp;#39;#aaa&amp;#39; // 副标题文字颜色 } }, // 图例 legend: { orient: &amp;#39;horizontal&amp;#39;, // 布局方式，默认为水平布局，可选为： // &amp;#39;horizontal&amp;#39; ¦ &amp;#39;vertical&amp;#39; x: &amp;#39;center&amp;#39;, // 水平安放位置，默认为全图居中，可选为： // &amp;#39;center&amp;#39; ¦ &amp;#39;left&amp;#39; ¦ &amp;#39;right&amp;#39; // ¦ {number}（x坐标，单位px） y: &amp;#39;top&amp;#39;, // 垂直安放位置，默认为全图顶端，可选为： // &amp;#39;top&amp;#39; ¦ &amp;#39;bottom&amp;#39; ¦ &amp;#39;center&amp;#39; // ¦ {number}（y坐标，单位px） backgroundColor: &amp;#39;rgba(0,0,0,0)&amp;#39;, borderColor: &amp;#39;#ccc&amp;#39;, // 图例边框颜色 borderWidth: 0, // 图例边框线宽，单位px，默认为0（无边框） padding: 5, // 图例内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css itemGap: 10, // 各个item之间的间隔，单位px，默认为10， // 横向布局时为水平间隔，纵向布局时为纵向间隔 itemWidth: 20, // 图例图形宽度 itemHeight: 14, // 图例图形高度 textStyle: { color: &amp;#39;#333&amp;#39; // 图例文字颜色 } }, // 值域 dataRange: { orient: &amp;#39;vertical&amp;#39;, // 布局方式，默认为垂直布局，可选为： // &amp;#39;horizontal&amp;#39; ¦ &amp;#39;vertical&amp;#39; x: &amp;#39;left&amp;#39;, // 水平安放位置，默认为全图左对齐，可选为： // &amp;#39;center&amp;#39; ¦ &amp;#39;left&amp;#39; ¦ &amp;#39;right&amp;#39; // ¦ {number}（x坐标，单位px） y: &amp;#39;bottom&amp;#39;, // 垂直安放位置，默认为全图底部，可选为： // &amp;#39;top&amp;#39; ¦ &amp;#39;bottom&amp;#39; ¦ &amp;#39;center&amp;#39; // ¦ {number}（y坐标，单位px） backgroundColor: &amp;#39;rgba(0,0,0,0)&amp;#39;, borderColor: &amp;#39;#ccc&amp;#39;, // 值域边框颜色 borderWidth: 0, // 值域边框线宽，单位px，默认为0（无边框） padding: 5, // 值域内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css itemGap: 10, // 各个item之间的间隔，单位px，默认为10， // 横向布局时为水平间隔，纵向布局时为纵向间隔 itemWidth: 20, // 值域图形宽度，线性渐变水平布局宽度为该值 * 10 itemHeight: 14, // 值域图形高度，线性渐变垂直布局高度为该值 * 10 splitNumber: 5, // 分割段数，默认为5，为0时为线性渐变 color: [&amp;#39;#1e90ff&amp;#39;, &amp;#39;#f0ffff&amp;#39;],//颜色 //text:[&amp;#39;高&amp;#39;,&amp;#39;低&amp;#39;], // 文本，默认为数值文本 textStyle: { color: &amp;#39;#333&amp;#39; // 值域文字颜色 } }, toolbox: { orient: &amp;#39;horizontal&amp;#39;, // 布局方式，默认为水平布局，可选为： // &amp;#39;horizontal&amp;#39; ¦ &amp;#39;vertical&amp;#39; x: &amp;#39;right&amp;#39;, // 水平安放位置，默认为全图右对齐，可选为： // &amp;#39;center&amp;#39; ¦ &amp;#39;left&amp;#39; ¦ &amp;#39;right&amp;#39; // ¦ {number}（x坐标，单位px） y: &amp;#39;top&amp;#39;, // 垂直安放位置，默认为全图顶端，可选为： // &amp;#39;top&amp;#39; ¦ &amp;#39;bottom&amp;#39; ¦ &amp;#39;center&amp;#39; // ¦ {number}（y坐标，单位px） color: [&amp;#39;#1e90ff&amp;#39;, &amp;#39;#22bb22&amp;#39;, &amp;#39;#4b0082&amp;#39;, &amp;#39;#d2691e&amp;#39;], backgroundColor: &amp;#39;rgba(0,0,0,0)&amp;#39;, // 工具箱背景颜色 borderColor: &amp;#39;#ccc&amp;#39;, // 工具箱边框颜色 borderWidth: 0, // 工具箱边框线宽，单位px，默认为0（无边框） padding: 5, // 工具箱内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css itemGap: 10, // 各个item之间的间隔，单位px，默认为10， // 横向布局时为水平间隔，纵向布局时为纵向间隔 itemSize: 16, // 工具箱图形宽度 featureImageIcon: {}, // 自定义图片icon featureTitle: { mark: &amp;#39;辅助线开关&amp;#39;, markUndo: &amp;#39;删除辅助线&amp;#39;, markClear: &amp;#39;清空辅助线&amp;#39;, dataZoom: &amp;#39;区域缩放&amp;#39;, dataZoomReset: &amp;#39;区域缩放后退&amp;#39;, dataView: &amp;#39;数据视图&amp;#39;, lineChart: &amp;#39;折线图切换&amp;#39;, barChart: &amp;#39;柱形图切换&amp;#39;, restore: &amp;#39;还原&amp;#39;, saveAsImage: &amp;#39;保存为图片&amp;#39; } }, // 提示框 tooltip: { trigger: &amp;#39;item&amp;#39;, // 触发类型，默认数据触发，见下图，可选为：&amp;#39;item&amp;#39; ¦ &amp;#39;axis&amp;#39; showDelay: 20, // 显示延迟，添加显示延迟可以避免频繁切换，单位ms hideDelay: 100, // 隐藏延迟，单位ms transitionDuration: 0.</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-4-SpringBoot/res/SQL/SpringBoot.sql/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-4-SpringBoot/res/SQL/SpringBoot.sql/</guid><description/></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-4-SpringBoot/res/%E5%B0%81%E8%A3%85Excel%E5%B7%A5%E5%85%B7%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-4-SpringBoot/res/%E5%B0%81%E8%A3%85Excel%E5%B7%A5%E5%85%B7%E7%B1%BB/</guid><description>S01. 封装Excel工具类 package com.lsx.util; /** @author lsx */ public class EasyExcelUtil { /** * 生成Excel报表并自动下载 * * @param resp HTTP响应对象 * @param fileName Excel文件名 * @param sheetName Excel表格页标题 * @param c 数据泛型类型 * @param data 数据 */ @SneakyThrows public static void download(HttpServletResponse resp, String fileName, String sheetName, Class&amp;lt;?&amp;gt; c, Collection&amp;lt;?&amp;gt; data) { // 对文件名重新编码，以避免文件名中文乱码问题 fileName = URLEncoder.encode(fileName, StandardCharsets.UTF_8); sheetName = URLEncoder.encode(sheetName, StandardCharsets.UTF_8); // 设置响应MIME类型为Excel文件下载类型 resp.setContentType(&amp;#34;application/vnd.openxmlformats-officedocument&amp;#34; + &amp;#34;.spreadsheetml.sheet;charset=utf-8&amp;#34;); // 设置以附件的形式下载文件 resp.setHeader(&amp;#34;Content-disposition&amp;#34;, &amp;#34;attachment;filename=&amp;#34; + fileName); // 生成Excel报表并自动下载 EasyExcel.</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-4-SpringBoot/res/%E5%B0%81%E8%A3%85JWT%E5%B7%A5%E5%85%B7%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-4-SpringBoot/res/%E5%B0%81%E8%A3%85JWT%E5%B7%A5%E5%85%B7%E7%B1%BB/</guid><description>S01. 封装JWT工具类 心法: Token解析流程
sequenceDiagram autonumber title: Token解析流程 participant BI as 前端拦截器 participant SI as 后端拦截器 note over BI: 从sessionStorage中获取当前Token note over BI: 将当前Token设置到请求头中 BI -&amp;gt;&amp;gt; SI: 发送请求 note over SI: 判断是否携带正确的Token opt 未携带正确的Token SI --&amp;gt;&amp;gt; BI: 响应Token验证失败(1003) end opt 携带了正确的Token note over SI: 判断Token是否即将过期 opt Token过期时间大于30分钟 note over SI: 放行请求到目标方法并执行下单业务 end opt Token过期时间小于30分钟 SI --&amp;gt;&amp;gt; BI: 响应Token即将过期(1004)和一个新的Token note over BI: 当响应码是1004时，用新的Token替换旧的Token BI --&amp;gt;&amp;gt; SI: 携带新的Token，重新发送请求，重复第1步骤 end end 武技: 封装Token令牌工具类</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-4-SpringBoot/res/%E5%B0%81%E8%A3%85MinIO%E5%B7%A5%E5%85%B7%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-4-SpringBoot/res/%E5%B0%81%E8%A3%85MinIO%E5%B7%A5%E5%85%B7%E7%B1%BB/</guid><description>S01. 封装MinIO工具类 开发常量属性 Constant: package com.lsx.constant; /** @author lsx */ public interface MinioConst { /** 端点 */ String END_POINT = &amp;#34;http://192.168.40.77:9001&amp;#34;; /** 公钥 */ String ACCESS_KEY = &amp;#34;20tW6cOfZjzqOn2EtVKE&amp;#34;; /** 私钥 */ String SECRET_KEY = &amp;#34;eCY0zJQ6t7FoQfiKovFcjfrrOAdVvf7MMhE5jJJb&amp;#34;; /** 桶名 */ String BUCKET_NAME = &amp;#34;lesson-bucket&amp;#34;; } 封装MinIO工具类 MinioUtil: package com.lsx.util; /** @author lsx */ @Slf4j public class MinioUtil { /** Minio客户端 */ private static MinioClient minioClient; static { try { // 创建MinIO客户端 minioClient = new MinioClient(MinioConst.</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-5-Redis/frag/%E6%AE%8B%E5%8D%B7-Redis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-5-Redis/frag/%E6%AE%8B%E5%8D%B7-Redis/</guid><description>RedisForWin单机服务 搭建Redis服务端 武技: 在Windows中搭建Redis单机服务
下载安装Redis服务: 下载后直接解压缩即可: Redis官网提供 RedisForLinux GitHub提供 RedisForWindows 偶数版本号如3.0为稳定版，奇数版本号如3.1为不稳定版。 Redis2.8+支持Redis-sentinel哨兵 Redis3.0+支持redis-cluster集群。 解析Redis目录: redis-server.exe: 服务端程序，提供Redis服务。 redis-cli.exe: 客户端程序，通过它连接Redis服务和操作数据。 redis-check-aof.exe: 更新日志检查工具，用于对AOF文件进行修复。 redis-benchmark.exe: 性能测试工具，用于模拟客户端向服务端发送操作请求。 redis.windows.conf: Redis主配文件，在将Redis作为第三方软件使用时生效。 redis.windows-service.conf: Redis主配文件，在将Redis作为系统服务使用时生效。 启动Redis服务端 武技: 在Windows环境下启动Redis服务端
在Redis家目录新建 start 目录，将Redis的客户端和服务端的exe程序都拷贝到该目录下。 开发配置文件 start/6379.conf: 初始内容可以从 redis.windows.conf 中复制。 使用 findstr /V &amp;quot;#&amp;quot; redis.windows.conf 可去除注释查看内容。 # 配置Redis服务的IP地址，127.0.0.1用于自动获取本机IP地址 bind 127.0.0.1 # 配置Redis服务的端口号，是同一IP地址下，不同服务的标识 port 6379 # 配置连接超时时间，单位秒: 若该时间内，客户端和服务端都没有进行数据交互则断开连接 # 0表示永不断开 timeout 0 # 配置数据目录，RDB快照和AOF文件都会存储在这里 dir ./ # 配置客户端连接服务端时，需要的密码，该项配置用于提高安全性 requirepass 123 启动Redis服务端: 服务器运行需要一直保持CMD窗口。 # 进入start目录 cd D:\redis\redis-x64-3.</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-5-Redis/res/Jedis%E5%8D%95%E6%9C%BA%E5%B7%A5%E5%85%B7%E5%B0%81%E8%A3%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-5-Redis/res/Jedis%E5%8D%95%E6%9C%BA%E5%B7%A5%E5%85%B7%E5%B0%81%E8%A3%85/</guid><description>S01. 封装Jedis单机工具 封装单机Redis版本的Jedis连接工具: com.lsx.util.JedisStandaloneUtil
/** @author lsx */ public class JedisStandaloneUtil { /** Jedis连接池 */ private static final JedisPool jedisPool; /** Jedis超时时间 */ private static final int TIMEOUT = 10000; /** Redis主机地址 */ private static final String HOST = &amp;#34;192.168.40.77&amp;#34;; /** Redis端口号 */ private static final int PORT = 6379; /** Jedis连接池最大连接 */ private static final int MAX_TOTAL = 8; /** Jedis连接池最大阻塞时间 */ private static final long MAX_WAIT_MILLIS = 10000L; /** Jedis连接池最大空闲 */ private static final int MAX_IDLE = 8; /** Jedis连接池最小空闲 */ private static final int MIN_IDLE = 0; static { // 初始化Jedis连接池配置实例 JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-5-Redis/res/Jedis%E5%93%A8%E5%85%B5%E5%B7%A5%E5%85%B7%E5%B0%81%E8%A3%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-5-Redis/res/Jedis%E5%93%A8%E5%85%B5%E5%B7%A5%E5%85%B7%E5%B0%81%E8%A3%85/</guid><description>S01. 封装Jedis哨兵工具 封装哨兵Redis版本的Jedis连接工具： com.lsx.util.JedisSentinelUtil
/** @author lsx */ public class JedisSentinelUtil { /** Jedis超时时间 */ private static final int TIMEOUT = 10000; /** Jedis连接池最大连接 */ private static final int MAX_TOTAL = 8; /** Jedis连接池最大阻塞时间 */ private static final long MAX_WAIT_MILLIS = 10000L; /** Jedis连接池最大空闲 */ private static final int MAX_IDLE = 8; /** Jedis连接池最小空闲 */ private static final int MIN_IDLE = 0; /** 哨兵模式: Jedis哨兵连接池 */ private static final JedisSentinelPool jedisSentinelPool; /** 哨兵模式: 全部哨兵节点端口号集合，格式: [&amp;#34;IP:PORT&amp;#34;, &amp;#34;IP:PORT&amp;#34;, &amp;#34;IP:PORT&amp;#34;] */ private static final Set&amp;lt;String&amp;gt; SENTINEL_NODES = Set.</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-5-Redis/res/Jedis%E9%9B%86%E7%BE%A4%E5%B7%A5%E5%85%B7%E5%B0%81%E8%A3%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-5-Redis/res/Jedis%E9%9B%86%E7%BE%A4%E5%B7%A5%E5%85%B7%E5%B0%81%E8%A3%85/</guid><description>S01. 封装Jedis集群工具 测试哨兵Redis版本的Jedis连接工具： com.lsx.util.JedisClusterUtil
/** @author lsx */ public class JedisClusterUtil { /** Jedis超时时间 */ private static final int TIMEOUT = 10000; /** Jedis连接池最大连接 */ private static final int MAX_TOTAL = 8; /** Jedis连接池最大阻塞时间 */ private static final long MAX_WAIT_MILLIS = 10000L; /** Jedis连接池最大空闲 */ private static final int MAX_IDLE = 8; /** Jedis连接池最小空闲 */ private static final int MIN_IDLE = 0; /** 集群模式: Jedis集群连接池 */ private static final JedisCluster jedisCluster; /** 集群模式: 全部集群节点端口号，逗号分割 */ private static final Set&amp;lt;HostAndPort&amp;gt; CLUSTER_NODES = Set.</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-5-Redis/res/redis.conf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-5-Redis/res/redis.conf/</guid><description># Redis configuration file example. # # Note that in order to read the configuration file, Redis must be # started with the file path as first argument: # # ./redis-server /path/to/redis.conf # Note on units: when memory size is needed, it is possible to specify # it in the usual form of 1k 5GB 4M and so forth: # # 1k =&amp;gt; 1000 bytes # 1kb =&amp;gt; 1024 bytes # 1m =&amp;gt; 1000000 bytes # 1mb =&amp;gt; 1024*1024 bytes # 1g =&amp;gt; 1000000000 bytes # 1gb =&amp;gt; 1024*1024*1024 bytes # # units are case insensitive so 1GB 1Gb 1gB are all the same.</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-5-Redis/res/RedisUtil%E5%B7%A5%E5%85%B7%E5%B0%81%E8%A3%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-5-Redis/res/RedisUtil%E5%B7%A5%E5%85%B7%E5%B0%81%E8%A3%85/</guid><description>S01. 封装Redis工具 com.lsx.util.RedisUtil
/** @author lsx */ @Component public class RedisUtil { @Autowired private StringRedisTemplate stringRedisTemplate; /** * 获取 StringRedisTemplate 对象 * * @return StringRedisTemplate 对象 */ public StringRedisTemplate getStringRedisTemplate() { return this.stringRedisTemplate; } /** * COMMON: 按缓存名单删一条缓存记录 * * @param key 缓存名 */ public void del(String key) { stringRedisTemplate.delete(key); } /** * COMMON: 按缓存名的集合批删多条缓存记录 * * @param keys 缓存名的集合 */ public void del(Set&amp;lt;String&amp;gt; keys) { stringRedisTemplate.delete(keys); } /** * COMMON: 按缓存名查询该缓存记录是否存在 * * @param key 缓存名 * @return true表示缓存记录存在，false表示缓存记录不存在 */ public boolean exists(String key) { return Boolean.</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-6-ElasticSearch/frag/%E6%AE%8B%E5%8D%B7-ElasticSearch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-6-ElasticSearch/frag/%E6%AE%8B%E5%8D%B7-ElasticSearch/</guid><description>Windows搭建ES服务 在Windows上搭建ElasticSearch服务端需要依赖正确的JDK环境。 搭建ES单机服务端 武技: 在Windows上安装ElasticSearch服务端
下载 ES服务端 : res: elasticsearch-7.11.2-windows-x86_64.zip: 解压缩到硬盘。 启动ES服务端: 双击 @\bin\elasticsearch.bat: 提示 started 表示启动成功。 cli: localhost:9200: 访问ES服务端，默认9200端口。 搭建ES集群服务端 武技: 在Windows上搭建ES集群
创建集群目录 es-cluster: 拷贝两个ES服务端根目录到集群目录中: D:\elasticsearch\es-cluster\es-node-a: ES-A节点目录。 D:\elasticsearch\es-cluster\es-node-b: ES-B节点目录。 删除两个ES节点的 data 目录全部删除以保证节点数据一致性。 修改两个ES节点的主配 @/config/elasticsearch.yml: cluster.name: es-cluster: 集群名，默认 elasticsearch，必须保证两个ES节点的集群名一致。 node.name: es-node-a: 节点名，必须保证两个ES节点的名称不一致。 node.master: true: 该节点拥有成为master的资格。 node.data: true: 该节点允许存储数据。 network.host: 127.0.0.1: 该ES节点所在的服务器IP，0.0.0.0 表示允许所有IP对我访问。 http.port: 9201: 该ES节点的端口号，默认9200。 transport.tcp.port: 9301: 该ES节点的内部集群间通信端口号，必须保证与ES节点端口号不同。 discovery.zen.ping.unicast.hosts: [&amp;quot;127.0.0.1:9301&amp;quot;, &amp;quot;127.0.0.1:9302&amp;quot;]: 集群节点列表。 cluster.initial_master_nodes: es-node-a: 配置初始主节点名。 http.cors.enabled: true: 允许被跨域访问，默认false。 http.cors.allow-origin: &amp;quot;*&amp;quot;: 允许所有域名对我进行访问，值为RE表达式。 tips: 不要在yml中添加注释。 启动两个ES节点: 通过任一节点测试: cli: localhost:9201/9202: 分别查看两个节点信息。 cli: localhost:9201/_cat/health?</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-8-Nginx/frag/%E6%AE%8B%E5%8D%B7-Nginx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-8-Nginx/frag/%E6%AE%8B%E5%8D%B7-Nginx/</guid><description>Windows安装Nginx服务器 下载nginx for windows服务： res：nginx-1.20.2.zip：解压缩即可。 nginx启动须知：以下对 @/logs/nginx.pid 简称PID文件： 使用CMD命令启动nginx服务时，会自动生成PID文件，该文件用于记录nginx服务中master进程的ID号。 使用CMD命令关闭nginx服务时，会根据PID文件内容来结束nginx所有后台进程，然后自动删除PID文件。 多次启动nginx服务不会端口占用，但会覆盖PID文件中的内容，进而导致之前的nginx进程失联并泄露，不建议。 双击 nginx.exe 也可以启动nginx服务，但不会生成PID文件，此时只能在任务管理器中手动结束相关进程，不建议。 武技：启动并访问nginx服务器
启动nginx服务：先切换到nginx家目录： cmd：start nginx：启动nginx服务并生成PID文件。 cmd：tasklist | findstr &amp;quot;nginx*&amp;quot;：查看nginx服务启动的两个 nginx.exe 后台进程。 cmd：netstat -ano | findstr &amp;quot;80&amp;quot;：确认nginx默认的80端口是否正在被worker进程监听。 cmd：taskkill /pid 进程号 /f：强制结束某个后台进程。 cmd：nginx -s stop：关闭nginx服务，结束所有相关进程，并删除PID文件，若PID文件不存在则报错。 访问nginx服务器，查看环境界面： cli：localhost:80：默认端口号80，80可省略。</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-9-Vue/mindmap/Vue%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-9-Vue/mindmap/Vue%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</guid><description>Vue相关基础概念 Node 承载前端项目的服务器 相当于Tomcat服务器 NodeJs 运行在Node服务器上的JavaScript代码 相当于Java代码 NPM 基本概念 NodeJs的模块管理工具，也叫包管理工具 相当于Maven管理工具 Node服务器默认集成了NPM工具，但不一定是最新版 常用命令 查看全局模块安装位置 npm root -g 查看NPM配置信息列表 npm config list 查看NPM安装模块列表 全局模块 npm list -g 局部模块 npm list NPM安装模块 本地安装 npm install xxx 仅当node_modules中不存在该依赖时安装该依赖。 如果要安装模块的特定版本，可以在模块名后面加上@和版本号。 模块名不写入package.json中 npm i xxx 简写形式 npm i xxx@版本号 不指定版本号则默认安装最新版 全局安装 npm i xxx -g -g 同 -global 强制安装 npm i xxx -f 指定模块不管是否已经安装过，都要强制重新安装 -f 同 &amp;ndash;force 生产安装 npm i xxx -S 模块名将被添加到package.json中的dependencies -S 同 &amp;ndash;save 开发安装 npm i xxx -D 模块名将被添加到package.</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-9-Vue/mindmap/Vue%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-9-Vue/mindmap/Vue%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/</guid><description>Vue环境搭建流程 卸载Node 删除相关文件 C:\Users\用户\ 中的 .npmrc 文件 C:\Users\用户\ 中的 .cnpmrc 文件 可能不存在 C:\Users\用户\ 中的 .vuerc 文件 删除安装目录 Node安装目录及其中的全部文件 从控制面板卸载Node服务器 免安装版本的略过此步骤 A）通过NVM安装Node 先彻底卸载Node，否则安装失败 下载NVM管理器 下载地址 https://github.com/coreybutler/nvm-windows/releases/tag/1.1.12 下载文件 nvm-setup.exe 安装NVM管理器 傻瓜式安装 选择NVM路径 推荐 D:\node\nvm 选择NodeJs路径 推荐 D:\node\nodejs 确认环境变量 注意用户变量和环境变量都需要配置 NVM_HOME = D:\node\nvm NVM_SYMLINK = D:\node\nodejs PATH += %NVM_HOME%, %NVM_SYMLINK% 查看NVM版本 nvm -v 预期 1.1.12 安装指定的Node版本 nvm install 20.12.0 管理员模式命令 若速度过慢可用命令配镜像源 nvm node_mirror https://npm.taobao.org/mirrors/node/ nvm npm_mirror https://npm.taobao.org/mirrors/npm/ 查看当前已安装的Node版本 nvm ls *号表示当前正在用 切换Node版本 nvm use 20.</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-9-Vue/qa/JB3-9-Vue-QA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-9-Vue/qa/JB3-9-Vue-QA/</guid><description> 代码 含义 &amp;lt;p&amp;gt;{{ name }}&amp;lt;/div&amp;gt; &amp;lt;p v-html=&amp;quot;html&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;a v-bind:href=&amp;quot;to&amp;quot;&amp;gt;按钮&amp;lt;/a&amp;gt; &amp;lt;a :href=&amp;quot;to&amp;quot;&amp;gt;按钮&amp;lt;/a&amp;gt; &amp;lt;a v-on:click=&amp;quot;info&amp;quot;&amp;gt;按钮&amp;lt;/a&amp;gt; &amp;lt;a @click=&amp;quot;info&amp;quot;&amp;gt;按钮&amp;lt;/a&amp;gt; let a = ref(0) let a = shallowRef(0) let a = reactive({}) let a = shallowReactive({}) let a = computed(() =&amp;gt; a + 1) &amp;lt;p v-if=&amp;quot;score &amp;lt; 60&amp;quot;&amp;gt;不及格&amp;lt;/div&amp;gt; &amp;lt;p v-for=&amp;quot;n in 10&amp;quot;&amp;gt;{{ n }}&amp;lt;/span&amp;gt; &amp;lt;p v-for=&amp;quot;user in users&amp;quot; :key=&amp;quot;user['id']&amp;quot;&amp;gt;{{ user }}&amp;lt;/p&amp;gt; &amp;lt;p v-for=&amp;quot;(v, k, i) in user&amp;quot; :key=&amp;quot;user['k']&amp;quot;&amp;gt;{{ v }}&amp;lt;/p&amp;gt; &amp;lt;input v-model=&amp;quot;message&amp;quot; /&amp;gt; onBeforeMount(() =&amp;gt; {}) onMounted(() =&amp;gt; {}) watch(num, (n1, n2) =&amp;gt; { alert(n1 + n2) }) defineProps(['content'])</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-9-Vue/res/element-plus-2.4.2.css/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-9-Vue/res/element-plus-2.4.2.css/</guid><description>@charset &amp;#34;UTF-8&amp;#34;;:root{--el-color-white:#ffffff;--el-color-black:#000000;--el-color-primary-rgb:64,158,255;--el-color-success-rgb:103,194,58;--el-color-warning-rgb:230,162,60;--el-color-danger-rgb:245,108,108;--el-color-error-rgb:245,108,108;--el-color-info-rgb:144,147,153;--el-font-size-extra-large:20px;--el-font-size-large:18px;--el-font-size-medium:16px;--el-font-size-base:14px;--el-font-size-small:13px;--el-font-size-extra-small:12px;--el-font-family:&amp;#39;Helvetica Neue&amp;#39;,Helvetica,&amp;#39;PingFang SC&amp;#39;,&amp;#39;Hiragino Sans GB&amp;#39;,&amp;#39;Microsoft YaHei&amp;#39;,&amp;#39;微软雅黑&amp;#39;,Arial,sans-serif;--el-font-weight-primary:500;--el-font-line-height-primary:24px;--el-index-normal:1;--el-index-top:1000;--el-index-popper:2000;--el-border-radius-base:4px;--el-border-radius-small:2px;--el-border-radius-round:20px;--el-border-radius-circle:100%;--el-transition-duration:0.3s;--el-transition-duration-fast:0.2s;--el-transition-function-ease-in-out-bezier:cubic-bezier(0.645, 0.045, 0.355, 1);--el-transition-function-fast-bezier:cubic-bezier(0.23, 1, 0.32, 1);--el-transition-all:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);--el-transition-fade:opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-md-fade:transform var(--el-transition-duration) var(--el-transition-function-fast-bezier),opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-fade-linear:opacity var(--el-transition-duration-fast) linear;--el-transition-border:border-color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-box-shadow:box-shadow var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-color:color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-component-size-large:40px;--el-component-size:32px;--el-component-size-small:24px}:root{color-scheme:light;--el-color-white:#ffffff;--el-color-black:#000000;--el-color-primary:#409eff;--el-color-primary-light-3:#79bbff;--el-color-primary-light-5:#a0cfff;--el-color-primary-light-7:#c6e2ff;--el-color-primary-light-8:#d9ecff;--el-color-primary-light-9:#ecf5ff;--el-color-primary-dark-2:#337ecc;--el-color-success:#67c23a;--el-color-success-light-3:#95d475;--el-color-success-light-5:#b3e19d;--el-color-success-light-7:#d1edc4;--el-color-success-light-8:#e1f3d8;--el-color-success-light-9:#f0f9eb;--el-color-success-dark-2:#529b2e;--el-color-warning:#e6a23c;--el-color-warning-light-3:#eebe77;--el-color-warning-light-5:#f3d19e;--el-color-warning-light-7:#f8e3c5;--el-color-warning-light-8:#faecd8;--el-color-warning-light-9:#fdf6ec;--el-color-warning-dark-2:#b88230;--el-color-danger:#f56c6c;--el-color-danger-light-3:#f89898;--el-color-danger-light-5:#fab6b6;--el-color-danger-light-7:#fcd3d3;--el-color-danger-light-8:#fde2e2;--el-color-danger-light-9:#fef0f0;--el-color-danger-dark-2:#c45656;--el-color-error:#f56c6c;--el-color-error-light-3:#f89898;--el-color-error-light-5:#fab6b6;--el-color-error-light-7:#fcd3d3;--el-color-error-light-8:#fde2e2;--el-color-error-light-9:#fef0f0;--el-color-error-dark-2:#c45656;--el-color-info:#909399;--el-color-info-light-3:#b1b3b8;--el-color-info-light-5:#c8c9cc;--el-color-info-light-7:#dedfe0;--el-color-info-light-8:#e9e9eb;--el-color-info-light-9:#f4f4f5;--el-color-info-dark-2:#73767a;--el-bg-color:#ffffff;--el-bg-color-page:#f2f3f5;--el-bg-color-overlay:#ffffff;--el-text-color-primary:#303133;--el-text-color-regular:#606266;--el-text-color-secondary:#909399;--el-text-color-placeholder:#a8abb2;--el-text-color-disabled:#c0c4cc;--el-border-color:#dcdfe6;--el-border-color-light:#e4e7ed;--el-border-color-lighter:#ebeef5;--el-border-color-extra-light:#f2f6fc;--el-border-color-dark:#d4d7de;--el-border-color-darker:#cdd0d6;--el-fill-color:#f0f2f5;--el-fill-color-light:#f5f7fa;--el-fill-color-lighter:#fafafa;--el-fill-color-extra-light:#fafcff;--el-fill-color-dark:#ebedf0;--el-fill-color-darker:#e6e8eb;--el-fill-color-blank:#ffffff;--el-box-shadow:0px 12px 32px 4px rgba(0, 0, 0, 0.04),0px 8px 20px rgba(0, 0, 0, 0.08);--el-box-shadow-light:0px 0px 12px rgba(0, 0, 0, 0.12);--el-box-shadow-lighter:0px 0px 6px rgba(0, 0, 0, 0.12);--el-box-shadow-dark:0px 16px 48px 16px rgba(0, 0, 0, 0.08),0px 12px 32px rgba(0, 0, 0, 0.12),0px 8px 16px -8px rgba(0, 0, 0, 0.</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-9-Vue/res/element-plus-2.4.2.js/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-9-Vue/res/element-plus-2.4.2.js/</guid><description>/*! Element Plus v2.4.2 */ (function (global, factory) { typeof exports === &amp;#39;object&amp;#39; &amp;amp;&amp;amp; typeof module !== &amp;#39;undefined&amp;#39; ? factory(exports, require(&amp;#39;vue&amp;#39;)) : typeof define === &amp;#39;function&amp;#39; &amp;amp;&amp;amp; define.amd ? define([&amp;#39;exports&amp;#39;, &amp;#39;vue&amp;#39;], factory) : (global = typeof globalThis !== &amp;#39;undefined&amp;#39; ? globalThis : global || self, factory(global.ElementPlus = {}, global.Vue)); })(this, (function (exports, vue) { &amp;#39;use strict&amp;#39;; const FOCUSABLE_ELEMENT_SELECTORS = `a[href],button:not([disabled]),button:not([hidden]),:not([tabindex=&amp;#34;-1&amp;#34;]),input:not([disabled]),input:not([type=&amp;#34;hidden&amp;#34;]),select:not([disabled]),textarea:not([disabled])`; const isVisible = (element) =&amp;gt; { const computed = getComputedStyle(element); return computed.</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-9-Vue/res/vue-3.3.7.js/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-9-Vue/res/vue-3.3.7.js/</guid><description>var Vue = (function (exports) { &amp;#39;use strict&amp;#39;; function makeMap(str, expectsLowerCase) { const map = /* @__PURE__ */ Object.create(null); const list = str.split(&amp;#34;,&amp;#34;); for (let i = 0; i &amp;lt; list.length; i++) { map[list[i]] = true; } return expectsLowerCase ? (val) =&amp;gt; !!map[val.toLowerCase()] : (val) =&amp;gt; !!map[val]; } const EMPTY_OBJ = Object.freeze({}) ; const EMPTY_ARR = Object.freeze([]) ; const NOOP = () =&amp;gt; { }; const NO = () =&amp;gt; false; const onRE = /^on[^a-z]/; const isOn = (key) =&amp;gt; onRE.</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-9-Vue/res/Vue%E5%AE%89%E8%A3%85ApacheECharts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-9-Vue/res/Vue%E5%AE%89%E8%A3%85ApacheECharts/</guid><description>武技: 在Vue项目中整合ECharts
1. 局部安装ECharts # 切换到当前项目 D: cd D:\idea\workspace\java-book\v3-9-ssm-vue # 局部安装ECharts组件 npm install echarts@5.4.3 -S # 查看本项目中的npm模块（非全局） npm list 2. 测试ECharts 测试 - 布局： &amp;lt;div id=&amp;#34;main&amp;#34; style=&amp;#34;width: 600px; height: 400px&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; 测试 - 脚本： import {onMounted} from &amp;#34;vue&amp;#34;; import * as echarts from &amp;#39;echarts&amp;#39;; onMounted(() =&amp;gt; { // 基于准备好的dom，初始化echarts实例 let myChart = echarts.init(document.getElementById(&amp;#39;main&amp;#39;)); // 指定图表的配置项和数据 let option = { title: {text: &amp;#39;ECharts 入门示例&amp;#39;}, tooltip: {}, legend: {data: [&amp;#39;销量&amp;#39;]}, xAxis: {data: [&amp;#39;衬衫&amp;#39;, &amp;#39;羊毛衫&amp;#39;, &amp;#39;雪纺衫&amp;#39;, &amp;#39;裤子&amp;#39;, &amp;#39;高跟鞋&amp;#39;, &amp;#39;袜子&amp;#39;]}, yAxis: {}, series: [{name: &amp;#39;销量&amp;#39;, type: &amp;#39;bar&amp;#39;, data: [5, 20, 36, 10, 10, 20]}] }; // 使用刚指定的配置项和数据显示图表。 myChart.</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-9-Vue/res/Vue%E5%AE%89%E8%A3%85Axios/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-9-Vue/res/Vue%E5%AE%89%E8%A3%85Axios/</guid><description>S01. 安装Axios工具 武技: 在Vue项目中整合Axios工具
局部安装Axios工具: # 切换到当前项目 D: cd D:\idea\workspace\java-book\v3-9-ssm-vue # 安装Axios组件组件 npm install axios@1.6.7 -S # 查看本项目中的npm模块（非全局） npm list</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-9-Vue/res/Vue%E5%AE%89%E8%A3%85ElementPlus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-9-Vue/res/Vue%E5%AE%89%E8%A3%85ElementPlus/</guid><description>心法: Vue安装ElementPlus完整流程
flowchart LR n1[&amp;#34;安装&amp;lt;br/&amp;gt;EP组件库&amp;#34;] --&amp;gt; n2[&amp;#34;导入&amp;lt;br/&amp;gt;EP组件库&amp;#34;] --&amp;gt; n3[&amp;#34;安装&amp;lt;br/&amp;gt;EP图标库&amp;#34;] --&amp;gt; n4[&amp;#34;导入&amp;lt;br/&amp;gt;EP图标库&amp;#34;] --&amp;gt; n5[&amp;#34;安装&amp;lt;br/&amp;gt;EP暗黑库&amp;#34;] --&amp;gt; n6[&amp;#34;引入&amp;lt;br/&amp;gt;EP暗黑样式文件&amp;#34;] S01. 安装组件库 武技: 在Vue项目中安装ElementPlus组件库
1. 安装ElementPlus组件库 # 切换到当前项目 D: cd D:\idea\workspace\java-book\v3-9-ssm-vue # 局部安装ElementPlus组件库 npm install element-plus@2.5.3 -S # 查看安装的依赖 npm list 2. 导入ElementPlus组件库 main.js
// ElementPlus组件库: 核心对象，核心CSS，显隐CSS import ElementPlus from &amp;#39;element-plus&amp;#39;; import &amp;#39;element-plus/dist/index.css&amp;#39;; import &amp;#39;element-plus/theme-chalk/display.css&amp;#39;; // 使用ElementPlus组件库 const app = createApp(App); app.use(store).use(router).use(ElementPlus).mount(&amp;#39;#app&amp;#39;); S02. 安装图标库 武技: 在Vue项目中安装ElementPlus图标库
1. 安装ElementPlus图标库 # 切换到当前项目 D: cd D:\idea\workspace\java-book\v3-9-ssm-vue # 局部安装ElementPlus图标库 npm install @element-plus/icons-vue@2.</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-9-Vue/res/Vue%E5%AE%89%E8%A3%85MavonEditor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-9-Vue/res/Vue%E5%AE%89%E8%A3%85MavonEditor/</guid><description>S01. MavonEditor E01. 安装编辑器 # 切换到当前项目 D: cd D:\idea\workspace\java-book\v3-9-ssm-vue # 局部安装 MavonDditor 组件：注意不要安装@latest版本，它会安装2.10.4的版本 npm i mavon-editor@3.0.1 --S # 查看本项目中的npm模块（非全局） npm list E02. 导入MavonEditor组件库 main.js
// MavonEditor编辑器: 核心对象，核心CSS import mavonEditor from &amp;#39;mavon-editor&amp;#39;; import &amp;#39;mavon-editor/dist/css/index.css&amp;#39;; // 使用 MavonEditor 编辑器组件库 const app = createApp(App); app.use(mavonEditor).mount(&amp;#39;#app&amp;#39;); E03. 测试编辑器 测试 - 布局: &amp;lt;!--MD编辑器--&amp;gt; &amp;lt;section style=&amp;#34;height: 300px; margin: 50px&amp;#34;&amp;gt; &amp;lt;mavon-editor ref=&amp;#34;myEditor&amp;#34; v-model=&amp;#34;content&amp;#34;/&amp;gt; &amp;lt;/section&amp;gt; 测试 - 脚本: import {QuillEditor} from &amp;#39;@vueup/vue-quill&amp;#39; import &amp;#39;@vueup/vue-quill/dist/vue-quill.snow.css&amp;#39;; import {ref, shallowRef} from &amp;#34;vue&amp;#34;; // 当前富文本编辑器对象 const mavonEditorRef = ref(); let content = shallowRef(&amp;#39;&amp;#39;); S02.</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-9-Vue/res/Vue%E5%AE%89%E8%A3%85QuillEditor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-9-Vue/res/Vue%E5%AE%89%E8%A3%85QuillEditor/</guid><description>E01. 安装模块 1. 安装编辑器 # 切换到当前项目 D: cd D:\idea\workspace\java-book\v3-9-ssm-vue # 局部安装QuillEditor组件 npm i @vueup/vue-quill@1.2.0 -S # 查看本项目中的npm模块（非全局） npm list 2. 测试编辑器 测试 - 布局: &amp;lt;!--富文本编辑器--&amp;gt; &amp;lt;section style=&amp;#34;height: 300px; margin: 50px&amp;#34;&amp;gt; &amp;lt;QuillEditor ref=&amp;#34;myQuillEditor&amp;#34; :toolbar=&amp;#34;toolbar&amp;#34; content-type=&amp;#39;html&amp;#39; placeholder=&amp;#34;请输入&amp;#34; @update:content=&amp;#34;onEditorChange($event)&amp;#34;/&amp;gt; &amp;lt;/section&amp;gt; &amp;lt;!--提交按钮--&amp;gt; &amp;lt;el-button type=&amp;#34;button&amp;#34; @click=&amp;#34;submit&amp;#34;&amp;gt;{{ curLength }}/500 提交&amp;lt;/el-button&amp;gt; 测试 - 脚本: import {QuillEditor} from &amp;#39;@vueup/vue-quill&amp;#39; import &amp;#39;@vueup/vue-quill/dist/vue-quill.snow.css&amp;#39;; import {shallowRef} from &amp;#34;vue&amp;#34;; // 当前富文本编辑器对象 let myQuillEditor = shallowRef(); // 当前QuillEditor中的TEXT内容大小 let curLength = shallowRef(0); // QuillEditor自定义工具栏选项 const toolbar = [ [&amp;#39;bold&amp;#39;, &amp;#39;italic&amp;#39;, &amp;#39;underline&amp;#39;, &amp;#39;strike&amp;#39;], // 有序列表，无序列表 [{list: &amp;#39;ordered&amp;#39;}, {list: &amp;#39;bullet&amp;#39;}], // 标题 [{header: [1, 2, 3, 4, 5, 6, false]}], // 前景色，背景色 [{color: []}, {background: []}], // 对齐方式 [{align: []}], ] // 当QuillEditor内容改变时触发 function onEditorChange(e) { curLength.</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-9-Vue/res/Vue%E5%AE%89%E8%A3%85Vant/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-9-Vue/res/Vue%E5%AE%89%E8%A3%85Vant/</guid><description>S01. 安装Vant 武技: 在Vue项目中安装Vant组件库
局部安装Vant组件库: # 进入子项目 D: cd D:\idea\workspace\java-book\v3-9-ssm-vue # 安装Vant组件 npm i vant@4.6.0 -S; # 安装插件: 可以自动引入组件，并按需引入组件的样式 npm i @vant/auto-import-resolver@1.1.0 -D; npm i unplugin-vue-components@0.24.1 -D; npm i unplugin-auto-import@0.17.5 -D; # 查看本项目中的npm模块（非全局） npm list S02. 配置Vant 武技: 在Vue项目中配置Vant组件库
E01. 配置Vant插件 @/vue.config.js
// vant相关 const { VantResolver } = require(&amp;#39;@vant/auto-import-resolver&amp;#39;); const Components = require(&amp;#39;unplugin-vue-components/webpack&amp;#39;); module.exports = defineConfig({ // .. // 配置Vant插件: 它可以自动引入组件，并按需引入组件的样式 configureWebpack: { plugins: [ Components({ resolvers: [VantResolver()] }), ], }, }) E02.</description></item><item><title/><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-9-Vue/res/Vue%E5%AE%89%E8%A3%85XGPlayer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-9-Vue/res/Vue%E5%AE%89%E8%A3%85XGPlayer/</guid><description>S01. 安装模块 1. 安装播放器 # 切换到当前项目 D: cd D:\idea\workspace\java-book\v3-9-ssm-vue # 局部安装XGPlayer组件 npm install xgplayer@3.0.11 -S # 查看本项目中的npm模块（非全局） npm list 2. 测试播放器 测试 - 布局: &amp;lt;article style=&amp;#34;margin: 50px auto;width: 600px;height: 337px;&amp;#34;&amp;gt; &amp;lt;div id=&amp;#34;player&amp;#34;/&amp;gt; &amp;lt;/article&amp;gt; 测试 - 脚本: // 西瓜播放器: 核心实例，核心CSS，弹幕插件，弹幕CSS import Player from &amp;#39;xgplayer&amp;#39;; import &amp;#39;xgplayer/dist/index.min.css&amp;#39;; import Danmu from &amp;#39;xgplayer/es/plugins/danmu&amp;#39;; import &amp;#39;xgplayer/es/plugins/danmu/index.css&amp;#39;; import {onMounted} from &amp;#34;vue&amp;#34;; // 西瓜播放器 let player = null; // 初始化西瓜播放器 function initPlayer() { // 欢迎弹幕配置 const welcomeDanmu = { duration: 15000, // 弹幕持续显示时间，毫秒，最低为5000 id: &amp;#39;1&amp;#39;, // 弹幕ID，必须唯一 start: 3000, // 弹幕出现时间，毫秒 prior: true, // 该条弹幕优先显示，默认false color: true, // 该条弹幕为彩色弹幕，默认false txt: &amp;#39;一大波弹幕即将来袭&amp;#39;, // 弹幕内容 style: {color: &amp;#39;red&amp;#39;, fontSize: &amp;#39;20px&amp;#39;, padding: &amp;#39;20px&amp;#39;}, // 弹幕样式 mode: &amp;#39;scroll&amp;#39; // 显示模式，top顶部居中，bottom底部居中，scroll滚动，默认为scroll }; // 西瓜播放器配置 const config = { id: &amp;#39;player&amp;#39;, // 绑定DOM元素的ID值 url: &amp;#39;http://192.</description></item><item><title>JB3-1-MyBatis</title><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-1-MyBatis/JB3-1-MyBatis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-1-MyBatis/JB3-1-MyBatis/</guid><description>Java道经第3卷 - 第1阶 - v3-1-ssm-mybatis - MyBatis
CH01. MyBatis基础入门 心法: MyBatis
MyBatis是一个底层半封装了JDBC的持久层的开源ORM框架。 MyBatis前身是Apache的iBatis项目，2010年迁移到了GoogleCode并改名为MyBatis，2013年11月迁移到Github。 MyBatis封装了驱动，连接，Statement等业务代码，但不封装SQL语句。 MyBatis支持注解或XML方式单独开发SQL语句。 武技: 准备MyBatis测试数据
在数据库中创建测试数据库，表以及数据: -- db create database mybatis character set utf8mb4; use mybatis; -- table drop table if exists mybatis.student; create table if not exists mybatis.student ( student_id int auto_increment comment &amp;#39;学生表主键&amp;#39;, real_name varchar(128) not null default &amp;#39;&amp;#39; comment &amp;#39;学生真实姓名&amp;#39;, gender tinyint not null default 0 comment &amp;#39;学生性别，0女，1男，2保密&amp;#39;, phone char(11) not null default &amp;#39;&amp;#39; comment &amp;#39;学生手机号&amp;#39;, fk_clazz_id int comment &amp;#39;班级表外键&amp;#39;, create_time bigint not null default 0 comment &amp;#39;首次创建时间，时间戳&amp;#39;, modify_time bigint not null default 0 comment &amp;#39;最后修改时间，时间戳&amp;#39;, primary key (student_id), unique (phone), unique (real_name) ) comment &amp;#39;学生表&amp;#39;; drop table if exists mybatis.</description></item><item><title>JB3-2-Spring</title><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-2-Spring/JB3-2-Spring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-2-Spring/JB3-2-Spring/</guid><description>[!NOTE] Java道经第3卷 - 第2阶 - Spring v3-2-ssm-spring
S01. Spring基础入门 心法: Spring
Spring是2003年兴起的一个轻量级的Java开源框架，用于管理MVC架构中的控制层和模型层，它提供了一组强大的功能和工具，使得开发者能够更加容易地构建高效、可维护和可扩展的 Java 应用程序，核心包括: SpringCore模块：提供了IOC和DI的支持，用于管理对象以及对象间的依赖关系。 SpringAOP模块：提供了AOP的支持，用于解耦业务代码和切面代码。 SpringContext模块：提供了BeanFactory的功能，是核心模块的拓展。 SpringJDBC模块：提供了JDBC的支持，用于访问和操作数据库。 SpringORM模块：提供了对ORM框架的支持，如Mybatis、JPA等。 SpringWeb模块：提供构建Web应用所需的各种特性和工具，如SpringMVC，Servlet等。 SpringTest模块：提供了对单元测试和集成测试的支持，如JUnit等。 Spring支持基于XML的配置，基于注解的配置和基于纯Java的配置这三种开发方式。 Spring中使用到了大量的设计模式： 设计模式 描述 代理模式 AOP中使用到了CGLIB动态代理 单例模式 Spring配置文件中定义的bean默认为单例模式 模板方法 用来解决代码重复的问题，如RestTemplate, JmsTemplate, JpaTemplate等 工厂模式 Spring通过BeanFactory或ApplicationContext等容器来创建和管理Bean对象 E01. Spring基础配通 武技: 在 v3-2-ssm-spring 子项目中整合Spring框架
1. 引入相关依赖 在父项目中锁定版本: pom.xml
&amp;lt;junit-version&amp;gt;4.13.2&amp;lt;/junit-version&amp;gt; &amp;lt;lombok-version&amp;gt;1.18.24&amp;lt;/lombok-version&amp;gt; &amp;lt;hutool-version&amp;gt;5.8.14&amp;lt;/hutool-version&amp;gt; &amp;lt;spring-version&amp;gt;5.2.15.RELEASE&amp;lt;/spring-version&amp;gt; 在父项目中管理依赖: pom.xml
&amp;lt;!--junit--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${junit-version}&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--lombok--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${lombok-version}&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--hutool-all--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;cn.hutool&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;hutool-all&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${hutool-version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!</description></item><item><title>JB3-3-SpringMVC</title><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-3-SpringMVC/JB3-3-SpringMVC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-3-SpringMVC/JB3-3-SpringMVC/</guid><description>[!NOTE] Java道经第3卷 - 第3阶 - SpringMVC v3-3-ssm-springmvc
S01. SpringMVC基础入门 心法: SpringMVC
SpringMVC是Spring框架的控制层技术，本质是一个Servlet组件。 SpringMVC核心是前端控制器 org.springframework.web.servlet.DispatcherServlet DispatcherServlet负责管理和调用其它组件以处理用户的HTTP请求，降低组件间的耦合度。 E01. SpringMVC底层流程 心法: SpringMVC底层流程
当浏览器请求符合前端控制器规则时，WEB服务器会将其转交给前端控制器。 前端控制器调用处理器映射器 HandlerMapping，该组件主要负责查找: 根据请求URL找到某自定义Handler，将其和拦截器（若有）封装成执行链并返回。 全名 org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping 前端控制器调用处理器适配器 HandlerAdapter，该组件主要负责执行: 依次执行执行链中拦截器和Handler并返回一个ModelAndView对象。 全名 org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter 前端控制器调用视图解析器 ViewResolver，该组件主要负责解析结果: 将ModelAndView中的逻辑视图名拼接前后缀后解析为物理视图名，并返回View对象。 全名 org.springframework.web.servlet.view.InternalResourceViewResolver 前端控制器根据View组装HTML页面响应给浏览器，浏览器渲染页面: 渲染: 浏览器解析HTML，构建DOM树，整合CSS和JS，布局，绘制等过程。 graph LR B((浏览器)) --发送请求--&amp;gt; f{分析请求&amp;lt;br/&amp;gt;是否指向&amp;lt;br/&amp;gt;Handler}; f --是--&amp;gt; DS(前端控制器&amp;lt;br/&amp;gt;DispatcherServlet); f --否--&amp;gt; RES(静态资源) --响应--&amp;gt; B; DS --传递请求--&amp;gt; HM(处理器映射器HandlerMapping&amp;lt;br/&amp;gt;负责寻找Handler，封装HandlerChain); HM --返回HandlerChain--&amp;gt; DS; DS --传递HandlerChain--&amp;gt; HA(处理器适配器HandlerAdapter&amp;lt;br/&amp;gt;负责执行HandlerChain); HA --返回ModelAndView--&amp;gt; DS; DS --传递ModelAndView--&amp;gt; VR(视图解析器ViewResolver&amp;lt;br/&amp;gt;负责根据ModelAndView解析出View对象); VR --返回View对象--&amp;gt; DS; DS --响应--&amp;gt; B; E02.</description></item><item><title>JB3-4-SpringBoot</title><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-4-SpringBoot/JB3-4-SpringBoot/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-4-SpringBoot/JB3-4-SpringBoot/</guid><description>[!NOTE] Java道经第3卷 - 第4阶 - SpringBoot v3-4-ssm-springboot
S01. SpringBoot基础入门 心法: SpringBoot 基本概念
SpringBoot是由Pivotal团队提供的基于Spring框架的轻量级应用开发框架，包含Spring全部功能。 SpringBoot的主要目的是简化Spring应用的开发和部署过程，从而提高开发和部署效率。 SpringBoot优势 描述 减少配置文件 SpringBoot大量使用注解来替代繁琐复杂的XML配置，大大地提高了开发效率和开发体验。 自动装配组件 SpringBoot可以自动将第三方组件的Bean装载进Spring容器，无需手写Bean的装配配置。 应用拓展性高 SpringBoot针对常见场景提供了丰富的启动依赖集合 starter，以支持快速开发和部署应用程序。 提高部署效率 SpringBoot项目内嵌Tomcat，Jetty等容器，不仅可以更快速便捷地将应用部署到各种云平台，Docker等环境中，而且以Jar包的形式独立运行和部署的项目，启动速度会更快。 面向生产环境 SpringBoot提供了很多面向生产环境的功能，如管理端点、健康检查、指标收集，应用监控等。 E01. SpringBoot项目搭建 心法: SpringBoot项目的三种创建方式
使用 官方在线工具 创建SpringBoot项目，没有IDEA时推荐该方式。 使用IDEA创建SpringBoot项目: 创建过程中直接选择 Spring Initializr 进行快速搭建，工作时推荐该方式。 使用IDEA创建SpringBoot项目: 先创建MavenJar项目，然后再改造为SpringBoot项目，学习时推荐该方式。 武技: 手动创建MavenJar项目 v3-4-ssm-springboot/springboot-start
1. 添加三方依赖 在父项目中锁定版本： pom.xml
&amp;lt;junit-version&amp;gt;4.13.2&amp;lt;/junit-version&amp;gt; &amp;lt;lombok-version&amp;gt;1.18.24&amp;lt;/lombok-version&amp;gt; &amp;lt;hutool-version&amp;gt;5.8.14&amp;lt;/hutool-version&amp;gt; &amp;lt;spring-boot-version&amp;gt;2.3.12.RELEASE&amp;lt;/spring-boot-version&amp;gt; 在父项目中管理依赖: pom.xml
&amp;lt;!--junit--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${junit-version}&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--lombok--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${lombok-version}&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--hutool-all--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;cn.</description></item><item><title>JB3-5-Redis</title><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-5-Redis/JB3-5-Redis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-5-Redis/JB3-5-Redis/</guid><description>Java道经第3卷 - 第5阶 - v3-5-ssm-redis - Redis
S01. Redis基础入门 E01. 基础概念入门 1. NoSQL基础概念 心法: NoSQL 全称 Not Only SQL，不止于SQL
NoSQL是一种泛指非关系型数据库的全新理念，如键值对结构的Redis，文档结构的MongoDB，图形结构的Neo4j等。 flowchart LR n1[&amp;#34;NoSQL特点&amp;#34;] n1 -.- n2[&amp;#34;高扩展&amp;#34;] -.- n2a[&amp;#34;数据之间无关联，故非常容易进行修改和扩展&amp;#34;] n1 -.- n3[&amp;#34;高性能&amp;#34;] -.- n3a[&amp;#34;数据结构简单，在海量数据量场景下具有高读写性能&amp;#34;] n1 -.- n4[&amp;#34;更灵活&amp;#34;] -.- n4a[&amp;#34;无需事前建立表结构，更灵活的操作数据，避免繁琐的表，字段的关系操作&amp;#34;] n1 -.- n5[&amp;#34;高可用&amp;#34;] -.- n5a[&amp;#34;通常采用分布式架构，可以在多台服务器上部署，实现水平扩展和高可用性&amp;#34;] 2. Redis技术特点 心法: Redis缓存中间件 - 一款基于C语言开发的免费开源的缓存数据库
Redis目前被github，twitter，stackOverFlow，阿里巴巴，百度，美团，搜狐，新浪微博等项目使用: flowchart LR n1[&amp;#34;Redis特点&amp;#34;] n1 -.- n2[&amp;#34;原子操作&amp;#34;] -.- n2a[&amp;#34;Redis是单线程的，避免了并发问题和线程切换消耗&amp;#34;] n1 -.- n3[&amp;#34;内存存储&amp;#34;] -.- n3a[&amp;#34;数据默认保存在内存，官测50个并发执行10W个请求时，读速11W次/s，写速8.1W次/s&amp;#34;] n1 -.- n4[&amp;#34;多种场景&amp;#34;] -.- n4a[&amp;#34;常用于缓存热点数据，高效计数，秒杀限购，分布式锁等场景&amp;#34;] n1 -.</description></item><item><title>JB3-6-ElasticSearch</title><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-6-ElasticSearch/JB3-6-ElasticSearch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-6-ElasticSearch/JB3-6-ElasticSearch/</guid><description>[!NOTE] Java道经第3卷 - 第6阶 - ElasticSearch v3-6-ssm-elasticsearch
S01. ES基础入门 武技: 创建 v3-6-ssm-elasticsearch 子项目
在父项目中锁定版本: &amp;lt;junit-version&amp;gt;4.13.2&amp;lt;/junit-version&amp;gt; &amp;lt;lombok-version&amp;gt;1.18.24&amp;lt;/lombok-version&amp;gt; &amp;lt;hutool-version&amp;gt;5.8.14&amp;lt;/hutool-version&amp;gt; &amp;lt;spring-boot-version&amp;gt;2.3.12.RELEASE&amp;lt;/spring-boot-version&amp;gt; 在父项目中管理依赖: &amp;lt;!--junit--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${junit-version}&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--lombok--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${lombok-version}&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--hutool-all--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;cn.hutool&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;hutool-all&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${hutool-version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--spring-boot-starter-parent--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${spring-boot-version}&amp;lt;/version&amp;gt; &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt; &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; 在子项目中引入依赖: &amp;lt;!--junit--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--lombok--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--hutool-all--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;cn.hutool&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;hutool-all&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--spring-boot-starter-test--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 开发启动类: com.</description></item><item><title>JB3-7-MongoDB</title><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-7-MongoDB/JB3-7-MongoDB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-7-MongoDB/JB3-7-MongoDB/</guid><description>[!NOTE] Java道经第3卷 - 第7阶 - MongoDB v3-7-ssm-mongodb
S01. Mongo基础入门 E01. Mongo概念入门 心法: MongoDB
MongoDB是一个由C++语言编写的，基于分布式文件存储的数据库: MongoDB是面向文档存储的数据库，文档类似于JSON对象，数据结构由键值对组成。 MongoDB旨在为WEB应用提供可扩展的高性能数据存储解决方案。 MongoDB是一个介于关系数据库和非关系数据库之间的产品： MongoDB是非关系数据库当中功能最丰富，最像关系数据库的。 MongoDB支持支持索引，支持复杂查询。 MongoDB不支持连表操作，但支持文档数据嵌套。 1. Mongo对应MySQL MongoDB角色 中文 对应RDBMS中的 database 数据库 database 数据库 collection 集合 table 表格 document 文档 row 表行 field 字段 column 表列 index 索引 index 索引 primary key 主键 primary key 主键 E02. Mongo容器搭建 1. 准备相关目录 # 创建Mongo相关目录 mkdir -p /opt/mongo/data chmod -R 777 /opt/mongo/data 2. 创建运行容器 # 创建并启动Mongo容器 # args: `--auth`: 需要账号密码访问Mongo数据库 docker run -itd --name mongo --network host \ -v /opt/mongo/data:/data \ mongo:6.</description></item><item><title>JB3-8-Nginx</title><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-8-Nginx/JB3-8-Nginx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-8-Nginx/JB3-8-Nginx/</guid><description>[!NOTE] Java道经第3卷 - 第8阶 - Nginx v3-8-ssm-nginx
S01. Nginx基础入门 E01. 基础概念 心法: Nginx
Nginx是一款开源的服务器和反向代理Web服务器，邮件服务器，支持很多第三方的模块扩展。 1. 启动模式 心法: Nginx服务端启动模式
Nginx服务端采取多进程模式，启动Nginx服务时，后台会至少启动2个进程。 进程类型 中文 描述 Master 守护进程 负责向Worker转发外界信号负责监控Worker状态，当Worker异常时会自动重启新的Worker进程 Worker 工作进程 负责监听端口和处理用户请求Worker之间相互隔离独立Worker数量建议配置与CPU核数一致 2. 正向代理 心法: 正向代理 - 客户端的代理，对客户端负责
客户端发送请求到代理服务器，代理服务器转发请求到具体服务器，响应也是原路返回。 正向代理优势 描述 破解限制 某服务器限制客户端直接访问则可以找个可访问的代理服务器来访问该服务器如KX上网 加速访问 电信客户端访问联通服务器太慢则可以找个电信联通都能访问的代理服务器调节如游戏加速器 缓存数据 每次请求获取的数据都可以缓存到代理服务器中后续相同的请求可以直接从缓存中获取 保护客户端隐私 服务端仅知道请求来自于哪个代理服务器但并不知道请求具体来自于哪个客户端 3. 反向代理 心法: 反向代理 - 服务端的代理，对服务端负责
代理流程: 代理服务器接收到请求之后，按一定规则分发给某个具体的服务器，响应也是原路返回。 反向代理优势 描述 负载均衡 代理服务器可以使用多种负载均衡策略分发请求，分摊服务器集群的压力 保护服务端隐私 客户端仅知道请求发送给了哪个代理服务器但并不知道请求具体由哪台服务器进行处理 E02. 容器搭建 武技: 在Docker中搭建单机Nginx容器
1. 创建相关目录 # 创建Nginx相关目录 mkdir -p /opt/nginx/conf; mkdir -p /opt/nginx/logs; mkdir -p /opt/nginx/static; chmod -R 777 /opt/nginx; 2.</description></item><item><title>JB3-9-Vue</title><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-9-Vue/JB3-9-Vue/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-9-Vue/JB3-9-Vue/</guid><description>[!NOTE] Java道经第3卷 - 第9阶 - Vue v3-9-ssm-vue
S01. Vue基础入门 E01. Vue概念入门 心法: Vue
Vue是一套用于构建用户界面的渐进式框架，Vue组件使用 .vue 作为文件后缀: Vue文件使用 &amp;lt;template&amp;gt; 划分HTML代码开发区。 Vue文件使用 &amp;lt;style&amp;gt; 划分CSS/SCSS代码开发区。 Vue文件使用 &amp;lt;script&amp;gt; 划分JS代码开发区。 Vue底层采用MVVM架构，不允许直接操作DOM树，而是采用数据驱动DOM的方式工作。 MVVM架构 对比MVC架构 描述 代码所属区域 Model 模型层 负责定义数据 &amp;lt;script&amp;gt; ViewModel 控制层 负责连接V层和M层 &amp;lt;script&amp;gt; View 视图层 负责DOM元素的开发 &amp;lt;template&amp;gt; + &amp;lt;style&amp;gt; 武技: 测试Vue非脚手架开发方式
开发一个测试的HTML页面: 自行引入 vue-3.3.7.js（必选） 自行引入 element-plus-2.4.2.js（可选） 自行引入 element-plus-2.4.2.css（可选） &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;script src=&amp;#34;vue-3.3.7.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;element-plus-2.4.2.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;element-plus-2.4.2.css&amp;#34;&amp;gt; &amp;lt;title&amp;gt;测试Vue非脚手架开发方式&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;el-button&amp;gt;{{message}}&amp;lt;/el-button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; const App = { data(){ return{ message: &amp;#39;登录&amp;#39; } } } // 使用ElementPlus库，并挂载 div Vue.</description></item><item><title>MinIO</title><link>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-4-SpringBoot/res/Docker%E5%AE%89%E8%A3%85MinIO/Docker%E5%AE%89%E8%A3%85MinIO/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lsx2216.netlify.app/%E7%AC%AC3%E9%98%B6%E6%AE%B5-SSM/JB3-4-SpringBoot/res/Docker%E5%AE%89%E8%A3%85MinIO/Docker%E5%AE%89%E8%A3%85MinIO/</guid><description>S01. 安装MinIO容器 武技: 在Docker中安装一个单机的MinIO容器
准备MinIO的相关目录: # 准备MinIO相关目录 mkdir -p /opt/minio/conf; mkdir -p /opt/minio/data; chmod 777 -R /opt/minio; 创建并运行MinIO单机容器: # 拉取镜像（二选一） docker pull minio/minio:RELEASE.2023-08-31T15-31-16Z; docker pull registry.cn-hangzhou.aliyuncs.com/lsx/minio:2023; # 创建并运行MinIO容器 # arg: `-e &amp;#34;MINIO_ACCESS_KEY=minioadmin&amp;#34;`: 访问账号 # arg: `-e &amp;#34;MINIO_SECRET_KEY=minioadmin&amp;#34;`: 访问密码 # arg: `server /data`: 将数据存储在data目录中 # arg: `--console-adress`: 控制台访问地址 # arg: `--address`: API访问地址 # 账号长度必须大于等于5，密码长度必须大于等于8 docker run --name minio -d -p 9000:9000 -p 9001:9001 --network my-net \ -e &amp;#34;MINIO_ACCESS_KEY=minioadmin&amp;#34; \ -e &amp;#34;MINIO_SECRET_KEY=minioadmin&amp;#34; \ -v /opt/minio/conf:/root/.</description></item></channel></rss>